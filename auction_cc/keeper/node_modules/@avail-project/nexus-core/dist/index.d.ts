import * as _nexus_commons from './commons';
import { ExecuteParams, ExecuteResult, ExecuteSimulation, Network, SupportedChainsResult, SUPPORTED_CHAINS_IDS, BridgeAndExecuteParams, BridgeAndExecuteResult, BridgeAndExecuteSimulationResult, formatBalance, parseUnits, formatUnits, isValidAddress, truncateAddress, chainIdToHex, hexToChainId, getChainMetadata, formatTokenAmount, formatTestnetTokenAmount, SUPPORTED_CHAINS, NetworkConfig, ChainListType, SDKConfig, EthereumProvider, OnAllowanceHook, OnIntentHook, NexusNetwork, BridgeQueryInput, ExactInSwapInput, SwapInputOptionalParams, ExactOutSwapInput, RequestArguments, TxOptions, TransferQueryInput, EVMTransaction, Chain, UserAsset, BridgeParams, BridgeResult, TransferParams, TransferResult, SwapResult, SimulationResult, RequestForFunds, AllowanceResponse } from './commons';
export * from './commons';
export { AllowanceHookSource, AllowanceResponse, BridgeAndExecuteParams, BridgeAndExecuteResult, BridgeAndExecuteSimulationResult, BridgeParams, BridgeResult, CHAIN_METADATA, ChainMetadata, DESTINATION_SWAP_TOKENS, DynamicParamBuilder, EthereumProvider, EventListener, ExecuteParams, ExecuteResult, ExecuteSimulation, MAINNET_CHAINS, NEXUS_EVENTS, NexusNetwork, OnAllowanceHook, OnAllowanceHookData, OnIntentHook, OnIntentHookData, ProgressStep, ProgressSteps, RequestArguments, RequestForFunds, SUPPORTED_CHAINS, SUPPORTED_CHAINS_IDS, SUPPORTED_TOKENS, SimulationResult, TESTNET_CHAINS, TESTNET_TOKEN_METADATA, TOKEN_CONTRACT_ADDRESSES, TOKEN_METADATA, TokenMetadata, TransferParams, TransferResult, UserAsset } from './commons';
import * as viem from 'viem';
import { WalletClient, Client, CustomTransport, WalletActions, PublicActions, Hex } from 'viem';
import { NexusSDK as NexusSDK$1 } from 'sdk';
import SafeEventEmitter from '@metamask/safe-event-emitter';
import * as _arcana_ca_common from '@arcana/ca-common';
import { DirectSecp256k1Wallet } from '@cosmjs/proto-signing';
import { Account, FuelConnector, Provider, TransactionRequestLike } from 'fuels';

/**
 * Provides a unified interface for chain abstraction operations.
 */
declare class ChainAbstractionAdapter {
    nexusSDK: NexusSDK$1;
    private executeService;
    private bridgeExecuteService;
    constructor(nexusSDK: NexusSDK$1);
    getEVMClient(): Promise<viem.Client<viem.CustomTransport, undefined, undefined, undefined, viem.WalletActions & viem.PublicActions>>;
    /**
     * Execute a contract call using the execute service.
     */
    execute(params: ExecuteParams): Promise<ExecuteResult>;
    /**
     * Simulate contract execution using the execute service.
     */
    simulateExecute(params: ExecuteParams): Promise<ExecuteSimulation>;
    /**
     * Get the list of supported chains from the CA SDK.
     */
    getSupportedChains(env?: Network): SupportedChainsResult;
    /**
     * Check if a chain is supported by the adapter.
     */
    isSupportedChain(chainId: SUPPORTED_CHAINS_IDS): boolean;
    /**
     * Check if a token is supported by the adapter.
     */
    isSupportedToken(token: string): boolean;
    /**
     * Bridge and execute operation - uses the BridgeExecuteService
     */
    bridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteResult>;
    /**
     * Simulate bridge and execute operation
     */
    simulateBridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteSimulationResult>;
    /**
     * Enable or disable gas estimation for transactions
     * When enabled, gas estimation will run before each transaction execution
     * This helps identify potential failures early and provides cost estimates
     */
    private setGasEstimationEnabled;
}

declare class NexusUtils {
    private readonly adapter;
    private readonly isReady;
    constructor(adapter: ChainAbstractionAdapter, isReady: () => boolean);
    private ensureInitialized;
    formatBalance: typeof formatBalance;
    parseUnits: typeof parseUnits;
    formatUnits: typeof formatUnits;
    isValidAddress: typeof isValidAddress;
    truncateAddress: typeof truncateAddress;
    chainIdToHex: typeof chainIdToHex;
    hexToChainId: typeof hexToChainId;
    getMainnetTokenMetadata: (symbol: _nexus_commons.SUPPORTED_TOKENS) => _nexus_commons.TokenMetadata | undefined;
    getTestnetTokenMetadata: (symbol: _nexus_commons.SUPPORTED_TOKENS) => _nexus_commons.TokenMetadata | undefined;
    getTokenMetadata: (symbol: _nexus_commons.SUPPORTED_TOKENS) => _nexus_commons.TokenMetadata | undefined;
    getChainMetadata: typeof getChainMetadata;
    formatTokenAmount: typeof formatTokenAmount;
    formatTestnetTokenAmount: typeof formatTestnetTokenAmount;
    getSupportedChains(env?: Network): SupportedChainsResult;
    getSwapSupportedChainsAndTokens(): SupportedChainsResult;
    isSupportedChain(chainId: (typeof SUPPORTED_CHAINS)[keyof typeof SUPPORTED_CHAINS]): boolean;
    isSupportedToken(token: string): boolean;
}

declare class AllowanceQuery {
    private walletClient;
    private networkConfig;
    private chainList;
    constructor(walletClient: WalletClient, networkConfig: NetworkConfig, chainList: ChainListType);
    get(input: {
        chainID?: number;
        tokens?: string[];
    }): Promise<{
        allowance: bigint;
        chainID: number;
        token: string;
    }[]>;
    revoke(input: {
        chainID: number;
        tokens: string[];
    }): Promise<void>;
    set(input: {
        amount: bigint;
        chainID: number;
        tokens: string[];
    }): Promise<void>;
}

declare enum INIT_STATUS {
    CREATED = 0,
    RUNNING = 1,
    DONE = 2
}
declare class CA {
    #private;
    static getSupportedChains: (env?: _arcana_ca_common.Environment) => {
        id: number;
        logo: string;
        name: string;
        tokens: _nexus_commons.TokenInfo[];
    }[];
    protected _caEvents: SafeEventEmitter;
    chainList: ChainListType;
    protected _config: Required<SDKConfig>;
    protected _evm?: {
        client: Client<CustomTransport, undefined, undefined, undefined, WalletActions & PublicActions>;
        modProvider: EthereumProvider;
        provider: EthereumProvider;
    };
    protected _fuel?: {
        account: Account;
        address: string;
        connector: FuelConnector;
        modConnector: FuelConnector;
        modProvider: Provider;
        provider: Provider;
    };
    protected _hooks: {
        onAllowance: OnAllowanceHook;
        onIntent: OnIntentHook;
    };
    protected _initPromises: (() => void)[];
    protected _initStatus: INIT_STATUS;
    protected _isArcanaProvider: boolean;
    protected _networkConfig: NetworkConfig;
    protected _refundInterval: number | undefined;
    protected constructor(config?: {
        network?: NexusNetwork;
        debug?: boolean;
    });
    protected _allowance(): AllowanceQuery;
    protected _bridge(input: BridgeQueryInput): Promise<{
        exec: () => Promise<{
            explorerURL: string;
        } | undefined>;
        simulate: () => Promise<{
            intent: _nexus_commons.ReadableIntent;
            token: _nexus_commons.TokenInfo;
        }>;
    }>;
    protected _deinit: () => void;
    protected _getEVMProviderWithCA: () => EthereumProvider;
    protected _getFuelWithCA(): Promise<{
        connector: FuelConnector;
        provider: Provider;
    }>;
    protected _getMyIntents(page?: number): Promise<_nexus_commons.RFF[]>;
    protected _getUnifiedBalance(symbol: string): Promise<_nexus_commons.UserAssetDatum | undefined>;
    protected _getUnifiedBalances(): Promise<_nexus_commons.UserAssetDatum[]>;
    protected _isInitialized(): boolean;
    protected _swapWithExactIn(input: ExactInSwapInput, options?: SwapInputOptionalParams): Promise<_nexus_commons.SuccessfulSwapResult>;
    protected _swapWithExactOut(input: ExactOutSwapInput, options?: SwapInputOptionalParams): Promise<_nexus_commons.SuccessfulSwapResult>;
    private getCommonSwapParams;
    protected _handleEVMTx(args: RequestArguments, options?: Partial<TxOptions>): Promise<unknown>;
    protected _init: () => Promise<void>;
    protected onAccountsChanged: (accounts: Array<`0x${string}`>) => void;
    _setEVMProvider(provider: EthereumProvider): Promise<void>;
    protected _setFuelConnector(connector: FuelConnector): Promise<void>;
    protected _setOnAllowanceHook(hook: OnAllowanceHook): void;
    protected _setOnIntentHook(hook: OnIntentHook): void;
    protected _transfer(input: TransferQueryInput): Promise<{
        exec: () => Promise<{
            hash: `0x${string}`;
            explorerURL: string;
        }>;
        simulate: () => Promise<{
            intent: _nexus_commons.ReadableIntent;
            token: _nexus_commons.TokenInfo;
        }>;
    }>;
    protected _changeChain(chainID: number): Promise<void>;
    protected _checkPendingRefunds(): Promise<void>;
    protected _createCosmosWallet(): Promise<DirectSecp256k1Wallet>;
    protected _createEVMHandler(tx: EVMTransaction, options?: Partial<TxOptions>): Promise<_nexus_commons.CreateHandlerResponse | null>;
    getEVMClient(): Client<CustomTransport, undefined, undefined, undefined, WalletActions & PublicActions>;
    protected _createFuelHandler(tx: TransactionRequestLike, options?: Partial<TxOptions>): Promise<_nexus_commons.CreateHandlerResponse>;
    protected _getChainID(): Promise<number>;
    protected _getCosmosWallet(): Promise<DirectSecp256k1Wallet>;
    protected _getEVMAddress(): Promise<Address>;
    protected _resolveInitPromises(): void;
    protected _setProviderHooks(): Promise<void>;
    protected _signatureForLogin(): Promise<`0x${string}`>;
    protected _waitForInit(): Promise<void>;
    protected _getSwapSupportedChainsAndTokens(): SupportedChainsResult;
}

type SwapStep = ReturnType<typeof CREATE_PERMIT_EOA_TO_EPHEMERAL> | ReturnType<typeof CREATE_PERMIT_FOR_SOURCE_SWAP> | ReturnType<typeof DESTINATION_SWAP_BATCH_TX> | ReturnType<typeof DESTINATION_SWAP_HASH> | ReturnType<typeof DETERMINING_SWAP> | ReturnType<typeof RFF_ID> | ReturnType<typeof SOURCE_SWAP_BATCH_TX> | ReturnType<typeof SOURCE_SWAP_HASH> | typeof SWAP_COMPLETE | typeof SWAP_START;
declare const SWAP_START: {
    readonly completed: true;
    readonly type: "SWAP_START";
    readonly typeID: "SWAP_START";
};
declare const DETERMINING_SWAP: (completed?: boolean) => {
    readonly completed: boolean;
    readonly type: "DETERMINING_SWAP";
    readonly typeID: (completed?: boolean) => /*elided*/ any;
};
declare const CREATE_PERMIT_EOA_TO_EPHEMERAL: (completed: boolean, symbol: string, chain: Chain) => {
    readonly chain: {
        readonly id: number;
        readonly name: string;
    };
    readonly completed: boolean;
    readonly symbol: string;
    readonly type: "CREATE_PERMIT_EOA_TO_EPHEMERAL";
    readonly typeID: `CREATE_PERMIT_EOA_TO_EPHEMERAL_${number}_${string}`;
};
declare const CREATE_PERMIT_FOR_SOURCE_SWAP: (completed: boolean, symbol: string, chain: Chain) => {
    readonly chain: {
        readonly id: number;
        readonly name: string;
    };
    readonly completed: boolean;
    readonly symbol: string;
    readonly type: "CREATE_PERMIT_FOR_SOURCE_SWAP";
    readonly typeID: `CREATE_PERMIT_FOR_SOURCE_SWAP_${number}_${string}`;
};
declare const SOURCE_SWAP_BATCH_TX: (completed: boolean) => {
    readonly completed: boolean;
    readonly type: "SOURCE_SWAP_BATCH_TX";
    readonly typeID: "SOURCE_SWAP_BATCH_TX";
};
declare const SOURCE_SWAP_HASH: (ops: [bigint, Hex], chainList: ChainListType) => {
    readonly chain: {
        readonly id: number;
        readonly name: string;
    };
    readonly completed: true;
    readonly explorerURL: string;
    readonly type: "SOURCE_SWAP_HASH";
    readonly typeID: `SOURCE_SWAP_HASH_${bigint}`;
};
declare const RFF_ID: (id: number) => {
    readonly completed: true;
    readonly data: number;
    readonly type: "RFF_ID";
    readonly typeID: "RFF_ID";
};
declare const DESTINATION_SWAP_BATCH_TX: (completed: boolean) => {
    readonly completed: boolean;
    readonly type: "DESTINATION_SWAP_BATCH_TX";
    readonly typeID: "DESTINATION_SWAP_BATCH_TX";
};
declare const SWAP_COMPLETE: {
    readonly completed: true;
    readonly type: "SWAP_COMPLETE";
    readonly typeID: "SWAP_COMPLETE";
};
declare const DESTINATION_SWAP_HASH: (op: [bigint, Hex], chainList: ChainListType) => {
    readonly chain: {
        readonly id: number;
        readonly name: string;
    };
    readonly completed: true;
    readonly explorerURL: string;
    readonly type: "DESTINATION_SWAP_HASH";
    readonly typeID: `DESTINATION_SWAP_HASH_${number}`;
};

declare class NexusSDK extends CA {
    private readonly nexusAdapter;
    readonly nexusEvents: SafeEventEmitter;
    readonly utils: NexusUtils;
    constructor(config?: {
        network?: NexusNetwork;
        debug?: boolean;
    });
    /**
     * Initialize the SDK with a provider
     */
    initialize(provider: EthereumProvider): Promise<void>;
    /**
     * Get unified balances across all chains
     */
    getUnifiedBalances(): Promise<UserAsset[]>;
    /**
     * Get unified balance for a specific token
     */
    getUnifiedBalance(symbol: string): Promise<UserAsset | undefined>;
    /**
     * Cross chain token transfer
     */
    bridge(params: BridgeParams): Promise<BridgeResult>;
    /**
     * Cross chain token transfer to EOA
     */
    transfer(params: TransferParams): Promise<TransferResult>;
    swapWithExactIn(input: ExactInSwapInput, options?: SwapInputOptionalParams): Promise<SwapResult>;
    swapWithExactOut(input: ExactOutSwapInput, options?: SwapInputOptionalParams): Promise<SwapResult>;
    /**
     * Get chain abstracted provider allowing use of chain asbtraction
     * @returns EthereumProvider
     */
    getEVMProviderWithCA(): EthereumProvider;
    /**
     * Simulate bridge transaction to get costs and fees
     */
    simulateBridge(params: BridgeParams): Promise<SimulationResult>;
    /**
     * Simulate transfer transaction to get costs and fees
     */
    simulateTransfer(params: TransferParams): Promise<SimulationResult>;
    /**
     * Get user's intents with pagination
     */
    getMyIntents(page?: number): Promise<RequestForFunds[]>;
    /**
     * Check allowance for tokens on a specific chain
     */
    getAllowance(chainId?: number, tokens?: string[]): Promise<AllowanceResponse[]>;
    /**
     * Set allowance for a token on a specific chain
     */
    setAllowance(chainId: number, tokens: string[], amount: bigint): Promise<void>;
    /**
     * Revoke allowance for a token on a specific chain
     */
    revokeAllowance(chainId: number, tokens: string[]): Promise<void>;
    /**
     * Set callback for intent status updates
     */
    setOnIntentHook(callback: OnIntentHook): void;
    /**
     * Set callback for allowance approval events
     */
    setOnAllowanceHook(callback: OnAllowanceHook): void;
    deinit(): Promise<void>;
    request(args: RequestArguments): Promise<unknown>;
    /**
     * Standalone function to execute funds into a smart contract
     * @param params execute parameters including contract details and transaction settings
     * @returns Promise resolving to execute result with transaction hash and explorer URL
     */
    execute(params: ExecuteParams): Promise<ExecuteResult>;
    /**
     * Simulate a standalone execute to estimate gas costs and validate parameters
     * @param params execute parameters for simulation
     * @returns Promise resolving to simulation result with gas estimates
     */
    simulateExecute(params: ExecuteParams): Promise<ExecuteSimulation>;
    /**
     * Enhanced bridge and execute function with optional execute step and improved error handling
     * @param params Enhanced bridge and execute parameters
     * @returns Promise resolving to comprehensive operation result
     */
    bridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteResult>;
    /**
     * Simulate bridge and execute operation using bridge output amounts for realistic execute cost estimation
     * This method provides more accurate gas estimates by using the actual amount that will be
     * received on the destination chain after bridging (accounting for fees, slippage, etc.)
     * Includes detailed step-by-step breakdown with approval handling.
     */
    simulateBridgeAndExecute(params: BridgeAndExecuteParams): Promise<BridgeAndExecuteSimulationResult>;
    getSwapSupportedChainsAndTokens(): SupportedChainsResult;
    isInitialized(): boolean;
}

export { NexusSDK };
export type { SwapStep };
