import { Universe } from '@arcana/ca-common';
import { DirectSecp256k1Wallet } from '@cosmjs/proto-signing';
import Decimal from 'decimal.js';
import { type Hex, PrivateKeyAccount, WalletClient } from 'viem';
import { NetworkConfig, TokenInfo, ChainListType } from '../index';
export type AuthorizationList = {
    address: Uint8Array;
    chain_id: Uint8Array;
    nonce: number;
    sig_r: Uint8Array;
    sig_s: Uint8Array;
    sig_v: number;
};
export type BridgeAsset = {
    chainID: number;
    contractAddress: `0x${string}`;
    decimals: number;
    eoaBalance: Decimal;
    ephemeralBalance: Decimal;
};
export type SBCCall = {
    data: Uint8Array;
    to_addr: Uint8Array;
    value: Uint8Array;
};
export type SBCTx = {
    address: Uint8Array;
    authorization_list: AuthorizationList[];
    calls: SBCCall[];
    chain_id: Uint8Array;
    deadline: Uint8Array;
    key_hash: Uint8Array;
    nonce: Uint8Array;
    revert_on_failure: boolean;
    signature: Uint8Array;
    universe: Universe;
};
type BaseSwapInput = {
    toChainID: number;
    toTokenAddress: Hex;
};
type SWAP_ALL_IN = BaseSwapInput;
type SWAP_EXACT_IN = {
    fromAmount: bigint;
    fromChainID: number;
    fromTokenAddress: Hex;
} & BaseSwapInput;
type SWAP_EXACT_OUT = {
    toAmount: bigint;
} & BaseSwapInput;
export type SwapInput = SWAP_ALL_IN | SWAP_EXACT_IN | SWAP_EXACT_OUT;
export type InternalSwapInput = {
    chainList: ChainListType;
    cosmos: {
        address: string;
        wallet: DirectSecp256k1Wallet;
    };
    destination: {
        amount?: bigint;
        chainID: number;
        token: `0x${string}`;
    };
    eoaWallet: WalletClient;
    ephemeralWallet: PrivateKeyAccount;
    networkConfig: NetworkConfig;
    source?: {
        amount: bigint;
        chainID: number;
        token: `0x${string}`;
    };
};
export type SwapIntent = {
    destination: {
        amount: string;
        chain: {
            id: number;
            logo: string;
            name: string;
        };
        token: {
            contractAddress: Hex;
            decimals: number;
            symbol: string;
        };
    };
    sources: {
        amount: string;
        chain: {
            id: number;
            logo: string;
            name: string;
        };
        token: {
            contractAddress: Hex;
            decimals: number;
            symbol: string;
        };
    }[];
};
export type SwapIntentHook = (data: {
    allow: () => void;
    deny: () => void;
    intent: SwapIntent;
    refresh: () => Promise<SwapIntent>;
}) => unknown;
export type SwapParams = {
    emit: (stepID: string, step: unknown) => void;
    chainList: ChainListType;
    address: {
        cosmos: string;
        eoa: Hex;
        ephemeral: Hex;
    };
    wallet: {
        cosmos: DirectSecp256k1Wallet;
        ephemeral: PrivateKeyAccount;
        eoa: WalletClient;
    };
    networkConfig: NetworkConfig;
} & SwapInputOptionalParams;
export type SwapInputOptionalParams = {
    swapIntentHook?: SwapIntentHook;
};
export interface ExactInSwapInput {
    from?: {
        chainId: number;
        amount: bigint;
        tokenAddress: Hex;
    }[];
    toChainId: number;
    toTokenAddress: Hex;
}
export interface ExactOutSwapInput {
    toChainId: number;
    toTokenAddress: Hex;
    toAmount: bigint;
}
export declare enum SwapMode {
    EXACT_IN = 0,
    EXACT_OUT = 1
}
export type SwapData = {
    mode: SwapMode.EXACT_IN;
    data: ExactInSwapInput;
} | {
    mode: SwapMode.EXACT_OUT;
    data: ExactOutSwapInput;
};
export declare const CaliburSBCTypes: {
    readonly BatchedCall: readonly [{
        readonly name: "calls";
        readonly type: "Call[]";
    }, {
        readonly name: "revertOnFailure";
        readonly type: "bool";
    }];
    readonly Call: readonly [{
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "value";
        readonly type: "uint256";
    }, {
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly SignedBatchedCall: readonly [{
        readonly name: "batchedCall";
        readonly type: "BatchedCall";
    }, {
        readonly name: "nonce";
        readonly type: "uint256";
    }, {
        readonly name: "keyHash";
        readonly type: "bytes32";
    }, {
        readonly name: "executor";
        readonly type: "address";
    }, {
        readonly name: "deadline";
        readonly type: "uint256";
    }];
};
export type AnkrAsset = {
    balance: string;
    balanceRawInteger: string;
    balanceUsd: string;
    blockchain: string;
    contractAddress: `0x${string}`;
    holderAddress: `0x${string}`;
    thumbnail: string;
    tokenDecimals: number;
    tokenName: string;
    tokenPrice: string;
    tokenSymbol: string;
    tokenType: 'ERC20' | 'NATIVE';
};
export type AnkrBalance = {
    balance: string;
    balanceUSD: string;
    chainID: number;
    tokenAddress: `0x${string}`;
    tokenData: {
        decimals: number;
        icon: string;
        name: string;
        symbol: string;
    };
    universe: Universe;
};
export type AnkrBalances = AnkrBalance[];
export type Balances = {
    amount: string;
    chain_id: number;
    decimals: number;
    token_address: `0x${string}`;
    universe: Universe;
    value: number;
}[];
export type EoaToEphemeralCallMap = Record<number, {
    amount: bigint;
    decimals: number;
    tokenAddress: Hex;
}>;
export type RFFDepositCallMap = Record<number, {
    amount: bigint;
    tokenAddress: Hex;
    tx: Tx[];
}>;
export type RFFIntent = {
    destination: {
        amount: bigint;
        chainID: number;
        gasToken?: bigint;
        tokenContract: `0x${string}`;
    };
    fees: {
        caGas: bigint;
        collection: bigint;
        fulfilment: bigint;
        gasSupplied: bigint;
        protocol: bigint;
        solver: bigint;
    };
    isAvailableBalanceInsufficient: boolean;
    sources: {
        amount: bigint;
        chainID: number;
        tokenContract: `0x${string}`;
    }[];
};
export type SupportedChainsResult = {
    id: number;
    logo: string;
    name: string;
    tokens: TokenInfo[];
}[];
export type Tx = {
    data: Hex;
    to: Hex;
    value: bigint;
};
export type Swap = {
    inputAmount: bigint;
    inputContract: Hex;
    inputDecimals: number;
    outputAmount: bigint;
    outputContract: Hex;
    outputDecimals: number;
};
export type ChainSwap = {
    chainId: number;
    swaps: Swap[];
    txHash: Hex;
};
export type SuccessfulSwapResult = {
    sourceSwaps: ChainSwap[];
    explorerURL: string;
    destinationSwap: ChainSwap | null;
};
export type SwapResult = {
    success: true;
    result: SuccessfulSwapResult;
} | {
    success: false;
    error: string;
};
export {};
