import Decimal from 'decimal.js';
import { isAddress, encodeFunctionData, isHash, createPublicClient, custom } from 'viem';
import { base, optimism, arbitrum, polygon, mainnet } from 'viem/chains';

var SwapMode;
(function (SwapMode) {
    SwapMode[SwapMode["EXACT_IN"] = 0] = "EXACT_IN";
    SwapMode[SwapMode["EXACT_OUT"] = 1] = "EXACT_OUT";
})(SwapMode || (SwapMode = {}));
const CaliburSBCTypes = {
    BatchedCall: [
        { name: 'calls', type: 'Call[]' },
        { name: 'revertOnFailure', type: 'bool' },
    ],
    Call: [
        { name: 'to', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'data', type: 'bytes' },
    ],
    SignedBatchedCall: [
        { name: 'batchedCall', type: 'BatchedCall' },
        { name: 'nonce', type: 'uint256' },
        { name: 'keyHash', type: 'bytes32' },
        { name: 'executor', type: 'address' },
        { name: 'deadline', type: 'uint256' },
    ],
};

const SUPPORTED_CHAINS = {
    // Mainnet chains
    ETHEREUM: 1,
    BASE: 8453,
    ARBITRUM: 42161,
    OPTIMISM: 10,
    POLYGON: 137,
    AVALANCHE: 43114,
    SCROLL: 534352,
    SOPHON: 50104,
    KAIA: 8217,
    BNB: 56,
    HYPEREVM: 999,
    // Testnet chains
    SEPOLIA: 11155111,
    BASE_SEPOLIA: 84532,
    ARBITRUM_SEPOLIA: 421614,
    OPTIMISM_SEPOLIA: 11155420,
    POLYGON_AMOY: 80002,
    MONAD_TESTNET: 10143,
};
const BASE_TOKEN_METADATA = {
    ETH: {
        symbol: 'ETH',
        name: 'Ethereum',
        decimals: 18,
        icon: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628',
        coingeckoId: 'ethereum',
        isNative: true,
    },
    USDT: {
        symbol: 'USDT',
        name: 'Tether USD',
        decimals: 6,
        icon: 'https://coin-images.coingecko.com/coins/images/35023/large/USDT.png',
        coingeckoId: 'tether',
    },
    USDC: {
        symbol: 'USDC',
        name: 'USD Coin',
        decimals: 6,
        icon: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',
        coingeckoId: 'usd-coin',
    },
};
const TOKEN_METADATA = BASE_TOKEN_METADATA;
const TESTNET_TOKEN_METADATA = {
    ETH: { ...BASE_TOKEN_METADATA.ETH, name: 'Test Ethereum' },
    USDT: { ...BASE_TOKEN_METADATA.USDT, name: 'Test Tether USD' },
    USDC: { ...BASE_TOKEN_METADATA.USDC, name: 'Test USD Coin' },
};
const CHAIN_METADATA = {
    // Mainnet chains
    [SUPPORTED_CHAINS.ETHEREUM]: {
        id: 1,
        name: 'Ethereum',
        shortName: 'eth',
        logo: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png',
        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://eth.merkle.io'],
        blockExplorerUrls: ['https://etherscan.io'],
    },
    [SUPPORTED_CHAINS.BASE]: {
        id: 8453,
        name: 'Base',
        shortName: 'base',
        logo: 'https://pbs.twimg.com/profile_images/1945608199500910592/rnk6ixxH_400x400.jpg',
        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://mainnet.base.org'],
        blockExplorerUrls: ['https://basescan.org'],
    },
    [SUPPORTED_CHAINS.ARBITRUM]: {
        id: 42161,
        name: 'Arbitrum One',
        shortName: 'arb1',
        logo: 'https://assets.coingecko.com/coins/images/16547/small/photo_2023-03-29_21.47.00.jpeg',
        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: [
            'https://arb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
            'https://arbitrum.blockpi.network/v1/rpc/a8ccd43cdc840c2b2d20c24a058514a21302376d',
        ],
        blockExplorerUrls: ['https://arbiscan.io'],
    },
    [SUPPORTED_CHAINS.OPTIMISM]: {
        id: 10,
        name: 'Optimism',
        shortName: 'oeth',
        logo: 'https://assets.coingecko.com/coins/images/25244/small/Optimism.png',
        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://mainnet.optimism.io'],
        blockExplorerUrls: ['https://optimistic.etherscan.io'],
    },
    [SUPPORTED_CHAINS.POLYGON]: {
        id: 137,
        name: 'Polygon',
        shortName: 'matic',
        logo: 'https://assets.coingecko.com/coins/images/4713/small/polygon.png',
        nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
        rpcUrls: ['https://polygon-rpc.com'],
        blockExplorerUrls: ['https://polygonscan.com'],
    },
    [SUPPORTED_CHAINS.AVALANCHE]: {
        id: 43114,
        name: 'Avalanche',
        shortName: 'avax',
        logo: 'https://assets.coingecko.com/coins/images/12559/small/Avalanche_Circle_RedWhite_Trans.png',
        nativeCurrency: { name: 'Avalanche', symbol: 'AVAX', decimals: 18 },
        rpcUrls: ['https://api.avax.network/ext/bc/C/rpc'],
        blockExplorerUrls: ['https://snowtrace.io'],
    },
    [SUPPORTED_CHAINS.SCROLL]: {
        id: 534352,
        name: 'Scroll',
        shortName: 'scroll',
        logo: 'https://assets.coingecko.com/coins/images/50571/standard/scroll.jpg?1728376125',
        nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://rpc.scroll.io'],
        blockExplorerUrls: ['https://scrollscan.com'],
    },
    [SUPPORTED_CHAINS.SOPHON]: {
        id: 50104,
        name: 'Sophon',
        shortName: 'sophon',
        logo: 'https://assets.coingecko.com/coins/images/38680/large/sophon_logo_200.png',
        nativeCurrency: { name: 'Sophon', symbol: 'SOPH', decimals: 18 },
        rpcUrls: ['https://rpc.sophon.xyz'],
        blockExplorerUrls: ['https://explorer.sophon.xyz'],
    },
    [SUPPORTED_CHAINS.KAIA]: {
        id: 8217,
        name: 'Kaia Mainnet',
        shortName: 'kaia',
        logo: 'https://assets.coingecko.com/asset_platforms/images/9672/large/kaia.png',
        nativeCurrency: { name: 'Kaia', symbol: 'KAIA', decimals: 18 },
        rpcUrls: ['https://public-en.node.kaia.io'],
        blockExplorerUrls: ['https://kaiascan.io'],
    },
    [SUPPORTED_CHAINS.BNB]: {
        id: 56,
        name: 'BNB Smart Chain',
        shortName: 'bnb',
        logo: 'https://assets.coingecko.com/asset_platforms/images/1/large/bnb_smart_chain.png',
        nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
        rpcUrls: ['https://bsc-pokt.nodies.app'],
        blockExplorerUrls: ['https://bscscan.com'],
    },
    [SUPPORTED_CHAINS.HYPEREVM]: {
        id: 999,
        name: 'Hyperliquid EVM',
        shortName: 'hyperliquid',
        logo: 'https://assets.coingecko.com/asset_platforms/images/243/large/hyperliquid.png',
        nativeCurrency: { name: 'HYPE', symbol: 'HYPE', decimals: 18 },
        rpcUrls: ['https://rpc.hyperliquid.xyz/evm'],
        blockExplorerUrls: ['https://hyperevmscan.io/'],
    },
    // Testnet chains
    [SUPPORTED_CHAINS.SEPOLIA]: {
        id: 11155111,
        name: 'Sepolia',
        shortName: 'sepolia',
        logo: 'https://assets.coingecko.com/asset_platforms/images/279/large/ethereum.png?1706606803',
        nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://sepolia.drpc.org'],
        blockExplorerUrls: ['https://sepolia.etherscan.io'],
    },
    [SUPPORTED_CHAINS.BASE_SEPOLIA]: {
        id: 84532,
        name: 'Base Sepolia',
        shortName: 'base-sepolia',
        logo: 'https://pbs.twimg.com/profile_images/1945608199500910592/rnk6ixxH_400x400.jpg',
        nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://sepolia.base.org'],
        blockExplorerUrls: ['https://sepolia.basescan.org'],
    },
    [SUPPORTED_CHAINS.MONAD_TESTNET]: {
        id: 10143,
        name: 'Monad Testnet',
        shortName: 'monad-testnet',
        logo: 'https://assets.coingecko.com/coins/images/38927/standard/monad.jpg',
        nativeCurrency: { name: 'Testnet MON Token', symbol: 'MON', decimals: 18 },
        rpcUrls: ['https://testnet-rpc.monad.xyz/'],
        blockExplorerUrls: ['https://testnet.monadexplorer.com/'],
    },
    [SUPPORTED_CHAINS.ARBITRUM_SEPOLIA]: {
        id: 421614,
        name: 'Arbitrum Sepolia',
        shortName: 'arb-sepolia',
        logo: 'https://assets.coingecko.com/coins/images/16547/small/photo_2023-03-29_21.47.00.jpeg',
        nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://sepolia-rollup.arbitrum.io/rpc'],
        blockExplorerUrls: ['https://sepolia.arbiscan.io'],
    },
    [SUPPORTED_CHAINS.OPTIMISM_SEPOLIA]: {
        id: 11155420,
        name: 'Optimism Sepolia',
        shortName: 'op-sepolia',
        logo: 'https://assets.coingecko.com/coins/images/25244/small/Optimism.png',
        nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://sepolia.optimism.io'],
        blockExplorerUrls: ['https://sepolia-optimism.etherscan.io'],
    },
    [SUPPORTED_CHAINS.POLYGON_AMOY]: {
        id: 80002,
        name: 'Polygon Amoy',
        shortName: 'amoy',
        logo: 'https://assets.coingecko.com/coins/images/4713/small/polygon.png',
        nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
        rpcUrls: ['https://rpc-amoy.polygon.technology'],
        blockExplorerUrls: ['https://amoy.polygonscan.com'],
    },
};
// Event name constants to prevent typos
const NEXUS_EVENTS = {
    STEP_COMPLETE: 'step_complete',
    EXPECTED_STEPS: 'expected_steps',
    SWAP_STEPS: 'swap_step',
    // Modular event names
    BRIDGE_EXECUTE_EXPECTED_STEPS: 'bridge_execute_expected_steps',
    BRIDGE_EXECUTE_COMPLETED_STEPS: 'bridge_execute_completed_steps',
};
// Helper constants for mainnet and testnet chain categorization
const MAINNET_CHAINS = [
    SUPPORTED_CHAINS.ETHEREUM,
    SUPPORTED_CHAINS.BASE,
    SUPPORTED_CHAINS.ARBITRUM,
    SUPPORTED_CHAINS.OPTIMISM,
    SUPPORTED_CHAINS.POLYGON,
    SUPPORTED_CHAINS.AVALANCHE,
    SUPPORTED_CHAINS.SCROLL,
    SUPPORTED_CHAINS.SOPHON,
    SUPPORTED_CHAINS.KAIA,
    SUPPORTED_CHAINS.BNB,
    SUPPORTED_CHAINS.HYPEREVM,
];
const TESTNET_CHAINS = [
    SUPPORTED_CHAINS.SEPOLIA,
    SUPPORTED_CHAINS.BASE_SEPOLIA,
    SUPPORTED_CHAINS.ARBITRUM_SEPOLIA,
    SUPPORTED_CHAINS.OPTIMISM_SEPOLIA,
    SUPPORTED_CHAINS.POLYGON_AMOY,
    SUPPORTED_CHAINS.MONAD_TESTNET,
];
/**
 * Token contract addresses per chain
 * This registry contains the contract addresses for supported tokens across different chains
 */
const TOKEN_CONTRACT_ADDRESSES = {
    USDC: {
        [SUPPORTED_CHAINS.ETHEREUM]: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
        [SUPPORTED_CHAINS.BASE]: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
        [SUPPORTED_CHAINS.POLYGON]: '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359',
        [SUPPORTED_CHAINS.ARBITRUM]: '0xaf88d065e77c8cc2239327c5edb3a432268e5831',
        [SUPPORTED_CHAINS.SOPHON]: '0x9aa0f72392b5784ad86c6f3e899bcc053d00db4f',
        [SUPPORTED_CHAINS.OPTIMISM]: '0x0b2c639c533813f4aa9d7837caf62653d097ff85',
        [SUPPORTED_CHAINS.SCROLL]: '0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4',
        [SUPPORTED_CHAINS.AVALANCHE]: '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e',
        [SUPPORTED_CHAINS.BNB]: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',
        // testnet chains
        [SUPPORTED_CHAINS.SEPOLIA]: '0xf08A50178dfcDe18524640EA6618a1f965821715',
        [SUPPORTED_CHAINS.BASE_SEPOLIA]: '0x036CbD53842c5426634e7929541eC2318f3dCF7e',
        [SUPPORTED_CHAINS.ARBITRUM_SEPOLIA]: '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d',
        [SUPPORTED_CHAINS.OPTIMISM_SEPOLIA]: '0x5fd84259d66Cd46123540766Be93DFE6D43130D7',
        [SUPPORTED_CHAINS.POLYGON_AMOY]: '0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582',
        [SUPPORTED_CHAINS.MONAD_TESTNET]: '0xf817257fed379853cDe0fa4F97AB987181B1E5Ea',
    },
    USDT: {
        [SUPPORTED_CHAINS.ETHEREUM]: '0xdac17f958d2ee523a2206206994597c13d831ec7',
        [SUPPORTED_CHAINS.POLYGON]: '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',
        [SUPPORTED_CHAINS.ARBITRUM]: '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9',
        [SUPPORTED_CHAINS.SOPHON]: '0x6386da73545ae4e2b2e0393688fa8b65bb9a7169',
        [SUPPORTED_CHAINS.KAIA]: '0xd077a400968890eacc75cdc901f0356c943e4fdb',
        [SUPPORTED_CHAINS.OPTIMISM]: '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58',
        [SUPPORTED_CHAINS.SCROLL]: '0xf55bec9cafdbe8730f096aa55dad6d22d44099df',
        [SUPPORTED_CHAINS.AVALANCHE]: '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7',
        [SUPPORTED_CHAINS.BNB]: '0x55d398326f99059fF775485246999027B3197955',
        [SUPPORTED_CHAINS.HYPEREVM]: '0xB8CE59FC3717ada4C02eaDF9682A9e934F625ebb',
        // testnet chains
        [SUPPORTED_CHAINS.SEPOLIA]: '0xaA8E23Fb1079EA71e0a56F48a2aA51851D8433D0',
        [SUPPORTED_CHAINS.BASE_SEPOLIA]: '0xf7e53b20f39a5f8c35005fEf37eef03A7b0d0B5a',
        [SUPPORTED_CHAINS.ARBITRUM_SEPOLIA]: '0xb9a4873d8d2C22e56b8574e8605644d08E047434',
        [SUPPORTED_CHAINS.OPTIMISM_SEPOLIA]: '0x7F5c764cBc14f9669B88837ca1490cCa17c31607',
        [SUPPORTED_CHAINS.POLYGON_AMOY]: '0x2c852e740B62308c46DD29B982FBb650D063Bd07',
        [SUPPORTED_CHAINS.MONAD_TESTNET]: '0x88b8E2161DEDC77EF4ab7585569D2415a1C1055D',
    },
    // ETH is native on all supported chains, no contract address needed
};
const DESTINATION_SWAP_TOKENS = new Map([
    [
        SUPPORTED_CHAINS.OPTIMISM,
        [
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628',
                name: 'Ether',
                symbol: 'ETH',
                tokenAddress: '0x0000000000000000000000000000000000000000',
            },
            {
                decimals: 6,
                logo: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',
                name: 'USD Coin',
                symbol: 'USDC',
                tokenAddress: '0x0b2c639c533813f4aa9d7837caf62653d097ff85',
            },
            {
                decimals: 6,
                logo: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',
                name: 'USDT Coin',
                symbol: 'USDT',
                tokenAddress: '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58',
            },
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/25244/large/Optimism.png?1696524385',
                name: 'Optimism',
                symbol: 'OP',
                tokenAddress: '0x4200000000000000000000000000000000000042',
            },
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/12645/large/AAVE.png?1696512452',
                name: 'Aave Token',
                symbol: 'AAVE',
                tokenAddress: '0x76fb31fb4af56892a25e32cfc43de717950c9278',
            },
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/12504/large/uni.jpg?1696512319',
                name: 'Uniswap',
                symbol: 'UNI',
                tokenAddress: '0x6fd9d7ad17242c41f7131d257212c54a0e816691',
            },
        ],
    ],
    [
        SUPPORTED_CHAINS.ARBITRUM,
        [
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628',
                name: 'Ether',
                symbol: 'ETH',
                tokenAddress: '0x0000000000000000000000000000000000000000',
            },
            {
                decimals: 6,
                logo: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',
                name: 'USD Coin',
                symbol: 'USDC',
                tokenAddress: '0xaf88d065e77c8cc2239327c5edb3a432268e5831',
            },
            {
                decimals: 6,
                logo: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',
                name: 'USDT Coin',
                symbol: 'USDT',
                tokenAddress: '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9',
            },
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/29850/large/pepe-token.jpeg?1696528776',
                name: 'Pepe',
                symbol: 'PEPE',
                tokenAddress: '0x25d887ce7a35172c62febfd67a1856f20faebb00',
            },
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/13573/large/Lido_DAO.png?1696513326',
                name: 'Lido DAO Token',
                symbol: 'LDO',
                tokenAddress: '0x13ad51ed4f1b7e9dc168d8a00cb3f4ddd85efa60',
            },
        ],
    ],
    [
        SUPPORTED_CHAINS.SCROLL,
        [
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628',
                name: 'Ether',
                symbol: 'ETH',
                tokenAddress: '0x0000000000000000000000000000000000000000',
            },
            {
                decimals: 6,
                logo: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',
                name: 'USD Coin',
                symbol: 'USDC',
                tokenAddress: '0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4',
            },
            {
                decimals: 6,
                logo: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',
                name: 'USDT Coin',
                symbol: 'USDT',
                tokenAddress: '0xf55bec9cafdbe8730f096aa55dad6d22d44099df',
            },
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628',
                name: 'Ether',
                symbol: 'ETH',
                tokenAddress: '0x0000000000000000000000000000000000000000',
            },
        ],
    ],
    [
        SUPPORTED_CHAINS.BASE,
        [
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png?1696501628',
                name: 'Ether',
                symbol: 'ETH',
                tokenAddress: '0x0000000000000000000000000000000000000000',
            },
            {
                decimals: 6,
                logo: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png?1696506694',
                name: 'USD Coin',
                symbol: 'USDC',
                tokenAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',
            },
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/9956/large/Badge_Dai.png?1696509996',
                name: 'Dai Stablecoin',
                symbol: 'DAI',
                tokenAddress: '0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb',
            },
            {
                decimals: 18,
                logo: 'https://coin-images.coingecko.com/coins/images/28206/large/ftxG9_TJ_400x400.jpeg?1696527208',
                name: 'LayerZero',
                symbol: 'ZRO',
                tokenAddress: '0x6985884c4392d348587b19cb9eaaf157f13271cd',
            },
            {
                decimals: 18,
                logo: 'https://assets.coingecko.com/coins/images/12151/standard/OM_Token.png?1696511991',
                name: 'MANTRA',
                symbol: 'OM',
                tokenAddress: '0x3992b27da26848c2b19cea6fd25ad5568b68ab98',
            },
            {
                decimals: 18,
                logo: 'https://assets.coingecko.com/coins/images/54411/standard/Qm4DW488_400x400.jpg',
                name: 'KAITO',
                symbol: 'KAITO',
                tokenAddress: '0x98d0baa52b2d063e780de12f615f963fe8537553',
            },
        ],
    ],
    [
        SUPPORTED_CHAINS.BNB,
        [
            {
                decimals: 18,
                logo: 'https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png',
                name: 'BNB',
                symbol: 'BNB',
                tokenAddress: '0x0000000000000000000000000000000000000000',
            },
        ],
    ],
]);

const LOG_LEVEL = {
    DEBUG: 1,
    ERROR: 4,
    INFO: 2,
    NOLOGS: 5,
    WARNING: 3,
};
const setExceptionReporter = (reporter) => {
    state.exceptionReporter = reporter;
};
const sendException = (msg) => {
    if (!state.exceptionReporter)
        return;
    try {
        state.exceptionReporter(msg);
    }
    catch (reportErr) {
        console.error('[LOGGER] Exception reporter threw:', reportErr);
    }
};
const setLogLevel = (level) => {
    state.logLevel = level;
};
const getLogger = () => {
    return state.logger;
};
class Logger {
    constructor() {
        this.prefix = 'NEXUS_SDK';
    }
    consoleLog(level, message, params) {
        if (level < state.logLevel) {
            return;
        }
        switch (level) {
            case LOG_LEVEL.DEBUG:
                console.debug(`[DEBUG]`, message, params);
                break;
            case LOG_LEVEL.ERROR:
                console.error(`[ERROR]`, message, params);
                break;
            case LOG_LEVEL.INFO:
                console.info(`[INFO]`, message, params);
                break;
            case LOG_LEVEL.WARNING:
                console.warn(`[WARN]`, message, params);
                break;
            default:
                console.log(`[LOG]`, message, params);
        }
    }
    debug(message, params = {}) {
        this.internalLog(LOG_LEVEL.DEBUG, message, params);
    }
    error(message, err) {
        if (err instanceof Error) {
            this.internalLog(LOG_LEVEL.ERROR, message, err.message);
            sendException(JSON.stringify({ error: err.message, message }));
            return;
        }
        if (typeof err === 'string') {
            this.internalLog(LOG_LEVEL.ERROR, message, err);
            sendException(JSON.stringify({ error: err, message }));
        }
        else {
            this.internalLog(LOG_LEVEL.ERROR, message, undefined);
            sendException(JSON.stringify({ message }));
        }
    }
    info(message, params = {}) {
        this.internalLog(LOG_LEVEL.INFO, message, params);
    }
    internalLog(level, message, params) {
        const logMessage = `[${this.prefix}] Msg: ${message}\n`;
        this.consoleLog(level, logMessage, params);
    }
    warn(message, params = {}) {
        this.internalLog(LOG_LEVEL.WARNING, message, params);
    }
}
const state = {
    exceptionReporter: null,
    logger: new Logger(),
    logLevel: LOG_LEVEL.NOLOGS,
};
// Export a default logger instance for convenience
const logger = getLogger();

/**
 * Shared utility for standardized error message extraction
 */
function extractErrorMessage(error, fallbackContext) {
    return error instanceof Error ? error.message : `Unknown ${fallbackContext} error`;
}
function wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Get Viem chain configuration for supported chains
 */
function getViemChain(chainId) {
    switch (chainId) {
        case 1:
            return mainnet;
        case 137:
            return polygon;
        case 42161:
            return arbitrum;
        case 10:
            return optimism;
        case 8453:
            return base;
        default:
            // Return a basic chain config for unsupported chains
            return {
                id: chainId,
                name: `Chain ${chainId}`,
                nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                rpcUrls: {
                    default: { http: [] },
                    public: { http: [] },
                },
            };
    }
}
/**
 * Format a balance string to a human-readable format using Decimal.js
 */
function formatBalance(balance, decimals, precision = 4) {
    const balanceDecimal = new Decimal(balance);
    const divisor = new Decimal(10).pow(decimals);
    const formatted = balanceDecimal.div(divisor);
    if (formatted.isZero())
        return '0';
    if (formatted.lt(0.0001))
        return '< 0.0001';
    return formatted.toFixed(precision).replace(/\.?0+$/, '');
}
/**
 * Parse units from a human-readable string to wei/smallest unit using Decimal.js
 */
function parseUnits(value, decimals) {
    const valueDecimal = new Decimal(value);
    const multiplier = new Decimal(10).pow(decimals);
    const result = valueDecimal.mul(multiplier);
    return BigInt(result.toFixed(0));
}
/**
 * Format units from wei/smallest unit to human-readable string using Decimal.js
 */
function formatUnits(value, decimals) {
    const valueDecimal = new Decimal(value.toString());
    const divisor = new Decimal(10).pow(decimals);
    const result = valueDecimal.div(divisor);
    return result.toFixed();
}
/**
 * Validate if a string is a valid Ethereum address using viem
 */
function isValidAddress(address) {
    return isAddress(address);
}
/**
 * Get mainnet token metadata by symbol
 */
const getMainnetTokenMetadata = (symbol) => {
    return TOKEN_METADATA[symbol];
};
/**
 * Get testnet token metadata by symbol
 */
const getTestnetTokenMetadata = (symbol) => {
    return TESTNET_TOKEN_METADATA[symbol];
};
/**
 * Get token metadata by symbol (defaults to mainnet, kept for backward compatibility)
 */
const getTokenMetadata = (symbol) => {
    return TOKEN_METADATA[symbol];
};
/**
 * Get chain metadata by chain ID
 */
function getChainMetadata(chainId) {
    return CHAIN_METADATA[chainId];
}
/**
 * Format a mainnet token amount with proper decimals and symbol
 */
function formatTokenAmount(amount, tokenSymbol, precision = 4) {
    const metadata = getMainnetTokenMetadata(tokenSymbol);
    if (!metadata)
        return `${amount} ${tokenSymbol}`;
    const amountStr = typeof amount === 'bigint' ? amount.toString() : amount;
    const formatted = formatBalance(amountStr, metadata.decimals, precision);
    return `${formatted} ${metadata.symbol}`;
}
/**
 * Format a testnet token amount with proper decimals and symbol
 */
function formatTestnetTokenAmount(amount, tokenSymbol, precision = 4) {
    const metadata = getTestnetTokenMetadata(tokenSymbol);
    if (!metadata)
        return `${amount} ${tokenSymbol}`;
    const amountStr = typeof amount === 'bigint' ? amount.toString() : amount;
    const formatted = formatBalance(amountStr, metadata.decimals, precision);
    return `${formatted} ${metadata.symbol}`;
}
/**
 * Truncate an address for display purposes
 */
function truncateAddress(address, startLength = 6, endLength = 4) {
    if (!isValidAddress(address))
        return address;
    if (address.length <= startLength + endLength + 2)
        return address;
    return `${address.slice(0, startLength)}...${address.slice(-endLength)}`;
}
/**
 * Convert chain ID to hex format
 */
function chainIdToHex(chainId) {
    return `0x${chainId.toString(16)}`;
}
/**
 * Convert hex chain ID to number
 */
function hexToChainId(hex) {
    return parseInt(hex, 16);
}
const isMainnetChain = (chainId) => {
    return MAINNET_CHAINS.includes(chainId);
};
const isTestnetChain = (chainId) => {
    return TESTNET_CHAINS.includes(chainId);
};
/**
 * Enhanced contract parameter validation with detailed error messages
 */
function validateContractParams(params) {
    const { contractAddress, contractAbi, functionName, functionParams, chainId } = params;
    // Validate contract address
    if (!contractAddress || typeof contractAddress !== 'string') {
        return { isValid: false, error: 'Contract address is required and must be a string' };
    }
    if (!isAddress(contractAddress)) {
        return { isValid: false, error: 'Contract address must be a checksummed Ethereum address' };
    }
    // Validate ABI
    if (!Array.isArray(contractAbi) || contractAbi.length === 0) {
        return { isValid: false, error: 'Contract ABI is required and must be a non-empty array' };
    }
    // Validate function name
    if (!functionName || typeof functionName !== 'string') {
        return { isValid: false, error: 'Function name is required and must be a string' };
    }
    // Find function in ABI
    const functionAbi = contractAbi.find((item) => item.type === 'function' && item.name === functionName);
    if (!functionAbi) {
        return { isValid: false, error: `Function '${functionName}' not found in contract ABI` };
    }
    // Validate parameters count
    const expectedParamsCount = functionAbi.inputs?.length ?? 0;
    const providedParamsCount = functionParams?.length || 0;
    if (expectedParamsCount !== providedParamsCount) {
        return {
            isValid: false,
            error: `Function '${functionName}' expects ${expectedParamsCount} parameters, but ${providedParamsCount} were provided`,
        };
    }
    // Validate chain ID
    if (!chainId || !CHAIN_METADATA[chainId]) {
        return { isValid: false, error: `Unsupported chain ID: ${chainId}` };
    }
    return { isValid: true };
}
/**
 * Enhanced contract call encoding with comprehensive error handling
 */
function encodeContractCall(params) {
    try {
        const { contractAbi, functionName, functionParams } = params;
        const data = encodeFunctionData({
            abi: contractAbi,
            functionName,
            args: functionParams,
        });
        return { success: true, data };
    }
    catch (error) {
        return {
            success: false,
            error: `Failed to encode contract call: ${extractErrorMessage(error, 'encoding')}`,
        };
    }
}
/**
 * Validate and ensure a value is a valid transaction hash
 */
function validateTransactionHash(value) {
    if (typeof value !== 'string')
        return false;
    return isHash(value);
}
/**
 * Validate hex response from RPC calls
 */
function validateHexResponse(value, fieldName) {
    if (typeof value !== 'string') {
        return { isValid: false, error: `${fieldName} must be a string, got ${typeof value}` };
    }
    if (!value.startsWith('0x')) {
        return { isValid: false, error: `${fieldName} must be a hex string starting with 0x` };
    }
    return { isValid: true };
}
/**
 * Enhanced block explorer URL generation with fallback support
 */
function getBlockExplorerUrl(chainId, txHash) {
    const chainMetadata = CHAIN_METADATA[chainId];
    if (!chainMetadata?.blockExplorerUrls?.[0]) {
        logger.warn(`No block explorer URL found for chain ${chainId}`);
        return '';
    }
    const baseUrl = chainMetadata.blockExplorerUrls[0];
    return `${baseUrl}/tx/${txHash}`;
}
/**
 * Search for transaction hash in block transactions
 */
async function searchTransactionInBlock(provider, fromAddress) {
    const latestBlock = (await provider.request({
        method: 'eth_getBlockByNumber',
        params: ['latest', true],
    }));
    if (!latestBlock?.transactions)
        return null;
    for (const tx of latestBlock.transactions) {
        if (tx.from?.toLowerCase() === fromAddress.toLowerCase()) {
            if (validateTransactionHash(tx.hash)) {
                return tx.hash;
            }
        }
    }
    return null;
}
/**
 * Poll for transaction hash with timeout
 */
async function pollForTransactionHash(provider, fromAddress, timeout) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
        const hash = await searchTransactionInBlock(provider, fromAddress);
        if (hash) {
            return { success: true, hash };
        }
        await wait(2000);
    }
    return { success: false, error: 'Transaction hash not found within timeout period' };
}
/**
 * Get transaction hash with multiple fallback strategies
 */
async function getTransactionHashWithFallback(provider, response, options = {}) {
    const { enablePolling = false, timeout = 30000, fromAddress } = options;
    // Strategy 1: Direct response validation
    if (validateTransactionHash(response)) {
        return { success: true, hash: response };
    }
    // Strategy 2: Transaction polling (if enabled)
    if (enablePolling && fromAddress) {
        try {
            return await pollForTransactionHash(provider, fromAddress, timeout);
        }
        catch (error) {
            return {
                success: false,
                error: `Transaction polling failed: ${extractErrorMessage(error, 'polling')}`,
            };
        }
    }
    return {
        success: false,
        error: `Invalid transaction hash response: ${typeof response}${enablePolling ? ' (polling disabled)' : ''}`,
    };
}
/**
 * Enhanced transaction receipt waiting using Viem
 */
async function waitForTransactionReceipt(provider, txHash, options = {}, chainId = 1) {
    const { timeout = 300000, // 5 minutes default
    requiredConfirmations = 1, pollingInterval = 2000, } = options;
    try {
        const client = createPublicClient({
            chain: getViemChain(chainId),
            transport: custom(provider),
        });
        // Use Viem's waitForTransactionReceipt with timeout
        const receipt = await client.waitForTransactionReceipt({
            hash: txHash,
            timeout,
            pollingInterval,
        });
        // Check transaction status
        if (receipt.status === 'reverted') {
            return {
                success: false,
                error: 'Transaction failed (reverted)',
                receipt,
            };
        }
        // Get current block number for confirmation count
        const currentBlock = await client.getBlockNumber();
        const confirmations = Number(currentBlock - receipt.blockNumber) + 1;
        // Check if we have enough confirmations
        if (confirmations >= requiredConfirmations) {
            return {
                success: true,
                receipt,
                confirmations,
            };
        }
        const confirmationStartTime = Date.now();
        const confirmationTimeout = timeout || 300000;
        // Wait for additional confirmations if needed
        while (true) {
            await wait(pollingInterval);
            if (Date.now() - confirmationStartTime > confirmationTimeout) {
                return {
                    success: false,
                    error: `Confirmation timeout: only ${confirmations} of ${requiredConfirmations} confirmations received`,
                    receipt,
                    confirmations,
                };
            }
            const latestBlock = await client.getBlockNumber();
            const currentConfirmations = Number(latestBlock - receipt.blockNumber) + 1;
            if (currentConfirmations >= requiredConfirmations) {
                return {
                    success: true,
                    receipt,
                    confirmations: currentConfirmations,
                };
            }
        }
    }
    catch (error) {
        const errorMessage = error instanceof Error
            ? error.message
            : error?.shortMessage ||
                error?.message ||
                'Transaction receipt timeout';
        return {
            success: false,
            error: errorMessage,
        };
    }
}
/**
 * Utility function to get token contract address for a specific token and chain
 * @param token Token symbol (e.g., 'USDC', 'USDT')
 * @param chainId Chain ID
 * @param isTestnet Whether to use testnet addresses
 * @returns Contract address or undefined if not found
 */
function getTokenContractAddress(token, chainId) {
    const registry = TOKEN_CONTRACT_ADDRESSES;
    const address = registry[token]?.[chainId];
    return address || undefined;
}

export { CHAIN_METADATA, CaliburSBCTypes, DESTINATION_SWAP_TOKENS, LOG_LEVEL, MAINNET_CHAINS, NEXUS_EVENTS, SUPPORTED_CHAINS, SwapMode, TESTNET_CHAINS, TESTNET_TOKEN_METADATA, TOKEN_CONTRACT_ADDRESSES, TOKEN_METADATA, chainIdToHex, encodeContractCall, extractErrorMessage, formatBalance, formatTestnetTokenAmount, formatTokenAmount, formatUnits, getBlockExplorerUrl, getChainMetadata, getLogger, getMainnetTokenMetadata, getTestnetTokenMetadata, getTokenContractAddress, getTokenMetadata, getTransactionHashWithFallback, getViemChain, hexToChainId, isMainnetChain, isTestnetChain, isValidAddress, logger, parseUnits, setExceptionReporter, setLogLevel, truncateAddress, validateContractParams, validateHexResponse, validateTransactionHash, wait, waitForTransactionReceipt };
