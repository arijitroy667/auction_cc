'use strict';

var commons = require('./commons');
var viem = require('viem');
var caCommon = require('@arcana/ca-common');
var Decimal = require('decimal.js');
var fuels = require('fuels');
var axios = require('axios');
var itWs = require('it-ws');
var msgpackr = require('msgpackr');
var stargate = require('@cosmjs/stargate');
var tslib = require('tslib');
var SafeEventEmitter = require('@metamask/safe-event-emitter');
var starkwareCryptoUtils = require('@starkware-industries/starkware-crypto-utils');
var accounts = require('viem/accounts');
var siwe = require('viem/siwe');
var Long = require('long');
var utils = require('viem/utils');
var esToolkit = require('es-toolkit');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var Decimal__default = /*#__PURE__*/_interopDefault(Decimal);
var axios__default = /*#__PURE__*/_interopDefault(axios);
var SafeEventEmitter__default = /*#__PURE__*/_interopDefault(SafeEventEmitter);
var Long__default = /*#__PURE__*/_interopDefault(Long);

class NexusUtils {
    constructor(adapter, isReady) {
        this.adapter = adapter;
        this.isReady = isReady;
        // Pure utility functions (no adapter dependency)
        this.formatBalance = commons.formatBalance;
        this.parseUnits = commons.parseUnits;
        this.formatUnits = commons.formatUnits;
        this.isValidAddress = commons.isValidAddress;
        this.truncateAddress = commons.truncateAddress;
        this.chainIdToHex = commons.chainIdToHex;
        this.hexToChainId = commons.hexToChainId;
        this.getMainnetTokenMetadata = commons.getMainnetTokenMetadata;
        this.getTestnetTokenMetadata = commons.getTestnetTokenMetadata;
        this.getTokenMetadata = commons.getTokenMetadata;
        this.getChainMetadata = commons.getChainMetadata;
        this.formatTokenAmount = commons.formatTokenAmount;
        this.formatTestnetTokenAmount = commons.formatTestnetTokenAmount;
    }
    ensureInitialized() {
        if (!this.isReady()) {
            throw new Error('NexusSDK must be initialized before using utils methods that require adapter access. Call sdk.initialize() first.');
        }
    }
    getSupportedChains(env) {
        this.ensureInitialized();
        return this.adapter.getSupportedChains(env);
    }
    getSwapSupportedChainsAndTokens() {
        this.ensureInitialized();
        return this.adapter.nexusSDK.getSwapSupportedChainsAndTokens();
    }
    /* Same for isSupportedChain / isSupportedToken */
    isSupportedChain(chainId) {
        this.ensureInitialized();
        return this.adapter.isSupportedChain(chainId);
    }
    isSupportedToken(token) {
        this.ensureInitialized();
        return this.adapter.isSupportedToken(token);
    }
}

const BACKEND_URL = 'https://nexus-backend.avail.so';
/**
 * Backend client for gas estimation using new API
 */
class BackendSimulationClient {
    constructor(config) {
        this.baseUrl = config.baseUrl;
    }
    /**
     * Check if a specific chain is supported
     */
    async isChainSupported(chainId) {
        try {
            const response = await fetch(`${this.baseUrl}/api/gas-estimation/check-chain/${chainId}`);
            if (!response.ok)
                return false;
            const result = await response.json();
            return result.success && result.data?.supported === true;
        }
        catch (error) {
            commons.logger.warn(`Error checking chain support for ${chainId}:`, error);
            return false;
        }
    }
    /**
     * Get all supported chains
     */
    async getSupportedChains() {
        try {
            const response = await fetch(`${this.baseUrl}/api/gas-estimation/supported-chains`);
            if (!response.ok)
                return null;
            const result = await response.json();
            return result.success ? result.data || null : null;
        }
        catch (error) {
            commons.logger.warn('Error fetching supported chains:', error);
            return null;
        }
    }
    /**
     * Get service status
     */
    async getServiceStatus() {
        try {
            const response = await fetch(`${this.baseUrl}/api/gas-estimation/status`);
            if (!response.ok)
                return null;
            const result = await response.json();
            return result.success ? result.data || null : null;
        }
        catch (error) {
            commons.logger.warn('Error fetching service status:', error);
            return null;
        }
    }
    /**
     * Health check
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/api/health`);
            if (!response.ok)
                return null;
            const result = await response.json();
            return result.success ? result.data || null : null;
        }
        catch (error) {
            commons.logger.warn('Error performing health check:', error);
            return null;
        }
    }
    /**
     * Test connectivity and service health
     */
    async testConnection() {
        try {
            const health = await this.healthCheck();
            return health?.status === 'ok';
        }
        catch (error) {
            commons.logger.warn('Connection test failed:', error);
            return false;
        }
    }
    /**
     * Get detailed service information
     */
    async getServiceInfo() {
        try {
            const [health, status] = await Promise.all([this.healthCheck(), this.getServiceStatus()]);
            return {
                healthy: health?.status === 'ok',
                configured: status?.configured || false,
                supportedChains: status?.supportedChainsCount || 0,
                version: health?.version,
                uptime: health?.uptime,
            };
        }
        catch (error) {
            commons.logger.warn('Error getting service info:', error);
            return {
                healthy: false,
                configured: false,
                supportedChains: 0,
            };
        }
    }
    /**
     * Simulate transaction using Tenderly's Gateway RPC with state overrides
     * This provides more accurate simulation results than basic gas estimation
     */
    async simulate(request) {
        try {
            const response = await fetch(`${this.baseUrl}/api/gas-estimation/simulate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(request),
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Simulation API error: ${response.status} - ${errorText}`);
            }
            const result = await response.json();
            if (!result.success || !result.data) {
                throw new Error(result.error || result.message || 'Simulation failed');
            }
            const gasData = result.data;
            return {
                gasUsed: gasData.gasUsed,
                gasPrice: gasData.gasPrice || '0x0',
                maxFeePerGas: gasData.maxFeePerGas,
                maxPriorityFeePerGas: gasData.maxPriorityFeePerGas,
                success: true,
                estimatedCost: {
                    totalFee: gasData?.gasUsed || '0',
                },
            };
        }
        catch (error) {
            commons.logger.error('Simulation API error:', error);
            return {
                gasUsed: '0x0',
                gasPrice: '0x0',
                success: false,
                errorMessage: error instanceof Error ? error.message : 'Unknown error',
                estimatedCost: {
                    totalFee: '0',
                },
            };
        }
    }
    /**
     * Fetch current gas price via RPC
     */
    async getCurrentGasPrice(chainId) {
        try {
            const rpcUrl = this.getRpcUrl(chainId);
            const response = await fetch(rpcUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    method: 'eth_gasPrice',
                    params: [],
                    id: 1,
                }),
            });
            if (!response.ok) {
                throw new Error(`RPC request failed: ${response.status}`);
            }
            const result = await response.json();
            if (result.error) {
                throw new Error(`RPC error: ${result.error.message}`);
            }
            // Convert hex gas price to bigint
            return viem.hexToBigInt(result.result);
        }
        catch (error) {
            commons.logger.warn('Failed to fetch current gas price, using fallback:', error);
            // Fallback to 20 gwei if RPC call fails
            return BigInt('20000000000'); // 20 gwei in wei
        }
    }
    /**
     * Get RPC URL for a given chain ID using CHAIN_METADATA
     */
    getRpcUrl(chainId) {
        const chainIdNum = parseInt(chainId, 10);
        const chainMetadata = commons.CHAIN_METADATA[chainIdNum];
        if (!chainMetadata || !chainMetadata.rpcUrls || chainMetadata.rpcUrls.length === 0) {
            throw new Error(`No RPC URL available for chain ${chainId}`);
        }
        // Use the first RPC URL from the metadata
        return chainMetadata.rpcUrls[0];
    }
    async simulateBundle(request) {
        try {
            commons.logger.info('DEBUG simulateBundle - request:', JSON.stringify(request, null, 2));
            const response = await fetch(`${this.baseUrl}/api/gas-estimation/bundle`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(request),
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Bundle simulation API error: ${response.status} - ${errorText}`);
            }
            const result = await response.json();
            if (!result.success || !result.data) {
                throw new Error(result.message || 'Bundle simulation failed');
            }
            commons.logger.info('DEBUG simulateBundle - backend response:', result);
            // Fetch current gas price via RPC
            const currentGasPrice = await this.getCurrentGasPrice(request.chainId);
            commons.logger.info('DEBUG - Raw gas price from RPC (wei):', currentGasPrice.toString());
            commons.logger.info('DEBUG - Gas price in gwei:', (Number(currentGasPrice) / 1e9).toFixed(2));
            commons.logger.info('DEBUG - Chain ID:', request.chainId);
            // Transform backend response to human-readable format
            const transformedResults = result.data.map((item, index) => {
                const gasUsed = viem.hexToBigInt(item.gasUsed);
                commons.logger.info('DEBUG - Gas used (units):', gasUsed.toString());
                const gasCostWei = gasUsed * currentGasPrice;
                commons.logger.info('DEBUG - Gas cost (wei):', gasCostWei.toString());
                const gasCostEther = viem.formatEther(gasCostWei);
                return {
                    stepId: request.simulations[index]?.stepId || `step-${index}`,
                    gasUsed: gasCostEther, // Human-readable cost like "0.004205"
                    success: true,
                    error: undefined,
                };
            });
            // Calculate total cost
            const totalGasCostWei = result.data.reduce((sum, item) => {
                const gasUsed = viem.hexToBigInt(item.gasUsed);
                return sum + gasUsed * currentGasPrice;
            }, BigInt(0));
            const totalGasCostEther = viem.formatEther(totalGasCostWei);
            commons.logger.info('DEBUG simulateBundle - transformed response:', {
                results: transformedResults,
                totalGasUsed: totalGasCostEther,
                gasPriceUsed: viem.formatEther(currentGasPrice * BigInt(1000000000)) + ' gwei',
            });
            return {
                success: true,
                results: transformedResults,
                totalGasUsed: totalGasCostEther,
            };
        }
        catch (error) {
            commons.logger.error('Bundle simulation API error:', error);
            return {
                success: false,
                results: request.simulations.map((sim) => ({
                    stepId: sim.stepId,
                    gasUsed: '0.0',
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error',
                })),
                totalGasUsed: '0.0',
            };
        }
    }
}
/**
 * Default backend simulation client instance
 */
let defaultSimulationClient = null;
/**
 * Configure the default simulation client
 */
function configureSimulationBackend(config) {
    defaultSimulationClient = new BackendSimulationClient(config);
}
/**
 * Get the default simulation client
 */
function getSimulationClient() {
    return defaultSimulationClient;
}
/**
 * Initialize simulation client with health check
 */
async function initializeSimulationClient(baseUrl = BACKEND_URL) {
    try {
        const client = new BackendSimulationClient({ baseUrl });
        // Test the connection
        const isHealthy = await client.testConnection();
        if (!isHealthy) {
            return {
                success: false,
                error: `Backend service at ${baseUrl} is not responding or unhealthy`,
            };
        }
        // Configure as default client
        defaultSimulationClient = client;
        return {
            success: true,
        };
    }
    catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown initialization error',
        };
    }
}
// Initialize with BACKEND_URL by default
configureSimulationBackend({ baseUrl: BACKEND_URL });

const LOG_LEVEL = {
    DEBUG: 1,
    ERROR: 4,
    INFO: 2,
    NOLOGS: 5,
    WARNING: 3,
};
const sendException = (msg) => {
};
const setLogLevel = (level) => {
    state.logLevel = level;
};
const getLogger = () => {
    return state.logger;
};
class Logger {
    constructor() {
        this.prefix = "XAR_CA_SDK";
    }
    consoleLog(level, message, params) {
        if (level < state.logLevel) {
            return;
        }
        switch (level) {
            case LOG_LEVEL.DEBUG:
                console.debug(`[DEBUG]`, message, params);
                break;
            case LOG_LEVEL.ERROR:
                console.error(`[ERROR]`, message, params);
                break;
            case LOG_LEVEL.INFO:
                console.info(`[INFO]`, message, params);
                break;
            case LOG_LEVEL.WARNING:
                console.warn(`[WARN]`, message, params);
                break;
            default:
                console.log(`[LOG]`, message, params);
        }
    }
    debug(message, params = {}) {
        this.internalLog(LOG_LEVEL.DEBUG, message, params);
    }
    error(message, err) {
        if (err instanceof Error) {
            this.internalLog(LOG_LEVEL.ERROR, message, err.message);
            sendException(JSON.stringify({ error: err.message, message }));
            return;
        }
        if (typeof err == "string") {
            this.internalLog(LOG_LEVEL.ERROR, message, err);
            sendException(JSON.stringify({ error: err, message }));
        }
    }
    info(message, params = {}) {
        this.internalLog(LOG_LEVEL.INFO, message, params);
    }
    internalLog(level, message, params) {
        const logMessage = `[${this.prefix}] Msg: ${message}\n`;
        this.consoleLog(level, logMessage, params);
    }
    warn(message, params = {}) {
        this.internalLog(LOG_LEVEL.WARNING, message, params);
    }
}
const state = {
    logger: new Logger(),
    logLevel: LOG_LEVEL.NOLOGS,
};

const INTENT_ACCEPTED = {
    type: 'INTENT_ACCEPTED',
    typeID: 'IA',
};
const INTENT_HASH_SIGNED = {
    type: 'INTENT_HASH_SIGNED',
    typeID: 'IHS',
};
const INTENT_SUBMITTED = {
    type: 'INTENT_SUBMITTED',
    typeID: 'IS',
};
const INTENT_INIT_STEPS = [
    INTENT_HASH_SIGNED,
    {
        ...INTENT_SUBMITTED,
        data: {
            explorerURL: '',
            intentID: 0,
        },
    },
];
const INTENT_FULFILLED = {
    type: 'INTENT_FULFILLED',
    typeID: 'IF',
};
const ALLOWANCE_APPROVAL_REQ = (chainID) => ({
    type: 'ALLOWANCE_USER_APPROVAL',
    typeID: `AUA_${chainID}`,
});
const ALLOWANCE_APPROVAL_MINED = (chainID) => ({
    type: 'ALLOWANCE_APPROVAL_MINED',
    typeID: `AAM_${chainID}`,
});
const ALLOWANCE_COMPLETE = {
    type: 'ALLOWANCE_ALL_DONE',
    typeID: 'AAD',
};
const INTENT_DEPOSIT_REQ = (id) => ({
    type: 'INTENT_DEPOSIT',
    typeID: `ID_${id}`,
});
const INTENT_DEPOSITS_CONFIRMED = {
    type: 'INTENT_DEPOSITS_CONFIRMED',
    typeID: 'UIDC',
};
const INTENT_COLLECTION_COMPLETE = {
    type: 'INTENT_COLLECTION_COMPLETE',
    typeID: 'ICC',
};
const INTENT_COLLECTION = (id) => ({
    type: 'INTENT_COLLECTION',
    typeID: `IC_${id}`,
});
const INTENT_FINISH_STEPS = [INTENT_FULFILLED];
const createSteps = (intent, chainList, unallowedSources) => {
    const steps = [];
    steps.push(INTENT_ACCEPTED);
    if (unallowedSources && unallowedSources?.length > 0) {
        for (const source of unallowedSources) {
            steps.push({
                ...ALLOWANCE_APPROVAL_REQ(source.chain.id),
                data: {
                    chainID: source.chain.id,
                    chainName: source.chain.name,
                },
            }, {
                ...ALLOWANCE_APPROVAL_MINED(source.chain.id),
                data: {
                    chainID: source.chain.id,
                    chainName: source.chain.name,
                },
            });
        }
        steps.push(ALLOWANCE_COMPLETE);
    }
    steps.push(...INTENT_INIT_STEPS);
    const sources = intent.sources.filter((s) => s.chainID !== intent.destination.chainID);
    let collections = 0, deposits = 0;
    for (const [i, s] of sources.entries()) {
        const isNative = isNativeAddress$1(s.universe, s.tokenContract);
        if (isNative) {
            deposits++;
            const chain = chainList.getChainByID(s.chainID);
            if (!chain) {
                throw new Error(`Unknown chain ID ${s.chainID} while building steps`);
            }
            steps.push({
                ...INTENT_DEPOSIT_REQ(i + 1),
                data: {
                    amount: s.amount.toString(),
                    chainID: chain.id,
                    chainName: chain.name,
                    symbol: chain.nativeCurrency.symbol,
                },
            });
        }
        else {
            collections++;
            steps.push({
                ...INTENT_COLLECTION(i + 1),
                data: {
                    confirmed: i + 1,
                    total: sources.length,
                },
            });
        }
    }
    if (collections > 0) {
        steps.push(INTENT_COLLECTION_COMPLETE);
    }
    if (deposits > 0) {
        steps.push(INTENT_DEPOSITS_CONFIRMED);
    }
    steps.push(...INTENT_FINISH_STEPS);
    return steps;
};

const ERC20TransferABI = {
    constant: false,
    inputs: [
        {
            name: '_to',
            type: 'address',
        },
        {
            name: '_value',
            type: 'uint256',
        },
    ],
    name: 'transfer',
    outputs: [
        {
            name: '',
            type: 'bool',
        },
    ],
    payable: false,
    stateMutability: 'nonpayable',
    type: 'function',
};
const ERC20AllowanceABI = {
    constant: true,
    inputs: [
        {
            name: '_owner',
            type: 'address',
        },
        {
            name: '_spender',
            type: 'address',
        },
    ],
    name: 'allowance',
    outputs: [
        {
            name: '',
            type: 'uint256',
        },
    ],
    payable: false,
    stateMutability: 'view',
    type: 'function',
};
const ABI = [
    {
        constant: true,
        inputs: [],
        name: 'name',
        outputs: [
            {
                name: '',
                type: 'string',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: false,
        inputs: [
            {
                name: '_spender',
                type: 'address',
            },
            {
                name: '_value',
                type: 'uint256',
            },
        ],
        name: 'approve',
        outputs: [
            {
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'totalSupply',
        outputs: [
            {
                name: '',
                type: 'uint256',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: false,
        inputs: [
            {
                name: '_from',
                type: 'address',
            },
            {
                name: '_to',
                type: 'address',
            },
            {
                name: '_value',
                type: 'uint256',
            },
        ],
        name: 'transferFrom',
        outputs: [
            {
                name: '',
                type: 'bool',
            },
        ],
        payable: false,
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'decimals',
        outputs: [
            {
                name: '',
                type: 'uint8',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: true,
        inputs: [
            {
                name: '_owner',
                type: 'address',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                name: 'balance',
                type: 'uint256',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    {
        constant: true,
        inputs: [],
        name: 'symbol',
        outputs: [
            {
                name: '',
                type: 'string',
            },
        ],
        payable: false,
        stateMutability: 'view',
        type: 'function',
    },
    ERC20TransferABI,
    ERC20AllowanceABI,
    {
        payable: true,
        stateMutability: 'payable',
        type: 'fallback',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Approval',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Transfer',
        type: 'event',
    },
];
const ERC20PermitABI = [
    {
        comment: 'From the EIP-2612 spec.',
        inputs: [
            {
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'spender',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'value',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'deadline',
                type: 'uint256',
            },
            {
                internalType: 'uint8',
                name: 'v',
                type: 'uint8',
            },
            {
                internalType: 'bytes32',
                name: 'r',
                type: 'bytes32',
            },
            {
                internalType: 'bytes32',
                name: 's',
                type: 'bytes32',
            },
        ],
        name: 'permit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        comment: 'Available on bridged tokens on Polygon.',
        inputs: [
            {
                internalType: 'address',
                name: 'userAddress',
                type: 'address',
            },
            {
                internalType: 'bytes',
                name: 'functionSignature',
                type: 'bytes',
            },
            {
                internalType: 'bytes32',
                name: 'sigR',
                type: 'bytes32',
            },
            {
                internalType: 'bytes32',
                name: 'sigS',
                type: 'bytes32',
            },
            {
                internalType: 'uint8',
                name: 'sigV',
                type: 'uint8',
            },
        ],
        name: 'executeMetaTransaction',
        outputs: [
            {
                internalType: 'bytes',
                name: '',
                type: 'bytes',
            },
        ],
        stateMutability: 'payable',
        type: 'function',
    },
];
const ERC20PermitEIP712Type = {
    EIP712Domain: [
        { name: 'name', type: 'string' },
        { name: 'version', type: 'string' },
        { name: 'chainId', type: 'uint256' },
        { name: 'verifyingContract', type: 'address' },
    ],
    Permit: [
        { name: 'owner', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
    ],
};
const ERC20PermitEIP2612PolygonType = {
    EIP712Domain: [
        { name: 'name', type: 'string' },
        { name: 'version', type: 'string' },
        { name: 'verifyingContract', type: 'address' },
        { name: 'salt', type: 'bytes32' },
    ],
    MetaTransaction: [
        { name: 'nonce', type: 'uint256' },
        { name: 'from', type: 'address' },
        { name: 'functionSignature', type: 'bytes' },
    ],
};

var gasOracleABI = [
    { inputs: [], stateMutability: "nonpayable", type: "constructor" },
    {
        inputs: [],
        name: "DECIMALS",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "baseFee",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "decimals",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "gasPrice",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "bytes", name: "_data", type: "bytes" }],
        name: "getL1Fee",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "bytes", name: "_data", type: "bytes" }],
        name: "getL1GasUsed",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "l1BaseFee",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "overhead",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "scalar",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "version",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
];

const FillEvent = {
    anonymous: false,
    inputs: [
        {
            indexed: true,
            internalType: "bytes32",
            name: "requestHash",
            type: "bytes32",
        },
        {
            indexed: false,
            internalType: "address",
            name: "from",
            type: "address",
        },
        {
            indexed: false,
            internalType: "address",
            name: "solver",
            type: "address",
        },
    ],
    name: "Fill",
    type: "event",
};

const ErrorUserDeniedIntent$1 = new viem.UserRejectedRequestError(new Error("User denied intent."));
const ErrorUserDeniedAllowance = new viem.UserRejectedRequestError(new Error("User denied allowance."));
const ErrorInsufficientBalance$1 = new viem.InternalRpcError(new Error("Insufficient balance."));
new viem.InternalRpcError(new Error("Error while building intent."));
const ErrorLiquidityTimeout = new viem.InternalRpcError(new Error("Timed out waiting for liquidity."));

const logger$l = getLogger();
const isEVMTx = (tx) => {
    logger$l.debug('isEVMTx', tx);
    if (typeof tx !== 'object') {
        return false;
    }
    if (!tx) {
        return false;
    }
    if (!('to' in tx)) {
        return false;
    }
    if (!('data' in tx || 'value' in tx)) {
        return false;
    }
    return true;
};
const getAllowance = (chain, address, tokenContract, chainList) => {
    logger$l.debug('getAllowance', {
        tokenContract,
        ZERO_ADDRESS,
    });
    if (equalFold(ZERO_ADDRESS, tokenContract)) {
        return Promise.resolve(viem.maxUint256);
    }
    const publicClient = createPublicClientWithFallback(chain);
    return publicClient.readContract({
        abi: ABI,
        address: tokenContract,
        args: [address, chainList.getVaultContractAddress(chain.id)],
        functionName: 'allowance',
    });
};
const getAllowances = async (input, address, chainList) => {
    const values = {};
    const promises = [];
    for (const i of input) {
        if (i.chainID === fuels.CHAIN_IDS.fuel.mainnet) {
            promises.push(Promise.resolve(0n));
        }
        else {
            const chain = chainList.getChainByID(i.chainID);
            if (!chain) {
                throw new Error('chain not found');
            }
            promises.push(getAllowance(chain, address, i.tokenContract, chainList));
        }
    }
    const result = await Promise.all(promises);
    for (const i in result) {
        values[input[i].chainID] = result[i];
    }
    return values;
};
const waitForIntentFulfilment = async (publicClient, vaultContractAddr, requestHash, ac) => {
    return new Promise((resolve) => {
        const unwatch = publicClient.watchContractEvent({
            abi: [FillEvent],
            address: vaultContractAddr,
            args: { requestHash },
            eventName: 'Fill',
            onLogs: (logs) => {
                logger$l.debug('waitForIntentFulfilment', { logs });
                ac.abort();
                return resolve('ok');
            },
            poll: false,
        });
        ac.signal.addEventListener('abort', () => {
            unwatch();
            return resolve('ok from outside');
        }, { once: true });
    });
};
const requestTimeout = (timeout, ac) => {
    return new Promise((_, reject) => {
        const t = window.setTimeout(() => {
            ac.abort();
            return reject(ErrorLiquidityTimeout);
        }, minutesToMs(timeout));
        ac.signal.addEventListener('abort', () => {
            window.clearTimeout(t);
        }, { once: true });
    });
};
const getTokenTxFunction = (data) => {
    try {
        const { args, functionName } = viem.decodeFunctionData({
            abi: ABI,
            data,
        });
        return { args, functionName };
    }
    catch (e) {
        logger$l.debug('getTokenTxFunction', e);
        return { args: [], functionName: 'unknown' };
    }
};
const setAllowances = async (tokenContractAddresses, client, networkConfig, chainList, chain, amount) => {
    const vaultAddr = chainList.getVaultContractAddress(chain.id);
    const p = [];
    const address = (await client.getAddresses())[0];
    const chainId = new caCommon.OmniversalChainID(caCommon.Universe.ETHEREUM, chain.id);
    const chainDatum = caCommon.ChaindataMap.get(chainId);
    if (!chainDatum) {
        throw new Error('Chain data not found');
    }
    const account = {
        address,
        type: 'json-rpc',
    };
    const publicClient = createPublicClientWithFallback(chain);
    const sponsoredApprovalParams = {
        address: viem.hexToBytes(viem.pad(address, {
            dir: 'left',
            size: 32,
        })),
        chain_id: chainDatum.ChainID32,
        operations: [],
        universe: chainDatum.Universe,
    };
    for (const addr of tokenContractAddresses) {
        const currency = chainDatum.CurrencyMap.get(convertTo32Bytes$1(addr));
        if (!currency) {
            throw new Error('Currency not found');
        }
        if (currency.permitVariant === caCommon.PermitVariant.Unsupported) {
            const hash = await client.writeContract({
                abi: ABI,
                account: address,
                address: addr,
                args: [vaultAddr, amount],
                chain,
                functionName: 'approve',
            });
            p.push((async function () {
                const result = await publicClient.waitForTransactionReceipt({
                    confirmations: 2,
                    hash,
                });
                if (result.status === 'reverted') {
                    throw new Error('setAllowance failed with tx revert');
                }
            })());
        }
        else {
            const signed = viem.parseSignature(await signPermitForAddressAndValue(currency, client, publicClient, account, vaultAddr, amount));
            sponsoredApprovalParams.operations.push({
                sig_r: viem.hexToBytes(signed.r),
                sig_s: viem.hexToBytes(signed.s),
                sig_v: signed.yParity < 27 ? signed.yParity + 27 : signed.yParity,
                token_address: currency.tokenAddress,
                value: convertTo32Bytes$1(amount),
                variant: currency.permitVariant === caCommon.PermitVariant.PolygonEMT ? 2 : 1,
            });
        }
    }
    if (p.length) {
        await Promise.all(p);
    }
    if (sponsoredApprovalParams.operations.length) {
        await vscCreateSponsoredApprovals(networkConfig.VSC_DOMAIN, [sponsoredApprovalParams]);
    }
    return;
};
const DEFAULT_GAS_ORACLE_ADDRESS = '0x420000000000000000000000000000000000000F';
const L1_GAS_ORACLES = {
    10: DEFAULT_GAS_ORACLE_ADDRESS,
    11155420: DEFAULT_GAS_ORACLE_ADDRESS,
    534352: '0x5300000000000000000000000000000000000002',
    8453: DEFAULT_GAS_ORACLE_ADDRESS,
    84532: DEFAULT_GAS_ORACLE_ADDRESS,
};
const chainsWithGasOracles = Object.keys(L1_GAS_ORACLES).map(Number);
const getL1Fee = async (chain, input = '0x') => {
    let fee = 0n;
    if (chainsWithGasOracles.includes(chain.id)) {
        fee = await fetchL1Fee(chain, input);
    }
    return fee;
};
const fetchL1Fee = (chain, input) => {
    const pc = createPublicClientWithFallback(chain);
    return pc.readContract({
        abi: gasOracleABI,
        address: L1_GAS_ORACLES[chain.id],
        args: [input],
        functionName: 'getL1Fee',
    });
};
const waitForTxReceipt = async (hash, publicClient, confirmations = 1) => {
    const r = await publicClient.waitForTransactionReceipt({
        confirmations,
        hash,
    });
    if (r.status === 'reverted') {
        throw new Error(`Transaction reverted: ${hash}`);
    }
};
const switchChain = async (client, chain) => {
    try {
        await client.switchChain({ id: chain.id });
    }
    catch (e) {
        if (e instanceof viem.SwitchChainError && e.code === viem.SwitchChainError.code) {
            await client.addChain({
                chain,
            });
            await client.switchChain({ id: chain.id });
            return;
        }
        throw e;
    }
};
const EIP712Domain = [
    { name: 'name', type: 'string' },
    { name: 'version', type: 'string' },
    { name: 'chainId', type: 'uint256' },
    { name: 'verifyingContract', type: 'address' },
];
const PolygonDomain = [
    { name: 'name', type: 'string' },
    { name: 'version', type: 'string' },
    { name: 'verifyingContract', type: 'address' },
    { name: 'salt', type: 'bytes32' },
];
async function signPermitForAddressAndValue(cur, client, publicClient, account, spender, value, deadline) {
    const contract = viem.getContract({
        abi: caCommon.ERC20ABI,
        address: viem.bytesToHex(cur.tokenAddress.subarray(12)),
        client: { public: publicClient },
    });
    const walletAddress = account.address;
    deadline = deadline ?? 2n ** 256n - 1n;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const requestsToBeMade = [
        (() => {
            // Hack for sophon ETH
            return contract.read.name().catch(() => {
                return '';
            });
        })(),
        client.request({ method: 'eth_chainId' }, { dedupe: true }),
    ];
    switch (cur.permitVariant) {
        case caCommon.PermitVariant.Unsupported:
        default: {
            throw new caCommon.PermitCreationError('Permits are unsupported on this currency');
        }
        case caCommon.PermitVariant.DAI:
        case caCommon.PermitVariant.EIP2612Canonical:
        case caCommon.PermitVariant.Polygon2612: {
            requestsToBeMade[2] = contract.read.nonces([walletAddress]);
            break;
        }
        case caCommon.PermitVariant.PolygonEMT: {
            requestsToBeMade[2] = contract.read.getNonce([walletAddress]);
        }
    }
    const [name, chainID, nonce] = await Promise.all(requestsToBeMade);
    switch (cur.permitVariant) {
        case caCommon.PermitVariant.DAI: {
            return client.signTypedData({
                account,
                domain: {
                    chainId: viem.hexToBigInt(chainID),
                    name,
                    verifyingContract: contract.address,
                    version: cur.permitContractVersion.toString(10),
                },
                message: {
                    allowed: true,
                    expiry: deadline,
                    holder: walletAddress,
                    nonce,
                    spender: spender,
                },
                primaryType: 'Permit',
                types: {
                    EIP712Domain,
                    Permit: [
                        { name: 'holder', type: 'address' },
                        { name: 'spender', type: 'address' },
                        { name: 'nonce', type: 'uint256' },
                        { name: 'expiry', type: 'uint256' },
                        { name: 'allowed', type: 'bool' },
                    ],
                },
            });
        }
        case caCommon.PermitVariant.EIP2612Canonical: {
            return client.signTypedData({
                account,
                domain: {
                    chainId: viem.hexToBigInt(chainID),
                    name,
                    verifyingContract: contract.address,
                    version: cur.permitContractVersion.toString(10),
                },
                message: {
                    deadline,
                    nonce,
                    owner: walletAddress,
                    spender,
                    value,
                },
                primaryType: 'Permit',
                types: {
                    EIP712Domain,
                    Permit: [
                        { name: 'owner', type: 'address' },
                        { name: 'spender', type: 'address' },
                        { name: 'value', type: 'uint256' },
                        { name: 'nonce', type: 'uint256' },
                        { name: 'deadline', type: 'uint256' },
                    ],
                },
            });
        }
        case caCommon.PermitVariant.Polygon2612: {
            return client.signTypedData({
                account,
                domain: {
                    name,
                    salt: viem.pad(chainID, {
                        dir: 'left',
                        size: 32,
                    }),
                    verifyingContract: contract.address,
                    version: cur.permitContractVersion.toString(10),
                },
                message: {
                    allowed: true,
                    expiry: deadline,
                    holder: walletAddress,
                    nonce,
                    spender: spender,
                },
                primaryType: 'Permit',
                types: {
                    EIP712Domain: PolygonDomain,
                    Permit: [
                        { name: 'holder', type: 'address' },
                        { name: 'spender', type: 'address' },
                        { name: 'nonce', type: 'uint256' },
                        { name: 'expiry', type: 'uint256' },
                        { name: 'allowed', type: 'bool' },
                    ],
                },
            });
        }
        case caCommon.PermitVariant.PolygonEMT: {
            const funcSig = viem.encodeFunctionData({
                abi: ABI,
                args: [spender, value],
                functionName: 'approve',
            });
            return client.signTypedData({
                account,
                domain: {
                    name,
                    salt: viem.pad(chainID, {
                        dir: 'left',
                        size: 32,
                    }),
                    verifyingContract: contract.address,
                    version: cur.permitContractVersion.toString(10),
                },
                message: {
                    from: walletAddress,
                    functionSignature: funcSig,
                    nonce,
                },
                primaryType: 'MetaTransaction',
                types: {
                    EIP712Domain: PolygonDomain,
                    MetaTransaction: [
                        { name: 'nonce', type: 'uint256' },
                        { name: 'from', type: 'address' },
                        { name: 'functionSignature', type: 'bytes' },
                    ],
                },
            });
        }
    }
}
const createPublicClientWithFallback = (chain) => {
    if (chain.rpcUrls.default.http.length === 1) {
        return viem.createPublicClient({
            transport: viem.http(chain.rpcUrls.default.http[0]),
        });
    }
    return viem.createPublicClient({
        transport: viem.fallback(chain.rpcUrls.default.http.map((s) => viem.http(s))),
    });
};

const logger$k = getLogger();
const getCosmosURL = (cosmosURL, kind) => {
    const u = new URL(cosmosURL);
    if (kind === 'rpc') {
        // FIXME: don't hardcode port here
        u.port = '26650';
    }
    return u.toString();
};
const cosmosFeeGrant = async (cosmosURL, vscDomain, address) => {
    try {
        await axios__default.default.get(`/cosmos/auth/v1beta1/accounts/${address}`, {
            baseURL: getCosmosURL(cosmosURL, 'rest'),
        });
    }
    catch (e) {
        logger$k.error('Requesting a fee grant', e);
        const response = await vscCreateFeeGrant(vscDomain, address);
        logger$k.debug('Fee grant response', response.data);
        return;
    }
};
const cosmosCreateRFF$1 = async ({ address, cosmosURL, msg, wallet, }) => {
    const client = await caCommon.createCosmosClient(wallet, getCosmosURL(cosmosURL, 'rpc'), {
        broadcastPollIntervalMs: 250,
    });
    try {
        const res = await client.signAndBroadcast(address, [
            {
                typeUrl: '/xarchain.chainabstraction.MsgCreateRequestForFunds',
                value: msg,
            },
        ], {
            amount: [],
            gas: 100000n.toString(10),
        });
        if (stargate.isDeliverTxFailure(res)) {
            throw new Error(`Error creating RFF – code=${res.code} log=${res.rawLog ?? 'n/a'}`);
        }
        const decoded = caCommon.MsgCreateRequestForFundsResponse.decode(res.msgResponses[0].value);
        return decoded.id;
    }
    finally {
        client.disconnect();
    }
};
const cosmosRefundIntent = async (cosmosURL, intentID, wallet) => {
    const address = (await wallet.getAccounts())[0].address;
    const client = await caCommon.createCosmosClient(wallet, getCosmosURL(cosmosURL, 'rpc'), {
        broadcastPollIntervalMs: 250,
    });
    try {
        const resp = await client.signAndBroadcast(address, [
            {
                typeUrl: '/xarchain.chainabstraction.MsgRefundReq',
                value: caCommon.MsgRefundReq.create({
                    creator: address,
                    rffID: intentID,
                }),
            },
        ], {
            amount: [],
            gas: 100000n.toString(10),
        });
        logger$k.debug('Refund response', { resp });
        try {
            if (stargate.isDeliverTxSuccess(resp)) {
                const decoded = caCommon.MsgRefundReqResponse.decode(resp.msgResponses[0].value);
                logger$k.debug('Refund success', { decoded, resp });
                return resp;
            }
            else if (resp.code === 18) {
                if (resp.rawLog?.includes('RFF already refunded') ||
                    resp.rawLog?.includes('RFF already filled')) {
                    return resp;
                }
                throw new Error('RFF is not expired yet.');
            }
            else {
                throw new Error('unknown error');
            }
        }
        catch (e) {
            logger$k.error('Refund failed', e);
            throw e;
        }
    }
    finally {
        client.disconnect();
    }
};
const cosmosCreateDoubleCheckTx$1 = async ({ address, cosmosURL, msg, wallet, }) => {
    const client = await caCommon.createCosmosClient(wallet, getCosmosURL(cosmosURL, 'rpc'), {
        broadcastPollIntervalMs: 250,
    });
    try {
        logger$k.debug('cosmosCreateDoubleCheckTx', { doubleCheckMsg: msg });
        const res = await client.signAndBroadcast(address, [
            {
                typeUrl: '/xarchain.chainabstraction.MsgDoubleCheckTx',
                value: msg,
            },
        ], {
            amount: [],
            gas: 100000n.toString(10),
        });
        if (stargate.isDeliverTxFailure(res)) {
            throw new Error('Error creating MsgDoubleCheckTx');
        }
        logger$k.debug('double check response', { doubleCheckTx: res });
    }
    finally {
        client.disconnect();
    }
};
const decoder = new TextDecoder('utf-8');
const cosmosFillCheck = async (intentID, grpcURL, cosmosURL, ac) => {
    return Promise.any([
        waitForCosmosFillEvent(intentID, cosmosURL, ac),
        checkIntentFilled(intentID, grpcURL),
    ]);
};
const waitForCosmosFillEvent = async (intentID, cosmosURL, ac) => {
    const u = new URL('/websocket', cosmosURL);
    u.protocol = 'wss';
    u.port = '26650';
    const connection = itWs.connect(u.toString());
    await connection.connected();
    ac.signal.addEventListener('abort', () => {
        connection.close();
        return Promise.resolve('ok from outside');
    }, { once: true });
    const EVENT = 'xarchain.chainabstraction.RFFFulfilledEvent.id';
    try {
        connection.socket.send(JSON.stringify({
            id: '0',
            jsonrpc: '2.0',
            method: 'subscribe',
            params: {
                query: `${EVENT}='"${intentID}"'`,
            },
        }));
        for await (const resp of connection.source) {
            const decodedResponse = JSON.parse(decoder.decode(resp));
            if (decodedResponse.result.events &&
                EVENT in decodedResponse.result.events &&
                decodedResponse.result.events[EVENT].includes(`"${intentID}"`)) {
                ac.abort();
                return 'ok';
            }
        }
        throw new Error('waitForCosmosFillEvent: out of loop but no events');
    }
    finally {
        connection.close();
    }
};

const logger$j = getLogger();
function convertAddressByUniverse(input, universe) {
    const inputIsString = typeof input === 'string';
    const bytes = inputIsString ? viem.toBytes(input) : input;
    if (universe === caCommon.Universe.ETHEREUM) {
        if (bytes.length === 20) {
            return inputIsString ? input : bytes;
        }
        if (bytes.length === 32) {
            return inputIsString ? viem.toHex(bytes.subarray(12)) : bytes.subarray(12);
        }
        throw new Error('invalid length of input');
    }
    if (universe === caCommon.Universe.FUEL) {
        if (bytes.length === 32) {
            return inputIsString ? input : bytes;
        }
        if (bytes.length === 20) {
            const padded = viem.pad(bytes, {
                dir: 'left',
                size: 32,
            });
            return inputIsString ? viem.toHex(padded) : padded;
        }
        throw new Error('invalid length of input');
    }
    return viem.toHex(input);
}
const minutesToMs = (min) => min * 60 * 1000;
const INTENT_KEY = 'xar-sdk-intents';
const getIntentKey = (address) => {
    return `${INTENT_KEY}-${address}`;
};
const storeIntentHashToStore = (address, id, createdAt = Date.now()) => {
    let intents = [];
    const fetchedIntents = localStorage.getItem(getIntentKey(address));
    if (fetchedIntents) {
        intents = JSON.parse(fetchedIntents) ?? [];
    }
    intents.push({ createdAt, id });
    localStorage.setItem(getIntentKey(address), JSON.stringify(intents));
};
const removeIntentHashFromStore = (address, id) => {
    let intents = [];
    const fetchedIntents = localStorage.getItem(getIntentKey(address));
    if (fetchedIntents) {
        intents = JSON.parse(fetchedIntents) ?? [];
    }
    const oLen = intents.length;
    intents = intents.filter((h) => h.id !== id.toNumber());
    if (oLen !== intents.length) {
        localStorage.setItem(getIntentKey(address), JSON.stringify(intents));
    }
};
const getExpiredIntents = (address) => {
    let intents = [];
    const fetchedIntents = localStorage.getItem(getIntentKey(address));
    if (fetchedIntents) {
        intents = JSON.parse(fetchedIntents) ?? [];
    }
    logger$j.debug('getExpiredIntents', { intents });
    const expiredIntents = [];
    const nonExpiredIntents = [];
    const TEN_MINUTES_BEFORE = Date.now() - 600000;
    for (const intent of intents) {
        if (intent.createdAt < TEN_MINUTES_BEFORE) {
            expiredIntents.push(intent);
        }
        else {
            nonExpiredIntents.push(intent);
        }
    }
    localStorage.setItem(getIntentKey(address), JSON.stringify(nonExpiredIntents));
    return expiredIntents;
};
const refundExpiredIntents = async (address, cosmosURL, wallet) => {
    logger$j.debug('Starting check for expired intents at ', new Date());
    const expIntents = getExpiredIntents(address);
    const failedRefunds = [];
    for (const intent of expIntents) {
        logger$j.debug(`Starting refund for: ${intent.id}`);
        try {
            await cosmosRefundIntent(cosmosURL, intent.id, wallet);
        }
        catch (e) {
            logger$j.debug('Refund failed', e);
            failedRefunds.push({
                createdAt: intent.createdAt,
                id: intent.id,
            });
        }
    }
    if (failedRefunds.length > 0) {
        for (const failed of failedRefunds) {
            storeIntentHashToStore(address, failed.id, failed.createdAt);
        }
    }
};
const equalFold = (a, b) => {
    if (!a || !b) {
        return false;
    }
    return a.toLowerCase() === b.toLowerCase();
};
const createRequestFuelSignature = async (fuelVaultAddress, provider, connector, fuelRFF) => {
    const account = await connector.currentAccount();
    if (!account) {
        throw new Error('Fuel connector is not connected.');
    }
    const vault = new caCommon.ArcanaVault(fuels.hexlify(fuelVaultAddress), provider);
    const { value: hash } = await vault.functions.hash_request(fuelRFF).get();
    const signature = await connector.signMessage(account, {
        personalSign: fuels.arrayify(hash),
    });
    return { requestHash: hash, signature: fuels.arrayify(signature) };
};
const getExplorerURL = (baseURL, id) => {
    return new URL(`/intent/${id.toNumber()}`, baseURL).toString();
};
/**
 * @param input
 * @param decimals
 * @returns input / (10**decimals)
 */
const divDecimals = (input, decimals) => {
    return new Decimal__default.default(input.toString()).div(Decimal__default.default.pow(10, decimals));
};
/**
 * @param input
 * @param decimals
 * @returns BigInt(input * (10**decimals))
 */
const mulDecimals = (input, decimals) => {
    return BigInt(new Decimal__default.default(input).mul(Decimal__default.default.pow(10, decimals)).toFixed(0, Decimal__default.default.ROUND_CEIL));
};
const convertIntent = (intent, token, chainList) => {
    console.time('convertIntent');
    const sources = [];
    let sourcesTotal = new Decimal__default.default(0);
    for (const s of intent.sources) {
        const chainInfo = chainList.getChainByID(s.chainID);
        if (!chainInfo) {
            throw new Error('chain not supported');
        }
        sources.push({
            amount: s.amount.toFixed(),
            chainID: chainInfo.id,
            chainLogo: chainInfo.custom.icon,
            chainName: chainInfo.name,
            contractAddress: s.tokenContract,
        });
        sourcesTotal = sourcesTotal.plus(s.amount);
    }
    const allSources = [];
    for (const s of intent.allSources) {
        const chainInfo = chainList.getChainByID(s.chainID);
        if (!chainInfo) {
            throw new Error('chain not supported');
        }
        allSources.push({
            amount: s.amount.toFixed(),
            chainID: chainInfo.id,
            chainLogo: chainInfo.custom.icon,
            chainName: chainInfo.name,
            contractAddress: s.tokenContract,
        });
    }
    const destinationChainInfo = chainList.getChainByID(intent.destination.chainID);
    if (!destinationChainInfo) {
        throw new Error('chain not supported');
    }
    const destination = {
        amount: intent.destination.amount.toFixed(),
        chainID: intent.destination.chainID,
        chainLogo: destinationChainInfo?.custom.icon,
        chainName: destinationChainInfo?.name,
    };
    console.timeEnd('convertIntent');
    return {
        allSources,
        destination,
        fees: {
            caGas: Decimal__default.default.sum(intent.fees.collection, intent.fees.fulfilment).toFixed(token.decimals),
            gasSupplied: new Decimal__default.default(intent.fees.gasSupplied).toFixed(),
            protocol: new Decimal__default.default(intent.fees.protocol).toFixed(),
            solver: new Decimal__default.default(intent.fees.solver).toFixed(),
            total: Decimal__default.default.sum(intent.fees.collection, intent.fees.solver, intent.fees.protocol, intent.fees.fulfilment, intent.fees.gasSupplied).toFixed(token.decimals),
        },
        sources,
        sourcesTotal: sourcesTotal.toFixed(token.decimals),
        token: {
            decimals: token.decimals,
            logo: token.logo,
            name: token.name,
            symbol: token.symbol.toUpperCase(),
        },
    };
};
const getSupportedChains = (env = caCommon.Environment.CORAL) => {
    const chainList = new ChainList(env);
    return chainList.chains.map((chain) => {
        return {
            id: chain.id,
            logo: chain.custom.icon,
            name: chain.name,
            tokens: [...chain.custom.knownTokens],
        };
    });
};
const isArcanaWallet = (p) => {
    if ('isArcana' in p && p.isArcana) {
        return true;
    }
    return false;
};
const createRequestEVMSignature = async (evmRFF, evmAddress, client) => {
    logger$j.debug('createReqEVMSignature', { evmRFF });
    const abi = viem.getAbiItem({ abi: caCommon.EVMVaultABI, name: 'deposit' });
    const msg = viem.encodeAbiParameters(abi.inputs[0].components, [
        evmRFF.sources,
        evmRFF.destinationUniverse,
        evmRFF.destinationChainID,
        evmRFF.destinations,
        evmRFF.nonce,
        evmRFF.expiry,
        evmRFF.parties,
    ]);
    const hash = viem.keccak256(msg, 'bytes');
    const signature = viem.toBytes(await client.signMessage({
        account: evmAddress,
        message: { raw: hash },
    }));
    return { requestHash: viem.hashMessage({ raw: hash }), signature };
};
const convertGasToToken = (token, oraclePrices, destinationChainID, destinationUniverse, gas) => {
    if (isNativeAddress$1(destinationUniverse, token.contractAddress)) {
        return gas;
    }
    const gasTokenInUSD = oraclePrices
        .find((rate) => rate.chainId === destinationChainID &&
        (equalFold(rate.tokenAddress, ZERO_ADDRESS) ||
            equalFold(rate.tokenAddress, FUEL_BASE_ASSET_ID)))
        ?.priceUsd.toFixed() ?? '0';
    const transferTokenInUSD = oraclePrices
        .find((rate) => rate.chainId === destinationChainID && equalFold(rate.tokenAddress, token.contractAddress))
        ?.priceUsd.toFixed();
    if (!transferTokenInUSD) {
        throw new Error('could not find token in price oracle');
    }
    const usdValue = gas.mul(gasTokenInUSD);
    const tokenEquivalent = usdValue.div(transferTokenInUSD);
    return tokenEquivalent.toDP(token.decimals, Decimal__default.default.ROUND_CEIL);
};
const evmWaitForFill = async (vaultContractAddress, publicClient, requestHash, intentID, grpcURL, cosmosURL) => {
    const ac = new AbortController();
    await Promise.race([
        waitForIntentFulfilment(publicClient, vaultContractAddress, requestHash, ac),
        requestTimeout(3, ac),
        cosmosFillCheck(intentID, grpcURL, cosmosURL, ac),
    ]);
};
const convertTo32Bytes$1 = (value) => {
    if (typeof value == 'bigint' || typeof value === 'number') {
        return viem.toBytes(value, {
            size: 32,
        });
    }
    if (typeof value === 'string') {
        return viem.pad(viem.toBytes(value), {
            dir: 'left',
            size: 32,
        });
    }
    throw new Error('invalid type');
};
const convertTo32BytesHex = (value) => {
    const bytes = convertTo32Bytes$1(value);
    return viem.toHex(bytes);
};
const convertToHexAddressByUniverse = (address, universe) => {
    if (universe === caCommon.Universe.FUEL) {
        if (address.length === 32) {
            return viem.bytesToHex(address);
        }
        else {
            throw new Error('fuel: invalid address length');
        }
    }
    else if (universe === caCommon.Universe.ETHEREUM) {
        if (address.length === 20) {
            return viem.bytesToHex(address);
        }
        else if (address.length === 32) {
            if (!address.subarray(0, 12).every((b) => b === 0)) {
                throw new Error('evm: non-zero-padded 32-byte address');
            }
            return viem.bytesToHex(address.subarray(12));
        }
        else {
            throw new Error('evm: invalid address length');
        }
    }
    else {
        throw new Error('unsupported universe');
    }
};
const createDepositDoubleCheckTx = (chainID, cosmos, intentID, network) => {
    const msg = caCommon.MsgDoubleCheckTx.create({
        creator: cosmos.address,
        packet: {
            $case: 'depositPacket',
            value: caCommon.DepositVEPacket.create({
                gasRefunded: false,
                id: intentID,
            }),
        },
        txChainID: chainID,
        txUniverse: caCommon.Universe.ETHEREUM,
    });
    return () => {
        return cosmosCreateDoubleCheckTx$1({
            address: cosmos.address,
            cosmosURL: network.COSMOS_URL,
            msg,
            wallet: cosmos.wallet,
        });
    };
};
const getSDKConfig = (c) => {
    const config = {
        debug: c.debug ?? false,
        network: caCommon.Environment.CORAL,
    };
    switch (c.network) {
        case 'testnet': {
            config.network = caCommon.Environment.FOLLY;
            break;
        }
        case 'mainnet': {
            config.network = caCommon.Environment.CORAL;
            break;
        }
    }
    return config;
};
const getTxOptions = (options) => {
    const defaultOptions = {
        bridge: false,
        gas: 0n,
        skipTx: false,
        sourceChains: [],
    };
    if (options?.bridge !== undefined) {
        defaultOptions.bridge = options.bridge;
    }
    if (options?.gas !== undefined) {
        defaultOptions.gas = options.gas;
    }
    if (options?.skipTx !== undefined) {
        defaultOptions.skipTx = options.skipTx;
    }
    if (options?.sourceChains !== undefined) {
        defaultOptions.sourceChains = options.sourceChains;
    }
    return defaultOptions;
};
class UserAsset {
    get balance() {
        return this.value.balance;
    }
    constructor(value) {
        this.value = value;
    }
    getBalanceOnChain(chainID, tokenAddress) {
        return (this.value.breakdown.find((b) => {
            if (tokenAddress) {
                return b.chain.id === chainID && equalFold(b.contractAddress, tokenAddress);
            }
            return b.chain.id === chainID;
        })?.balance ?? '0');
    }
    isDeposit(tokenAddress, universe) {
        if (universe === caCommon.Universe.ETHEREUM) {
            return equalFold(tokenAddress, ZERO_ADDRESS);
        }
        if (universe === caCommon.Universe.FUEL) {
            return true;
        }
        return false;
    }
    iterate(feeStore) {
        return this.value.breakdown
            .filter((b) => new Decimal__default.default(b.balance).gt(0))
            .sort((a, b) => {
            if (a.chain.id === 1) {
                return 1;
            }
            if (b.chain.id === 1) {
                return -1;
            }
            return Decimal__default.default.sub(b.balance, a.balance).toNumber();
        })
            .map((b) => {
            let balance = new Decimal__default.default(b.balance);
            if (this.isDeposit(b.contractAddress, b.universe)) {
                const collectionFee = feeStore.calculateCollectionFee({
                    decimals: b.decimals,
                    sourceChainID: b.chain.id,
                    sourceTokenAddress: b.contractAddress,
                });
                let estimatedGasForDeposit = collectionFee.mul(b.chain.id === 1 ? 2 : 4);
                if (b.contractAddress === FUEL_BASE_ASSET_ID && b.chain.id === fuels.CHAIN_IDS.fuel.mainnet) {
                    // Estimating this amount of gas is required for fuel -> vault
                    estimatedGasForDeposit = new Decimal__default.default('0.000_003');
                }
                if (new Decimal__default.default(b.balance).lessThan(estimatedGasForDeposit)) {
                    balance = new Decimal__default.default(0);
                }
                else {
                    balance = new Decimal__default.default(b.balance).minus(estimatedGasForDeposit);
                }
            }
            return {
                balance,
                chainID: b.chain.id,
                decimals: b.decimals,
                tokenContract: b.contractAddress,
                universe: b.universe,
            };
        });
    }
}
class UserAssets {
    constructor(data) {
        this.data = data;
    }
    add(asset) {
        this.data.push(asset);
    }
    find(symbol) {
        for (const asset of this.data) {
            if (equalFold(asset.symbol, symbol)) {
                return new UserAsset(asset);
            }
        }
        throw new Error('Asset is not supported.');
    }
    findOnChain(chainID, address) {
        return this.data.find((asset) => {
            const index = asset.breakdown.findIndex((b) => b.chain.id === chainID && equalFold(b.contractAddress, address));
            if (index > -1) {
                return asset;
            }
            return null;
        });
    }
    getAssetDetails(chain, address) {
        let asset = this.findOnChain(chain.id, address);
        getLogger().debug('getAssetDetails', {
            asset,
            assets: this.data,
        });
        const destinationGasBalance = this.getNativeBalance(chain);
        const chainsWithBalance = this.getChainCountWithBalance(asset);
        const destinationAssetBalance = asset?.breakdown.find((b) => b.chain.id === chain.id)?.balance ?? '0';
        return {
            chainsWithBalance,
            destinationAssetBalance,
            destinationGasBalance,
        };
    }
    getBalanceInFiat() {
        return this.data
            .reduce((total, asset) => {
            return total.add(asset.balanceInFiat);
        }, new Decimal__default.default(0))
            .toDecimalPlaces(2)
            .toNumber();
    }
    getChainCountWithBalance(asset) {
        return asset?.breakdown.filter((b) => new Decimal__default.default(b.balance).gt(0)).length ?? 0;
    }
    getNativeBalance(chain) {
        const asset = this.data.find((a) => equalFold(a.symbol, chain.nativeCurrency.symbol));
        if (asset) {
            return asset.breakdown.find((b) => b.chain.id === chain.id)?.balance ?? '0';
        }
        return '0';
    }
    sort() {
        this.data.forEach((asset) => {
            asset.breakdown.sort((a, b) => b.balanceInFiat - a.balanceInFiat);
        });
        this.data.sort((a, b) => b.balanceInFiat - a.balanceInFiat);
    }
    [Symbol.iterator]() {
        return this.data.values();
    }
}

const logger$i = getLogger();
let cosmosQueryClient = null;
const getCosmosQueryClient = (grpcURL) => {
    if (!cosmosQueryClient) {
        const rpc = new caCommon.GrpcWebImpl(grpcURL, {});
        cosmosQueryClient = new caCommon.QueryClientImpl(rpc);
    }
    return cosmosQueryClient;
};
const PAGE_LIMIT = 100;
async function fetchMyIntents(address, grpcURL, page = 1) {
    try {
        const response = await getCosmosQueryClient(grpcURL).RequestForFundsByAddress({
            account: address,
            pagination: {
                limit: PAGE_LIMIT,
                offset: (page - 1) * PAGE_LIMIT,
                reverse: true,
            },
        });
        return intentTransform(response.requestForFunds);
    }
    catch (error) {
        logger$i.error('Failed to fetch intents', error);
        throw new Error('Failed to fetch intents');
    }
}
const intentTransform = (input) => {
    return input.map((rff) => ({
        deposited: rff.deposited,
        destinationChainID: viem.bytesToNumber(rff.destinationChainID),
        destinations: rff.destinations.map((d) => ({
            tokenAddress: convertToHexAddressByUniverse(d.tokenAddress, rff.destinationUniverse),
            value: viem.bytesToBigInt(d.value),
        })),
        destinationUniverse: caCommon.Universe[rff.destinationUniverse],
        expiry: rff.expiry.toNumber(),
        fulfilled: rff.fulfilled,
        id: rff.id.toNumber(),
        refunded: rff.refunded,
        sources: rff.sources.map((s) => ({
            chainID: viem.bytesToNumber(s.chainID),
            tokenAddress: convertToHexAddressByUniverse(s.tokenAddress, s.universe),
            universe: caCommon.Universe[s.universe],
            value: viem.bytesToBigInt(s.value),
        })),
    }));
};
async function fetchProtocolFees(grpcURL) {
    try {
        const response = await getCosmosQueryClient(grpcURL).ProtocolFees({
            Universe: caCommon.Universe.FUEL,
        });
        return response;
    }
    catch (error) {
        logger$i.error('Failed to fetch protocol fees', error);
        throw new Error('Failed to fetch protocol fees');
    }
}
async function fetchSolverData(grpcURL) {
    try {
        const response = await getCosmosQueryClient(grpcURL).SolverDataAll({});
        return response;
    }
    catch (error) {
        logger$i.error('Failed to fetch solver data', error);
        throw new Error('Failed to fetch solver data');
    }
}
const fetchPriceOracle = async (grpcURL) => {
    const data = await getCosmosQueryClient(grpcURL).PriceOracleData({});
    if (data.PriceOracleData?.priceData?.length) {
        const oracleRates = data.PriceOracleData?.priceData.map((data) => ({
            chainId: viem.bytesToNumber(data.chainID),
            priceUsd: new Decimal__default.default(viem.bytesToNumber(data.price)).div(Decimal__default.default.pow(10, data.decimals)),
            tokenAddress: convertAddressByUniverse(viem.toHex(data.tokenAddress), data.universe),
            tokensPerUsd: new Decimal__default.default(1).div(new Decimal__default.default(viem.bytesToNumber(data.price)).div(Decimal__default.default.pow(10, data.decimals))),
        }));
        return oracleRates;
    }
    throw new Error('InternalError: No price data found.');
};
class FeeStore {
    constructor(data) {
        this.data = data;
    }
    calculateCollectionFee({ decimals, sourceChainID, sourceTokenAddress, }) {
        const collectionFee = this.data.fee.collection.find((f) => {
            return Number(f.chainID) === sourceChainID && equalFold(f.tokenAddress, sourceTokenAddress);
        });
        if (!collectionFee) {
            return new Decimal__default.default(0);
        }
        return divDecimals(collectionFee.fee ?? 0, decimals);
    }
    calculateFulfilmentFee({ decimals, destinationChainID, destinationTokenAddress, }) {
        const fulfilmentFeeBasis = this.data.fee.fulfilment.find((f) => {
            return (Number(f.chainID) === destinationChainID &&
                equalFold(f.tokenAddress, destinationTokenAddress));
        });
        if (!fulfilmentFeeBasis) {
            return new Decimal__default.default(0);
        }
        return new Decimal__default.default(fulfilmentFeeBasis.fee ?? 0).div(Decimal__default.default.pow(10, decimals));
    }
    calculateProtocolFee(borrow) {
        const protocolFeeBasis = new Decimal__default.default(this.data.fee.protocol.feeBP ?? 0).div(Decimal__default.default.pow(10, 4));
        return borrow.mul(protocolFeeBasis);
    }
    calculateSolverFee({ borrowAmount, decimals, destinationChainID, destinationTokenAddress, sourceChainID, sourceTokenAddress, }) {
        const solverFeeBP = this.data.solverRoutes.find((f) => {
            return (Number(f.sourceChainID) === sourceChainID &&
                Number(f.destinationChainID) === destinationChainID &&
                equalFold(f.sourceTokenAddress, sourceTokenAddress) &&
                equalFold(f.destinationTokenAddress, destinationTokenAddress));
        })?.feeBP ?? 0;
        return new Decimal__default.default(solverFeeBP ?? 0)
            .div(Decimal__default.default.pow(10, 4))
            .mul(borrowAmount)
            .toDP(decimals, Decimal__default.default.ROUND_CEIL);
    }
}
const getFeeStore = async (grpcURL) => {
    const feeData = {
        fee: {
            collection: [],
            fulfilment: [],
            protocol: {
                feeBP: '0',
            },
        },
        solverRoutes: [],
    };
    const [p, s] = await Promise.allSettled([fetchProtocolFees(grpcURL), fetchSolverData(grpcURL)]);
    if (p.status === 'fulfilled') {
        logger$i.debug('getFeeStore', {
            collection: p.value.ProtocolFees?.collectionFees,
            fulfilment: p.value.ProtocolFees?.fulfilmentFees,
            protocol: p.value.ProtocolFees?.feeBP,
        });
        feeData.fee.protocol.feeBP = p.value.ProtocolFees?.feeBP.toString(10) ?? '0';
        feeData.fee.collection =
            p.value.ProtocolFees?.collectionFees.map((fee) => {
                return {
                    chainID: viem.bytesToNumber(fee.chainID),
                    fee: viem.bytesToNumber(fee.fee),
                    tokenAddress: convertAddressByUniverse(viem.toHex(fee.tokenAddress), fee.universe),
                    universe: fee.universe,
                };
            }) ?? [];
        feeData.fee.fulfilment =
            p.value.ProtocolFees?.fulfilmentFees.map((fee) => {
                return {
                    chainID: viem.bytesToNumber(fee.chainID),
                    fee: viem.bytesToNumber(fee.fee),
                    tokenAddress: convertAddressByUniverse(viem.toHex(fee.tokenAddress), fee.universe),
                    universe: fee.universe,
                };
            }) ?? [];
    }
    if (s.status === 'fulfilled') {
        feeData.solverRoutes =
            s.value.solverData[0]?.advertisedFees.map((s) => {
                return {
                    destinationChainID: viem.bytesToNumber(s.destinationChainID),
                    destinationTokenAddress: convertAddressByUniverse(viem.toHex(s.destinationTokenAddress), s.destinationUniverse),
                    destinationUniverse: s.destinationUniverse,
                    feeBP: s.feeBP,
                    sourceChainID: viem.bytesToNumber(s.sourceChainID),
                    sourceTokenAddress: convertAddressByUniverse(viem.toHex(s.sourceTokenAddress), s.sourceUniverse),
                    sourceUniverse: s.sourceUniverse,
                };
            }) || [];
    }
    return new FeeStore(feeData);
};
const getVSCURL = (vscDomain, protocol) => {
    return `${protocol}://${vscDomain}`;
};
let vscReq = null;
const getVscReq = (vscDomain) => {
    if (!vscReq) {
        vscReq = axios__default.default.create({
            baseURL: new URL('/api/v1', getVSCURL(vscDomain, 'https')).toString(),
            headers: {
                Accept: 'application/msgpack',
            },
            responseType: 'arraybuffer',
            transformRequest: [
                function (data, headers) {
                    if (['get', 'head'].includes(this.method.toLowerCase()))
                        return;
                    headers['Content-Type'] = 'application/msgpack';
                    return msgpackr.pack(data);
                },
            ],
            transformResponse: [(data) => msgpackr.unpack(data)],
        });
    }
    return vscReq;
};
const getBalancesFromVSC = async (vscDomain, address, namespace = 'ETHEREUM') => {
    const response = await getVscReq(vscDomain).get(`/get-balance/${namespace}/${address}`);
    return response.data.balances;
};
const getEVMBalancesForAddress = async (vscDomain, address) => {
    return getBalancesFromVSC(vscDomain, address);
};
const getFuelBalancesForAddress = async (vscDomain, address) => {
    return getBalancesFromVSC(vscDomain, address, 'FUEL');
};
const vscCreateFeeGrant = async (vscDomain, address) => {
    const response = await getVscReq(vscDomain).post(`/create-feegrant`, {
        cosmos_address: address,
    });
    return response;
};
const vscPublishRFF = async (vscDomain, id) => {
    const response = await getVscReq(vscDomain).post('/publish-rff', {
        id: id.toNumber(),
    });
    logger$i.debug('publishRFF', { response });
    return { id };
};
const vscCreateSponsoredApprovals = async (vscDomain, input, msd) => {
    const connection = itWs.connect(new URL('/api/v1/create-sponsored-approvals', getVSCURL(vscDomain, 'wss')).toString());
    await connection.connected();
    try {
        connection.socket.send(msgpackr.pack(input));
        let count = 0;
        for await (const resp of connection.source) {
            const data = msgpackr.unpack(resp);
            logger$i.debug('vscCreateSponsoredApprovals', { data });
            if ('errored' in data && data.errored) {
                throw new Error(data.error);
            }
            if ('error' in data && data.error) {
                throw new Error(data.msg);
            }
            if (msd) {
                msd(ALLOWANCE_APPROVAL_MINED(viem.bytesToNumber(input[data.part_idx].chain_id)));
            }
            count += 1;
            if (count == input.length) {
                break;
            }
        }
        return 'ok';
    }
    finally {
        connection.close();
    }
};
const vscCreateRFF = async (vscDomain, id, msd, expectedCollectionIndexes) => {
    const receivedCollectionsACKs = [];
    const connection = itWs.connect(new URL('/api/v1/create-rff', getVSCURL(vscDomain, 'wss')).toString());
    await connection.connected();
    logger$i.debug('vscCreateRFF', {
        expectedCollectionIndexes,
    });
    try {
        connection.socket.send(msgpackr.pack({ id: id.toNumber() }));
        for await (const resp of connection.source) {
            const data = msgpackr.unpack(resp);
            logger$i.debug('vscCreateRFF:response', { data });
            if (data.status === 255) {
                if (expectedCollectionIndexes.length === receivedCollectionsACKs.length) {
                    msd(INTENT_COLLECTION_COMPLETE);
                    break;
                }
                else {
                    logger$i.debug('(vsc)create-rff:collections failed', {
                        expectedCollectionIndexes,
                        receivedCollectionsACKs,
                    });
                    throw new Error('(vsc)create-rff: collections failed');
                }
            }
            else if (data.status === 16) {
                if (expectedCollectionIndexes.includes(data.idx)) {
                    receivedCollectionsACKs.push(data.idx);
                }
                msd(INTENT_COLLECTION(receivedCollectionsACKs.length), {
                    confirmed: receivedCollectionsACKs.length,
                    total: expectedCollectionIndexes.length,
                });
            }
            else {
                if (expectedCollectionIndexes.includes(data.idx)) {
                    throw new Error(`(vsc)create-rff: ${data.error}`);
                }
                else {
                    logger$i.debug('vscCreateRFF:ExpectedError:ignore', { data });
                }
            }
        }
    }
    finally {
        connection.close();
    }
};
const checkIntentFilled = async (intentID, grpcURL) => {
    const response = await getCosmosQueryClient(grpcURL).RequestForFunds({
        id: intentID,
    });
    if (response.requestForFunds?.fulfilled) {
        return 'ok';
    }
    throw new Error('not filled yet');
};

const logger$h = getLogger();
const getSourcesAndDestinationsForRFF = (intent, chainList, destinationUniverse) => {
    const sources = [];
    const universes = new Set();
    for (const source of intent.sources) {
        if (source.chainID == intent.destination.chainID) {
            continue;
        }
        const token = chainList.getTokenByAddress(source.chainID, source.tokenContract);
        if (!token) {
            logger$h.error('Token not found', { source });
            throw new Error('token not found');
        }
        universes.add(source.universe);
        sources.push({
            chainID: BigInt(source.chainID),
            tokenAddress: convertTo32BytesHex(source.tokenContract),
            universe: source.universe,
            value: mulDecimals(source.amount, token.decimals),
        });
    }
    universes.add(intent.destination.universe);
    const destinations = [
        {
            tokenAddress: convertTo32BytesHex(intent.destination.tokenContract),
            universe: intent.destination.universe,
            value: mulDecimals(intent.destination.amount, intent.destination.decimals),
        },
    ];
    if (intent.destination.gas != 0n) {
        if (isNativeAddress$1(intent.destination.universe, intent.destination.tokenContract)) {
            destinations[0].value = destinations[0].value + intent.destination.gas;
        }
        else {
            destinations.push({
                tokenAddress: convertTo32BytesHex(destinationUniverse === caCommon.Universe.FUEL ? FUEL_BASE_ASSET_ID : ZERO_ADDRESS),
                universe: intent.destination.universe,
                value: intent.destination.gas,
            });
        }
    }
    return { destinations, sources, universes };
};
const createRFFromIntent = async (intent, options, destinationUniverse) => {
    const { destinations, sources, universes } = getSourcesAndDestinationsForRFF(intent, options.chainList, destinationUniverse);
    const parties = [];
    for (const universe of universes) {
        if (universe === caCommon.Universe.ETHEREUM) {
            parties.push({
                address: convertTo32BytesHex(options.evm.address),
                universe: universe,
            });
        }
        if (universe === caCommon.Universe.FUEL) {
            parties.push({
                address: convertTo32BytesHex(options.fuel.address),
                universe,
            });
        }
    }
    logger$h.debug('processRFF:1', {
        destinations,
        parties,
        sources,
        universes,
    });
    const omniversalRFF = new caCommon.OmniversalRFF({
        destinationChainID: convertTo32Bytes$1(intent.destination.chainID),
        destinations: destinations.map((dest) => ({
            tokenAddress: viem.toBytes(dest.tokenAddress),
            value: viem.toBytes(dest.value),
        })),
        destinationUniverse: intent.destination.universe,
        expiry: Long__default.default.fromString((BigInt(Date.now() + INTENT_EXPIRY) / 1000n).toString()),
        nonce: window.crypto.getRandomValues(new Uint8Array(32)),
        // @ts-ignore
        signatureData: parties.map((p) => ({
            address: viem.toBytes(p.address),
            universe: p.universe,
        })),
        // @ts-ignore
        sources: sources.map((source) => ({
            chainID: convertTo32Bytes$1(source.chainID),
            tokenAddress: convertTo32Bytes$1(source.tokenAddress),
            universe: source.universe,
            value: viem.toBytes(source.value),
        })),
    });
    const signatureData = [];
    for (const universe of universes) {
        if (universe === caCommon.Universe.ETHEREUM) {
            const { requestHash, signature } = await createRequestEVMSignature(omniversalRFF.asEVMRFF(), options.evm.address, options.evm.client);
            signatureData.push({
                address: convertTo32Bytes$1(options.evm.address),
                requestHash,
                signature,
                universe: caCommon.Universe.ETHEREUM,
            });
        }
        if (universe === caCommon.Universe.FUEL) {
            if (!options.fuel?.address || !options.fuel?.provider || !options.fuel?.connector) {
                logger$h.error('universe has fuel but not expected input', {
                    fuelInput: options.fuel,
                });
                throw new Error('universe has fuel but not expected input');
            }
            const { requestHash, signature } = await createRequestFuelSignature(options.chainList.getVaultContractAddress(fuels.CHAIN_IDS.fuel.mainnet), options.fuel.provider, options.fuel.connector, omniversalRFF.asFuelRFF());
            signatureData.push({
                address: viem.toBytes(options.fuel.address),
                requestHash,
                signature,
                universe: caCommon.Universe.FUEL,
            });
        }
    }
    const msgBasicCosmos = caCommon.MsgCreateRequestForFunds.create({
        destinationChainID: omniversalRFF.protobufRFF.destinationChainID,
        destinations: omniversalRFF.protobufRFF.destinations,
        destinationUniverse: omniversalRFF.protobufRFF.destinationUniverse,
        expiry: omniversalRFF.protobufRFF.expiry,
        nonce: omniversalRFF.protobufRFF.nonce,
        signatureData: signatureData.map((s) => ({
            address: s.address,
            signature: s.signature,
            universe: s.universe,
        })),
        sources: omniversalRFF.protobufRFF.sources,
        user: options.cosmos.address,
    });
    logger$h.debug('processRFF:2', {
        msgBasicCosmos,
        omniversalRFF,
        signatureData,
    });
    return {
        msgBasicCosmos,
        omniversalRFF,
        signatureData,
        sources,
        universes,
    };
};

const KAIA_CHAIN_ID = 8217;
const SOPHON_CHAIN_ID = 50104;
const HYPEREVM_CHAIN_ID = 0x3e7;
const MONAD_TESTNET_CHAIN_ID = 10143;
const FUEL_NETWORK_URL = 'https://mainnet.fuel.network/v1/graphql';
const SymbolToLogo = {
    BNB: 'https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png',
    AVAX: 'https://assets.coingecko.com/coins/images/12559/standard/Avalanche_Circle_RedWhite_Trans.png',
    ETH: 'https://coin-images.coingecko.com/coins/images/279/large/ethereum.png',
    KAIA: 'https://assets.coingecko.com/coins/images/39901/large/KAIA.png',
    MATIC: 'https://coin-images.coingecko.com/coins/images/32440/standard/polygon.png',
    MON: 'https://assets.coingecko.com/coins/images/38927/large/monad.jpg',
    POL: 'https://coin-images.coingecko.com/coins/images/32440/standard/polygon.png',
    SOPH: 'https://assets.coingecko.com/coins/images/38680/large/sophon_logo_200.png',
    USDC: 'https://coin-images.coingecko.com/coins/images/6319/large/usdc.png',
    USDT: 'https://coin-images.coingecko.com/coins/images/35023/large/USDT.png',
    WETH: 'https://coin-images.coingecko.com/coins/images/2518/standard/weth.png',
    HYPE: 'https://assets.coingecko.com/coins/images/50882/large/hyperliquid.jpg',
};
const FUEL_BASE_ASSET_ID = '0xf8f8b6283d7fa5b672b530cbb84fcccb4ff8dc40f8176ef4544ddb1f1952ad07';
const getLogoFromSymbol = (symbol) => {
    const logo = SymbolToLogo[symbol];
    if (!logo) {
        return '';
    }
    return logo;
};
const isNativeAddress$1 = (universe, address) => {
    if (universe === caCommon.Universe.ETHEREUM) {
        return address === ZERO_ADDRESS || address === ZERO_ADDRESS_FUEL;
    }
    if (universe === caCommon.Universe.FUEL) {
        return address === FUEL_BASE_ASSET_ID;
    }
    // Handle other universes or return false by default
    return false;
};
const INTENT_EXPIRY = 15 * 60 * 1000;
const AaveTokenContracts = {
    1: {
        USDC: '0x98C23E9d8f34FEFb1B7BD6a91B7FF122F4e16F5c',
        USDT: '0x23878914EFE38d27C4D67Ab83ed1b93A74D4086a',
        WETH: '0x4d5F47FA6A74757f35C14fD3a6Ef8E3C9BC514E8',
    },
    10: {
        USDC: '0x38d693cE1dF5AaDF7bC62595A37D667aD57922e5',
        USDT: '0x6ab707Aca953eDAeFBc4fD23bA73294241490620',
        WETH: '0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8',
    },
    11155420: {
        USDC: '0xa818F1B57c201E092C4A2017A91815034326Efd1',
    },
    137: {
        USDC: '0xA4D94019934D8333Ef880ABFFbF2FDd611C762BD',
        USDT: '0x6ab707Aca953eDAeFBc4fD23bA73294241490620',
        WETH: '0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8',
    },
    42161: {
        USDC: '0x724dc807b04555b71ed48a6896b6F41593b8C637',
        USDT: '0x6ab707Aca953eDAeFBc4fD23bA73294241490620',
        WETH: '0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8',
    },
    // Testnet chains
    421614: {
        USDC: '0x460b97BD498E1157530AEb3086301d5225b91216',
    },
    43114: {
        USDC: '0x625E7708f30cA75bfd92586e17077590C60eb4cD',
        USDT: '0x6ab707Aca953eDAeFBc4fD23bA73294241490620',
        WETH: '0xe50fA9b3c56FfB159cB0FCA61F5c9D750e8128c8',
    },
    534352: {
        USDC: '0x1D738a3436A8C49CefFbaB7fbF04B660fb528CbD',
        WETH: '0xf301805bE1Df81102C957f6d4Ce29d2B8c056B2a',
    },
    56: {
        USDC: '0x00901a076785e0906d1028c7d6372d247bec7d61',
        USDT: '0xa9251ca9DE909CB71783723713B21E4233fbf1B1',
    },
    59144: {
        USDC: '0x374D7860c4f2f604De0191298dD393703Cce84f3',
        USDT: '0x88231dfEC71D4FF5c1e466D08C321944A7adC673',
        WETH: '0x787897dF92703BB3Fc4d9Ee98e15C0b8130Bf163',
    },
    8453: {
        USDC: '0x4e65fE4DbA92790696d040ac24Aa414708F5c0AB',
        WETH: '0x7C307e128efA31F540F2E2d976C995E0B65F51F6',
    },
    84532: {
        USDC: '0x10F1A9D11CDf50041f3f8cB7191CBE2f31750ACC',
        USDT: '0xcE3CAae5Ed17A7AafCEEbc897DE843fA6CC0c018',
    },
};
const TOKEN_MINTER_CONTRACTS = {
    534352: {
        USDT: '0xe2b4795039517653c5ae8c2a9bfdd783b48f447a',
    },
    59144: {
        USDC: '0xA2Ee6Fce4ACB62D95448729cDb781e3BEb62504A',
        USDT: '0x353012dc4a9A6cF55c941bADC267f82004A8ceB9',
    },
    8453: {
        USDT: '0x4200000000000000000000000000000000000010',
    },
};
const TOP_OWNER = {
    [SOPHON_CHAIN_ID]: {
        ETH: '0x353B35a3362Dff8174cd9679BC4a46365CcD4dA7',
        USDC: '0x61a87fa6Dd89a23c78F0754EF3372d35ccde5935',
        USDT: '0x61a87fa6Dd89a23c78F0754EF3372d35ccde5935',
    },
};
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const ZERO_ADDRESS_FUEL = convertTo32BytesHex(ZERO_ADDRESS);

class ChainList {
    constructor(env) {
        switch (env) {
            case caCommon.Environment.CERISE:
            case caCommon.Environment.CORAL:
                this.chains = MAINNET_CHAINS;
                break;
            case caCommon.Environment.FOLLY:
                this.chains = TESTNET_CHAINS;
                break;
            case caCommon.Environment.JADE:
                throw new Error('Jade environment not supported yet');
            default:
                throw new Error('Unknown environment');
        }
        this.vcm = caCommon.getVaultContractMap(env);
    }
    getChainByID(id) {
        return this.chains.find((c) => c.id === id);
    }
    getNativeToken(chainID) {
        const chain = this.getChainByID(chainID);
        if (!chain) {
            throw new Error('chain not found');
        }
        return {
            contractAddress: ZERO_ADDRESS,
            decimals: chain.nativeCurrency.decimals,
            logo: chain.custom.icon,
            name: chain.nativeCurrency.name,
            symbol: chain.nativeCurrency.symbol,
        };
    }
    getTokenByAddress(chainID, address) {
        const chain = this.getChainByID(chainID);
        if (!chain) {
            return undefined;
        }
        const token = chain.custom.knownTokens.find((t) => equalFold(t.contractAddress, address));
        if (!token) {
            if (equalFold(address, ZERO_ADDRESS)) {
                return this.getNativeToken(chainID);
            }
        }
        return token;
    }
    getTokenInfoBySymbol(chainID, symbol) {
        const chain = this.getChainByID(chainID);
        if (!chain) {
            return undefined;
        }
        const token = chain.custom.knownTokens.find((t) => equalFold(t.symbol, symbol));
        if (!token) {
            if (equalFold(chain.nativeCurrency.symbol, symbol)) {
                return {
                    contractAddress: ZERO_ADDRESS,
                    decimals: chain.nativeCurrency.decimals,
                    logo: chain.custom.icon,
                    name: chain.nativeCurrency.name,
                    symbol: chain.nativeCurrency.symbol,
                };
            }
        }
        return token;
    }
    getVaultContractAddress(chainID) {
        const chain = this.getChainByID(chainID);
        if (!chain) {
            throw new Error('chain not supported');
        }
        const omniversalChainID = new caCommon.OmniversalChainID(chain.universe, chainID);
        const vc = this.vcm.get(omniversalChainID);
        if (!vc) {
            throw new Error('vault contract not found');
        }
        return convertToHexAddressByUniverse(vc, chain.universe);
    }
    getAnkrNameList() {
        return this.chains.map((c) => c.ankrName).filter((n) => n !== '');
    }
}
const TESTNET_CHAINS = [
    {
        blockExplorers: {
            default: {
                name: 'Arbitrum Sepolia Explorer',
                url: 'https://sepolia.arbiscan.io/',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/coins/images/16547/large/arb.jpg?1721358242',
            knownTokens: [
                {
                    contractAddress: '0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
                {
                    contractAddress: '0xF954d4A5859b37De88a91bdbb8Ad309056FB04B1',
                    decimals: 18,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Testing USD',
                    symbol: 'USDT',
                },
            ],
        },
        id: 421614,
        name: 'Arbitrum Sepolia',
        ankrName: '',
        nativeCurrency: {
            decimals: 18,
            name: 'Ether',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: ['https://arb-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],
                publicHttp: [
                    'https://public.stackup.sh/api/v1/node/arbitrum-sepolia',
                    'https://endpoints.omniatech.io/v1/arbitrum/sepolia/public',
                    'https://arbitrum-sepolia.gateway.tenderly.co',
                    'https://api.zan.top/arb-sepolia',
                ],
                webSocket: ['wss://arb-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'OP Sepolia Explorer',
                url: 'https://sepolia-optimism.etherscan.io/',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/coins/images/25244/large/Optimism.png?1696524385',
            knownTokens: [
                {
                    contractAddress: '0x5fd84259d66Cd46123540766Be93DFE6D43130D7',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
                {
                    contractAddress: '0x6462693c2F21AC0E517f12641D404895030F7426',
                    decimals: 18,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Testing USD',
                    symbol: 'USDT',
                },
            ],
        },
        id: 11155420,
        name: 'OP Sepolia',
        ankrName: '',
        nativeCurrency: {
            decimals: 18,
            name: 'Ether',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: ['https://opt-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],
                publicHttp: [
                    'https://api.zan.top/opt-sepolia',
                    'https://endpoints.omniatech.io/v1/op/sepolia/public',
                    'https://optimism-sepolia.gateway.tenderly.co',
                    'https://optimism-sepolia.api.onfinality.io/public',
                ],
                webSocket: ['wss://opt-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Amoy Polygon Explorer',
                url: 'https://amoy.polygonscan.com/',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/15/large/polygon_pos.png?1706606645',
            knownTokens: [
                {
                    contractAddress: '0x41E94Eb019C0762f9Bfcf9Fb1E58725BfB0e7582',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: 80002,
        name: 'Amoy',
        ankrName: '',
        nativeCurrency: {
            decimals: 18,
            name: 'POL',
            symbol: 'POL',
        },
        rpcUrls: {
            default: {
                http: ['https://polygon-amoy.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],
                publicHttp: [
                    'https://polygon-amoy-bor-rpc.publicnode.com',
                    'https://rpc-amoy.polygon.technology',
                    'https://polygon-amoy.gateway.tenderly.co',
                    'https://polygon-amoy.drpc.org',
                ],
                webSocket: ['wss://polygon-amoy.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Basescan',
                url: 'https://sepolia.basescan.org/',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/131/large/base-network.png?1720533039',
            knownTokens: [
                {
                    contractAddress: '0x036CbD53842c5426634e7929541eC2318f3dCF7e',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: 84532,
        name: 'Base Sepolia',
        ankrName: '',
        nativeCurrency: {
            decimals: 18,
            name: 'Ether',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: ['https://base-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],
                publicHttp: [
                    'https://rpc.notadegen.com/base/sepolia',
                    'https://public.stackup.sh/api/v1/node/base-sepolia',
                    'https://base-sepolia.gateway.tenderly.co',
                    'https://base-sepolia.drpc.org',
                ],
                webSocket: ['wss://base-sepolia.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq'],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Monad Testnet Explorer',
                url: 'https://testnet.monadexplorer.com',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/coins/images/38927/standard/monad.jpg',
            knownTokens: [
                {
                    contractAddress: '0xf817257fed379853cDe0fa4F97AB987181B1E5Ea',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
                {
                    contractAddress: '0x1c56F176D6735888fbB6f8bD9ADAd8Ad7a023a0b',
                    decimals: 18,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Testing USDT',
                    symbol: 'USDT',
                },
            ],
        },
        id: MONAD_TESTNET_CHAIN_ID,
        name: 'Monad Testnet',
        ankrName: '',
        nativeCurrency: {
            decimals: 18,
            name: 'Monad',
            symbol: 'MON',
        },
        rpcUrls: {
            default: {
                http: ['https://lb.drpc.org/monad-testnet/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE'],
                publicHttp: ['https://monad-testnet.drpc.org', 'https://rpc.ankr.com/monad_testnet'],
                webSocket: ['wss://lb.drpc.org/monad-testnet/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE'],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Etherscan Sepolia',
                url: 'https://sepolia.etherscan.io/',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/279/large/ethereum.png?1706606803',
            knownTokens: [
                {
                    contractAddress: '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: 11155111,
        name: 'Ethereum Sepolia',
        ankrName: '',
        nativeCurrency: {
            decimals: 18,
            name: 'Ether',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: ['https://sepolia.drpc.org'],
                publicHttp: [
                    'https://api.zan.top/eth-sepolia',
                    'https://ethereum-sepolia-public.nodies.app',
                ],
                webSocket: ['wss://sepolia.drpc.org'],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
];
const MAINNET_CHAINS = [
    {
        blockExplorers: {
            default: {
                name: 'Fuel Network Explorer',
                url: 'https://app.fuel.network/',
            },
        },
        custom: {
            icon: 'https://avatars.githubusercontent.com/u/55993183',
            knownTokens: [
                {
                    contractAddress: FUEL_BASE_ASSET_ID,
                    decimals: 9,
                    logo: getLogoFromSymbol('ETH'),
                    name: 'Ether',
                    symbol: 'ETH',
                },
                {
                    contractAddress: '0x286c479da40dc953bddc3bb4c453b608bba2e0ac483b077bd475174115395e6b',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
                {
                    contractAddress: '0xa0265fb5c32f6e8db3197af3c7eb05c48ae373605b8165b6f4a51c5b0ba4812e',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
            ],
        },
        id: fuels.CHAIN_IDS.fuel.mainnet,
        name: 'Fuel Network',
        ankrName: '',
        nativeCurrency: {
            decimals: 9,
            name: 'Ether',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: [FUEL_NETWORK_URL],
                webSocket: [],
            },
        },
        universe: caCommon.Universe.FUEL,
    },
    {
        blockExplorers: {
            default: {
                name: 'Sophscan',
                url: 'https://sophscan.xyz',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/coins/images/38680/large/sophon_logo_200.png',
            knownTokens: [
                {
                    contractAddress: '0x6386da73545ae4e2b2e0393688fa8b65bb9a7169',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
                {
                    contractAddress: '0x9aa0f72392b5784ad86c6f3e899bcc053d00db4f',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
                {
                    contractAddress: '0x72af9f169b619d85a47dfa8fefbcd39de55c567d',
                    decimals: 18,
                    logo: getLogoFromSymbol('ETH'),
                    name: 'Ether',
                    symbol: 'ETH',
                },
            ],
        },
        id: SOPHON_CHAIN_ID,
        name: 'Sophon',
        ankrName: '',
        nativeCurrency: {
            decimals: 18,
            name: 'Sophon',
            symbol: 'SOPH',
        },
        rpcUrls: {
            default: {
                http: ['https://sophon.gateway.tenderly.co/1d4STFT7zmG0vM5QowibCw'],
                publicHttp: ['https://rpc-quicknode.sophon.xyz'],
                webSocket: ['wss://sophon.gateway.tenderly.co/1d4STFT7zmG0vM5QowibCw'],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'KaiaScan',
                url: 'https://kaiascan.io',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/9672/large/kaia.png',
            knownTokens: [
                {
                    contractAddress: '0xd077a400968890eacc75cdc901f0356c943e4fdb',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
            ],
        },
        id: KAIA_CHAIN_ID,
        name: 'Kaia Mainnet',
        ankrName: '',
        nativeCurrency: {
            decimals: 18,
            name: 'Kaia',
            symbol: 'KAIA',
        },
        rpcUrls: {
            default: {
                http: [
                    'https://lb.drpc.org/klaytn/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'https://go.getblock.io/d7094dbd80ab474ba7042603fe912332',
                ],
                publicHttp: ['https://go.getblock.io/d7094dbd80ab474ba7042603fe912332'],
                webSocket: [
                    'wss://lb.drpc.org/klaytn/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'wss://go.getblock.io/92d6e31d6a47427d9337753b3d48b93e',
                ],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Etherscan',
                url: 'https://etherscan.io',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/279/large/ethereum.png?1706606803',
            knownTokens: [
                {
                    contractAddress: '0xdac17f958d2ee523a2206206994597c13d831ec7',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
                {
                    contractAddress: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: 1,
        name: 'Ethereum Mainnet',
        ankrName: 'eth',
        nativeCurrency: {
            decimals: 18,
            name: 'Ether',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: [
                    'https://lb.drpc.org/ethereum/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'https://ethereum.blockpi.network/v1/rpc/743f126e1720d79033ba70a92c9ea3724380d6bd',
                ],
                publicHttp: [
                    'https://cloudflare-eth.com',
                    'https://1rpc.io/eth',
                    'https://ethereum-rpc.publicnode.com',
                    'https://rpc.ankr.com/eth',
                    'https://ethereum.blockpi.network/v1/rpc/public',
                    'https://rpc.mevblocker.io',
                    'https://rpc.mevblocker.io/fast',
                ],
                webSocket: [
                    'wss://lb.drpc.org/ethereum/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'wss://eth.llamarpc.com',
                ],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Optimism Etherscan',
                url: 'https://optimistic.etherscan.io',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/coins/images/25244/large/Optimism.png?1696524385',
            knownTokens: [
                {
                    contractAddress: '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
                {
                    contractAddress: '0x0b2c639c533813f4aa9d7837caf62653d097ff85',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: 10,
        name: 'OP Mainnet',
        ankrName: 'optimism',
        nativeCurrency: {
            decimals: 18,
            name: 'Ether',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: [
                    'https://lb.drpc.org/optimism/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'https://opt-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
                publicHttp: [
                    'https://mainnet.optimism.io',
                    'https://1rpc.io/op',
                    'https://optimism-rpc.publicnode.com',
                    'https://rpc.ankr.com/optimism',
                    'https://optimism.blockpi.network/v1/rpc/public',
                    'https://optimism.llamarpc.com',
                ],
                webSocket: [
                    'wss://lb.drpc.org/optimism/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'wss://opt-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Polygonscan',
                url: 'https://polygonscan.com',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/15/large/polygon_pos.png?1706606645',
            knownTokens: [
                {
                    contractAddress: '0xc2132d05d31c914a87c6611c10748aeb04b58e8f',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
                {
                    contractAddress: '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: 137,
        name: 'Polygon PoS',
        ankrName: 'polygon',
        nativeCurrency: {
            decimals: 18,
            name: 'POL',
            symbol: 'POL',
        },
        rpcUrls: {
            default: {
                http: [
                    'https://lb.drpc.org/polygon/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'https://polygon-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                    'https://polygon.blockpi.network/v1/rpc/07fef5146d885cc0fe07ae6760d486b31e45dcc7',
                ],
                publicHttp: [
                    'https://polygon-rpc.com',
                    'https://1rpc.io/matic',
                    'https://polygon-bor-rpc.publicnode.com',
                    'https://rpc.ankr.com/polygon',
                    'https://polygon.blockpi.network/v1/rpc/public',
                    'https://polygon.llamarpc.com',
                ],
                webSocket: [
                    'wss://lb.drpc.org/polygon/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'wss://polygon-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Basescan',
                url: 'https://basescan.org',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/131/large/base-network.png?1720533039',
            knownTokens: [
                {
                    contractAddress: '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: 8453,
        name: 'Base',
        ankrName: 'base',
        nativeCurrency: {
            decimals: 18,
            name: 'Ether',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: [
                    'https://lb.drpc.org/base/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'https://base-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                    'https://base.blockpi.network/v1/rpc/dec2a84b57c7779c8b092a7ca9817e6855aa08c6',
                ],
                publicHttp: [
                    'https://mainnet.base.org',
                    'https://1rpc.io/base',
                    'https://base-rpc.publicnode.com',
                    'https://rpc.ankr.com/base',
                    'https://base.blockpi.network/v1/rpc/public',
                    'https://base.llamarpc.com',
                ],
                webSocket: [
                    'wss://lb.drpc.org/base/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'wss://base-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Arbiscan',
                url: 'https://arbiscan.io',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/coins/images/16547/large/arb.jpg?1721358242',
            knownTokens: [
                {
                    contractAddress: '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
                {
                    contractAddress: '0xaf88d065e77c8cc2239327c5edb3a432268e5831',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: 42161,
        name: 'Arbitrum One',
        ankrName: 'arbitrum',
        nativeCurrency: {
            decimals: 18,
            name: 'ETH',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: [
                    'https://lb.drpc.org/arbitrum/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'https://arb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                    'https://arbitrum.blockpi.network/v1/rpc/a8ccd43cdc840c2b2d20c24a058514a21302376d',
                ],
                publicHttp: [
                    'https://arb1.arbitrum.io/rpc',
                    'https://1rpc.io/arb',
                    'https://arbitrum-one-rpc.publicnode.com',
                    'https://rpc.ankr.com/arbitrum',
                    'https://arbitrum.blockpi.network/v1/rpc/public',
                ],
                webSocket: [
                    'wss://lb.drpc.org/arbitrum/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'wss://arb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Scrollscan',
                url: 'https://scrollscan.com',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/153/large/scroll.jpeg?1706606782',
            knownTokens: [
                {
                    contractAddress: '0xf55bec9cafdbe8730f096aa55dad6d22d44099df',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
                {
                    contractAddress: '0x06efdbff2a14a7c8e15944d1f4a48f9f95f663a4',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: 534352,
        name: 'Scroll',
        ankrName: 'scroll',
        nativeCurrency: {
            decimals: 18,
            name: 'Ether',
            symbol: 'ETH',
        },
        rpcUrls: {
            default: {
                http: [
                    'https://lb.drpc.org/scroll/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'https://scroll-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
                publicHttp: [
                    'https://rpc.scroll.io',
                    'https://1rpc.io/scroll',
                    'https://rpc.ankr.com/scroll',
                    'https://scroll-mainnet.public.blastapi.io',
                    // "https://scroll.blockpi.network/v1/rpc/public",
                    'https://scroll-rpc.publicnode.com',
                ],
                webSocket: [
                    'wss://lb.drpc.org/scroll/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'wss://scroll-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Snowscan',
                url: 'https://snowscan.xyz',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/12/large/avalanche.png',
            knownTokens: [
                {
                    contractAddress: '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
                {
                    contractAddress: '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
            ],
        },
        id: 43114,
        ankrName: 'avalanche',
        name: 'Avalanche C-Chain',
        nativeCurrency: {
            decimals: 18,
            name: 'AVAX',
            symbol: 'AVAX',
        },
        rpcUrls: {
            default: {
                http: [
                    'https://lb.drpc.org/avalanche/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'https://avax-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
                publicHttp: [
                    'https://1rpc.io/avax/c',
                    'https://avalanche-c-chain-rpc.publicnode.com',
                    'https://ava-mainnet.public.blastapi.io/ext/bc/C/rpc',
                    'https://rpc.ankr.com/avalanche',
                    'https://avalanche-mainnet.gateway.tenderly.co',
                ],
                webSocket: [
                    'wss://lb.drpc.org/avalanche/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'wss://avax-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'BscScan',
                url: 'https://bscscan.com',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/1/large/bnb_smart_chain.png',
            knownTokens: [
                {
                    contractAddress: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d',
                    decimals: 18,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
                {
                    contractAddress: '0x55d398326f99059fF775485246999027B3197955',
                    decimals: 18,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
                {
                    contractAddress: '0x2170Ed0880ac9A755fd29B2688956BD959F933F8',
                    decimals: 18,
                    logo: getLogoFromSymbol('ETH'),
                    name: 'Ether',
                    symbol: 'ETH',
                },
            ],
        },
        id: 0x38,
        name: 'BNB Smart Chain',
        ankrName: 'bsc',
        nativeCurrency: {
            decimals: 18,
            name: 'BNB',
            symbol: 'BNB',
        },
        rpcUrls: {
            default: {
                http: [
                    'https://lb.drpc.org/bsc/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'https://bnb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
                publicHttp: [
                    'https://1rpc.io/bnb',
                    'https://bsc-rpc.publicnode.com',
                    'https://bsc-mainnet.public.blastapi.io',
                    'https://bsc.drpc.org',
                    'https://bsc.blockrazor.xyz',
                ],
                webSocket: [
                    'wss://lb.drpc.org/bsc/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                    'wss://bnb-mainnet.g.alchemy.com/v2/PfaswrKq0rjOrfYWHfE9uLQKhiD4JCdq',
                ],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
    {
        blockExplorers: {
            default: {
                name: 'Hyperscan',
                url: 'https://hyperscan.com',
            },
        },
        custom: {
            icon: 'https://assets.coingecko.com/asset_platforms/images/243/large/hyperliquid.png',
            knownTokens: [
                {
                    contractAddress: '0xB8CE59FC3717ada4C02eaDF9682A9e934F625ebb',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDT'),
                    name: 'Tether USD',
                    symbol: 'USDT',
                },
                {
                    contractAddress: '0xb88339CB7199b77E23DB6E890353E22632Ba630f',
                    decimals: 6,
                    logo: getLogoFromSymbol('USDC'),
                    name: 'USD Coin',
                    symbol: 'USDC',
                },
            ],
        },
        id: HYPEREVM_CHAIN_ID,
        ankrName: '',
        name: 'HyperEVM',
        nativeCurrency: {
            decimals: 18,
            name: 'HYPE',
            symbol: 'HYPE',
        },
        rpcUrls: {
            default: {
                http: [
                    // Not supported by Alchemy
                    'https://hyperliquid.drpc.org',
                    'https://lb.drpc.org/hyperliquid/Am5nENoJmEuovqui8_LMxzp4ChJzW7kR8JfPrqRhf0fE',
                ],
                publicHttp: [
                    'https://hyperliquid-json-rpc.stakely.io',
                    'https://rpc.hyperlend.finance',
                    'https://rpc.hypurrscan.io',
                ],
                webSocket: ['wss://hyperliquid.drpc.org'],
            },
        },
        universe: caCommon.Universe.ETHEREUM,
    },
];

// Testnet with mainnet tokens
const CORAL_CONFIG = {
    COSMOS_URL: 'https://cosmos01-testnet.arcana.network',
    EXPLORER_URL: 'https://explorer.nexus.availproject.org',
    FAUCET_URL: 'https://gateway001-testnet.arcana.network/api/v1/faucet',
    GRPC_URL: 'https://grpcproxy-testnet.arcana.network',
    NETWORK_HINT: caCommon.Environment.CORAL,
    SIMULATION_URL: 'https://ca-sim-testnet.arcana.network',
    VSC_DOMAIN: 'vsc1-testnet.arcana.network',
};
// Dev with mainnet tokens
const CERISE_CONFIG = {
    COSMOS_URL: 'https://cosmos01-dev.arcana.network',
    EXPLORER_URL: 'https://explorer.nexus-cerise.availproject.org',
    FAUCET_URL: 'https://gateway-dev.arcana.network/api/v1/faucet',
    GRPC_URL: 'https://mimosa-dash-grpc.arcana.network',
    NETWORK_HINT: caCommon.Environment.CERISE,
    SIMULATION_URL: 'https://ca-sim-dev.arcana.network',
    VSC_DOMAIN: 'mimosa-dash-vsc.arcana.network',
};
// Dev with testnet tokens
const FOLLY_CONFIG = {
    COSMOS_URL: 'https://cosmos04-dev.arcana.network',
    EXPLORER_URL: 'https://explorer.nexus-folly.availproject.org',
    FAUCET_URL: 'https://gateway-dev.arcana.network/api/v1/faucet',
    GRPC_URL: 'https://grpc-folly.arcana.network',
    NETWORK_HINT: caCommon.Environment.FOLLY,
    SIMULATION_URL: 'https://ca-sim-dev.arcana.network',
    VSC_DOMAIN: 'vsc1-folly.arcana.network',
};
const isNetworkConfig = (config) => {
    if (typeof config !== 'object') {
        return false;
    }
    if (!(config.VSC_DOMAIN &&
        config.COSMOS_URL &&
        config.SIMULATION_URL &&
        config.FAUCET_URL &&
        config.EXPLORER_URL &&
        config.GRPC_URL)) {
        return false;
    }
    if (config.NETWORK_HINT === undefined) {
        return false;
    }
    return true;
};
const getNetworkConfig = (network) => {
    if (isNetworkConfig(network)) {
        return network;
    }
    switch (network) {
        case caCommon.Environment.CERISE:
            return CERISE_CONFIG;
        case caCommon.Environment.FOLLY:
            return FOLLY_CONFIG;
        default:
            return CORAL_CONFIG;
    }
};

class AllowanceQuery {
    constructor(walletClient, networkConfig, chainList) {
        this.walletClient = walletClient;
        this.networkConfig = networkConfig;
        this.chainList = chainList;
    }
    async get(input) {
        const addresses = await this.walletClient.getAddresses();
        if (!addresses.length) {
            throw new Error('No account connected with wallet client');
        }
        const address = addresses[0];
        const tokens = input.tokens ?? ['USDT', 'USDC'];
        const chainID = input.chainID ? [input.chainID] : this.chainList.chains.map((c) => c.id);
        const inp = [];
        const out = [];
        for (const c of chainID) {
            for (const t of tokens) {
                const token = this.chainList.getTokenInfoBySymbol(c, t);
                if (token) {
                    const chain = this.chainList.getChainByID(c);
                    if (!chain) {
                        throw new Error('chain not supported');
                    }
                    inp.push(getAllowance(chain, address, token.contractAddress, this.chainList).then((val) => {
                        out.push({
                            allowance: val,
                            chainID: c,
                            token: t,
                        });
                    }));
                }
            }
        }
        return Promise.all(inp).then(() => out);
    }
    async revoke(input) {
        await this.set({ ...input, amount: 0n });
    }
    async set(input) {
        if (input.tokens == null) {
            throw new Error('missing token param');
        }
        if (input.amount == null) {
            throw new Error('missing amount param');
        }
        if (input.chainID == null) {
            throw new Error('missing chainID param');
        }
        const chain = this.chainList.getChainByID(input.chainID);
        if (!chain) {
            throw new Error('chain not supported');
        }
        let chainID = await this.walletClient.getChainId();
        if (input.chainID && input.chainID !== chainID) {
            await switchChain(this.walletClient, chain);
            chainID = input.chainID;
        }
        const tokenAddresses = [];
        for (const t of input.tokens) {
            const token = chain.custom.knownTokens.find((kt) => equalFold(kt.symbol, t));
            if (token) {
                tokenAddresses.push(token.contractAddress);
            }
        }
        if (!tokenAddresses.length) {
            throw new Error('None of the supplied token symbols are recognised on this chain');
        }
        await setAllowances(tokenAddresses, this.walletClient, this.networkConfig, this.chainList, chain, input.amount);
    }
}

class BridgeQuery {
    constructor(input, init, switchChain, createEVMHandler, createFuelHandler, address, chainList, fuelAccount) {
        this.input = input;
        this.init = init;
        this.switchChain = switchChain;
        this.createEVMHandler = createEVMHandler;
        this.createFuelHandler = createFuelHandler;
        this.address = address;
        this.chainList = chainList;
        this.fuelAccount = fuelAccount;
        this.handler = null;
        this.exec = () => {
            if (!this.handler) {
                throw new Error('ca not applicable');
            }
            return this.handler.process();
        };
        this.simulate = async () => {
            if (!this.handler) {
                throw new Error('ca not applicable');
            }
            const response = await this.handler.buildIntent(this.input.sourceChains ?? []);
            if (!response) {
                throw new Error('ca not applicable');
            }
            return {
                intent: convertIntent(response.intent, response.token, this.chainList),
                token: response.token,
            };
        };
    }
    async initHandler() {
        if (!this.handler) {
            const input = this.input;
            await this.init();
            if (input.token && input.amount && input.chainId) {
                const token = this.chainList.getTokenInfoBySymbol(input.chainId, input.token);
                if (!token) {
                    throw new Error('Token not supported on this chain.');
                }
                const bridgeAmount = mulDecimals(input.amount, token.decimals);
                if (input.chainId === fuels.CHAIN_IDS.fuel.mainnet) {
                    if (this.fuelAccount) {
                        const tx = await this.fuelAccount.createTransfer(
                        // Random address, since bridge won't call the final tx
                        '0xE78655DfAd552fc3658c01bfb427b9EAb0c628F54e60b54fDA16c95aaAdE797A', fuels.bn(bridgeAmount.toString()), token.contractAddress);
                        const handlerResponse = await this.createFuelHandler(tx, {
                            bridge: true,
                            gas: input.gas ?? 0n,
                            skipTx: true,
                        });
                        this.handler = handlerResponse?.handler;
                    }
                    else {
                        throw new Error('Fuel connector is not set');
                    }
                }
                else {
                    await this.switchChain(input.chainId);
                    const p = {
                        from: this.address,
                        to: this.address,
                    };
                    const isNative = equalFold(token.contractAddress, ZERO_ADDRESS);
                    if (isNative) {
                        p.value = viem.toHex(bridgeAmount);
                        input.gas = 0n;
                    }
                    else {
                        p.to = token.contractAddress;
                        p.data = viem.encodeFunctionData({
                            abi: ABI,
                            args: [this.address, BigInt(bridgeAmount.toString())],
                            functionName: 'transfer',
                        });
                    }
                    const handlerResponse = await this.createEVMHandler(p, {
                        bridge: true,
                        gas: input.gas ?? 0n,
                        skipTx: true,
                        sourceChains: input.sourceChains,
                    });
                    this.handler = handlerResponse?.handler;
                }
                return;
            }
            throw new Error('bridge: missing params');
        }
    }
}

const logger$g = getLogger();
class TransferQuery {
    constructor(input, init, switchChain, createEVMHandler, createFuelHandler, evmAddress, chainList, fuelAccount) {
        this.input = input;
        this.init = init;
        this.switchChain = switchChain;
        this.createEVMHandler = createEVMHandler;
        this.createFuelHandler = createFuelHandler;
        this.evmAddress = evmAddress;
        this.chainList = chainList;
        this.fuelAccount = fuelAccount;
        this.handlerResponse = null;
        this.exec = async () => {
            if (!this.handlerResponse?.handler) {
                throw new Error('ca not applicable');
            }
            let explorerURL = '';
            const result = await this.handlerResponse.handler.process();
            if (result) {
                explorerURL = result.explorerURL;
            }
            logger$g.debug('TransferQuery:Exec', {
                state: 'processing completed, going to processTx()',
            });
            const hash = (await this.handlerResponse.processTx());
            return {
                hash,
                explorerURL,
            };
        };
        this.simulate = async () => {
            if (!this.handlerResponse?.handler) {
                throw new Error('ca not applicable');
            }
            const response = await this.handlerResponse.handler.buildIntent(this.input.sourceChains ?? []);
            if (!response) {
                throw new Error('ca not applicable');
            }
            return {
                intent: convertIntent(response.intent, response.token, this.chainList),
                token: response.token,
            };
        };
    }
    async initHandler() {
        if (!this.handlerResponse) {
            const input = this.input;
            await this.init();
            logger$g.debug('SendQueryBuilder.exec', {
                c: input.chainId,
                p: input,
            });
            if (input.to && input.amount !== undefined && input.token && input.chainId) {
                const tokenInfo = this.chainList.getTokenInfoBySymbol(input.chainId, input.token);
                if (!tokenInfo) {
                    throw new Error('Token not supported on this chain.');
                }
                const amount = mulDecimals(input.amount, tokenInfo.decimals);
                logger$g.debug('transfer:2', { amount, tokenInfo });
                if (input.chainId === fuels.CHAIN_IDS.fuel.mainnet) {
                    if (this.fuelAccount) {
                        const tx = await this.fuelAccount.createTransfer(input.to, fuels.bn(amount.toString()), tokenInfo.contractAddress);
                        this.handlerResponse = await this.createFuelHandler(tx, {
                            bridge: false,
                            gas: 0n,
                            skipTx: false,
                        });
                    }
                    else {
                        throw new Error('Fuel connector is not set');
                    }
                }
                else {
                    await this.switchChain(input.chainId);
                    const isNative = equalFold(tokenInfo.contractAddress, ZERO_ADDRESS);
                    const p = {
                        from: this.evmAddress,
                        to: input.to,
                    };
                    if (isNative) {
                        p.value = `0x${amount.toString(16)}`;
                    }
                    else {
                        p.to = tokenInfo.contractAddress;
                        p.data = viem.encodeFunctionData({
                            abi: ABI,
                            args: [input.to, amount],
                            functionName: 'transfer',
                        });
                    }
                    this.handlerResponse = await this.createEVMHandler(p, {
                        bridge: false,
                        gas: 0n,
                        skipTx: false,
                        sourceChains: input.sourceChains,
                    });
                }
                return;
            }
            throw new Error('transfer: missing params');
        }
    }
}

const logger$f = getLogger();
const simulate = async (tx, address, provider, chainList) => {
    const outputs = tx.outputs?.filter((o) => o.type === fuels.OutputType.Coin) ?? [];
    const tokens = outputs
        .map((o) => {
        const token = chainList.getTokenByAddress(fuels.CHAIN_IDS.fuel.mainnet, o.assetId);
        if (!token)
            return null;
        return {
            from: fuels.hexlify(address).toLowerCase(),
            to: fuels.hexlify(o.to).toLowerCase(),
            token: {
                address: fuels.hexlify(o.assetId),
                amount: divDecimals(o.amount.toString(), token.decimals),
                decimals: token.decimals,
                logo: token.logo,
                name: token.name,
                symbol: token.symbol,
            },
        };
    })
        .filter((o) => !!o)
        .reduce((acc, o) => {
        const existingCoin = acc.find((a) => o.from === a.from && o.token.address === a.token.contractAddress);
        if (existingCoin) {
            existingCoin.token.amount = new Decimal__default.default(existingCoin.token.amount).plus(o.token.amount);
            return acc;
        }
        acc.push({
            from: o.from,
            to: o.to,
            token: {
                amount: new Decimal__default.default(o.token.amount),
                contractAddress: o.token.address,
                decimals: o.token.decimals,
                logo: o.token.logo,
                name: o.token.name,
                symbol: o.token.symbol,
            },
        });
        return acc;
    }, [])
        .sort((a, b) => (new Decimal__default.default(a.token.amount).lessThan(b.token.amount) ? 1 : -1));
    const { assembledRequest } = await provider.assembleTx({
        feePayerAccount: new fuels.Account(address),
        request: tx,
    });
    logger$f.debug('Fuel Simulate: mappedOutputsToInputs', {
        assembledRequest,
    });
    const coin = tokens?.length ? tokens[0] : null;
    if (!coin) {
        return;
    }
    logger$f.debug('FuelSimulate', {
        amount: coin.token.amount.toFixed(),
        coin: coin,
    });
    const { amount, ...token } = coin.token;
    return {
        amount: amount,
        gas: BigInt(0),
        gasFee: divDecimals(BigInt(assembledRequest.maxFee.toString()) * 2n, 9),
        token: { ...token, type: 'src20' },
    };
};
const fixTx = async (address, tx, provider) => {
    delete tx.inputs;
    const outputQuantities = tx.outputs
        ?.filter((o) => o.type === fuels.OutputType.Coin)
        .map(({ amount, assetId }) => ({
        amount: fuels.bn(amount),
        assetId: String(assetId),
    }));
    const aResponse = await provider.assembleTx({
        accountCoinQuantities: outputQuantities,
        estimatePredicates: true,
        feePayerAccount: new fuels.Account(address),
        // @ts-ignore
        request: tx,
    });
    logger$f.debug('fixTx:sendTransaction:3', {
        assembleTxResponse: aResponse,
        request: tx,
    });
    return aResponse.assembledRequest;
};
const isFuelNativeTransfer = (tx) => {
    return tx.outputs?.every((o) => {
        return 'assetId' in o && o.assetId === FUEL_BASE_ASSET_ID;
    });
};

const logger$e = getLogger();
const getFuelProvider = (getBalances, address, chain) => {
    return new (class Provider extends fuels.Provider {
        constructor(url, options) {
            super(url, { ...options, resourceCacheTTL: -1 });
        }
        async assembleTx(params) {
            const { request } = params;
            logger$e.debug('ffProvider', {
                request,
            });
            const addr = new fuels.Address(address);
            const balances = await getBalances();
            const assetIdsOnFuel = chain.custom.knownTokens.map((c) => c.contractAddress);
            const outputAssetList = request.outputs.filter((o) => o.type === fuels.OutputType.Coin);
            const allAssetSupported = outputAssetList.every((a) => assetIdsOnFuel.includes(fuels.hexlify(a.assetId)));
            logger$e.debug('FuelProvide:1', {
                allAssetSupported,
                assetIdsOnFuel,
                outputAssetList,
            });
            if (!allAssetSupported) {
                return super.assembleTx({
                    ...params,
                    feePayerAccount: new fuels.Account(addr),
                    request,
                });
            }
            const al = [];
            for (const a of assetIdsOnFuel) {
                if (!outputAssetList.map((al) => al.assetId).includes(a) && a !== FUEL_BASE_ASSET_ID) {
                    continue;
                }
                const asset = balances.find((asset) => asset.breakdown.find((b) => equalFold(b.contractAddress, fuels.hexlify(a)) && b.universe === caCommon.Universe.FUEL));
                const chainAsset = asset?.breakdown.find((b) => equalFold(b.contractAddress, fuels.hexlify(a)) && b.universe === caCommon.Universe.FUEL);
                logger$e.debug('FuelProvider:2', {
                    asset,
                    chainAsset,
                });
                if (asset && chainAsset) {
                    const decimals = equalFold(FUEL_BASE_ASSET_ID, chainAsset.contractAddress)
                        ? 9
                        : asset.decimals;
                    const amount = new fuels.BN(mulDecimals(asset.balance, decimals).toString());
                    logger$e.debug('FuelProvider:3', {
                        amount,
                        assetId: fuels.hexlify(a),
                    });
                    al.push({
                        amount,
                        assetId: fuels.hexlify(a),
                    });
                }
            }
            request.addResources(generateFakeResources(al, new fuels.Address(address)));
            const { accountCoinQuantities, ...rest } = params;
            logger$e.debug('FuelProvider:4', {
                accountCoinQuantities,
                params: { ...params },
                request,
                rest,
            });
            const response = await super.assembleTx({
                ...rest,
                request,
            });
            logger$e.debug('FuelProvider:4', {
                accountCoinQuantities,
                params: { ...params },
                request,
                response,
            });
            return response;
        }
    })(FUEL_NETWORK_URL);
};
const generateFakeResources = (coins, address) => {
    return coins.map((coin) => ({
        blockCreated: fuels.bn(1),
        id: fuels.hexlify(fuels.randomBytes(fuels.UTXO_ID_LEN)),
        owner: address,
        txCreatedIdx: fuels.bn(1),
        ...coin,
    }));
};

const isERC20TokenTransfer = (input) => {
    if (input.evm.tx) {
        const { data, to } = input.evm.tx;
        if (!data) {
            return false;
        }
        const token = input.chainList.getTokenByAddress(input.chain.id, to);
        const isTokenSupported = !!token;
        if (isTokenSupported && data) {
            const { functionName } = getTokenTxFunction(data);
            if (functionName === 'transfer') {
                return true;
            }
        }
    }
    return false;
};
const isNativeTokenTransfer = (input) => {
    if (input.evm.tx) {
        const { value } = input.evm.tx;
        if (!value)
            return false;
        try {
            return BigInt(value) > 0n;
        }
        catch {
            return false;
        }
    }
    return false;
};

const simulateTransaction = async (chainID, simulations, baseURL) => {
    const url = new URL("/simulate", baseURL).toString();
    return await axios__default.default.post(url, {
        chainID,
        simulations,
    }, {
        headers: {
            "Content-Type": "application/json",
        },
    });
};

const EADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
const SWEEPER_ADDRESS = '0x0000000000296e7a886f40f7bc60D2E3653216a6';
const ZERO_BYTES_32 = new Uint8Array(32);
const ZERO_BYTES_20 = new Uint8Array(20);
const CALIBUR_ADDRESS = '0x00000000557A0daF2659cbb6A45f2beB6081e6AE';
const CALIBUR_EIP712 = {
    name: 'Calibur',
    salt: convertTo32BytesHex(CALIBUR_ADDRESS),
    version: '1.0.0',
};
const LIFI_API_KEY = 'bcb7981d-ea26-4adf-8926-95d3adf4c001.23bcc0d7-7df7-4c86-bb37-ae9ffc25bb95';
const BEBOP_API_KEY = 'ae262dbf-e4d0-4b66-aaec-57a1b4581440';

var CaliburABI = [
    {
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                components: [
                                    {
                                        internalType: 'address',
                                        name: 'to',
                                        type: 'address',
                                    },
                                    {
                                        internalType: 'uint256',
                                        name: 'value',
                                        type: 'uint256',
                                    },
                                    {
                                        internalType: 'bytes',
                                        name: 'data',
                                        type: 'bytes',
                                    },
                                ],
                                internalType: 'struct Call[]',
                                name: 'calls',
                                type: 'tuple[]',
                            },
                            {
                                internalType: 'bool',
                                name: 'revertOnFailure',
                                type: 'bool',
                            },
                        ],
                        internalType: 'struct BatchedCall',
                        name: 'batchedCall',
                        type: 'tuple',
                    },
                    {
                        internalType: 'uint256',
                        name: 'nonce',
                        type: 'uint256',
                    },
                    {
                        internalType: 'bytes32',
                        name: 'keyHash',
                        type: 'bytes32',
                    },
                    {
                        internalType: 'address',
                        name: 'executor',
                        type: 'address',
                    },
                    {
                        internalType: 'uint256',
                        name: 'deadline',
                        type: 'uint256',
                    },
                ],
                internalType: 'struct SignedBatchedCall',
                name: 'signedBatchedCall',
                type: 'tuple',
            },
            {
                internalType: 'bytes',
                name: 'wrappedSignature',
                type: 'bytes',
            },
        ],
        name: 'execute',
        outputs: [],
        stateMutability: 'payable',
        type: 'function',
    },
    {
        type: 'function',
        name: 'approveNative',
        inputs: [
            {
                name: 'spender',
                type: 'address',
                internalType: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
                internalType: 'uint256',
            },
        ],
        outputs: [
            {
                name: '',
                type: 'bool',
                internalType: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
    },
    {
        type: 'function',
        name: 'nativeAllowance',
        inputs: [
            {
                name: 'spender',
                type: 'address',
                internalType: 'address',
            },
        ],
        outputs: [
            {
                name: 'allowance',
                type: 'uint256',
                internalType: 'uint256',
            },
        ],
        stateMutability: 'view',
    },
];

const SWEEP_ABI = [
    {
        inputs: [
            {
                internalType: 'address',
                name: 'token',
                type: 'address',
            },
        ],
        name: 'SafeERC20FailedOperation',
        type: 'error',
    },
    {
        inputs: [
            {
                internalType: 'contract IERC20',
                name: 'token',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
        ],
        name: 'sweepERC20',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
        ],
        name: 'sweepERC7914',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];

const logger$d = getLogger();
const createBatchedCallSignature = (batchedCalls, nonce, chain, address, account) => {
    return account.signTypedData({
        domain: {
            chainId: chain,
            name: CALIBUR_EIP712.name,
            salt: CALIBUR_EIP712.salt,
            verifyingContract: address,
            version: CALIBUR_EIP712.version,
        },
        message: {
            batchedCall: {
                calls: batchedCalls,
                revertOnFailure: true,
            },
            deadline: viem.maxUint256,
            executor: viem.toHex(ZERO_BYTES_20),
            keyHash: viem.toHex(ZERO_BYTES_32),
            nonce,
        },
        primaryType: 'SignedBatchedCall',
        types: commons.CaliburSBCTypes,
    });
};
const waitForSBCTxReceipt = (ops, chainList, publicClientList) => {
    return Promise.all(ops.map((op) => {
        const chain = chainList.getChainByID(Number(op[0]));
        const explorerURL = new URL(`/tx/${op[1]}`, chain.blockExplorers?.default.url);
        console.log({ explorerURL: explorerURL.toString() });
        return waitForTxReceipt(op[1], publicClientList.get(chain.id), 2);
    }));
};
const checkAuthCodeSet = async (chainID, address, cache) => {
    return isAuthorizationCodeSet(chainID, address, cache);
};
const createSBCTxFromCalls = async ({ cache, calls, chainID, ephemeralAddress, ephemeralWallet, publicClient, }) => {
    const nonce = viem.bytesToBigInt(window.crypto.getRandomValues(new Uint8Array(24))) << 64n;
    const signature = await createBatchedCallSignature(calls, nonce, BigInt(chainID), ephemeralAddress, ephemeralWallet);
    let authorization = null;
    if (!(await isAuthorizationCodeSet(chainID, ephemeralAddress, cache))) {
        const nonce = await publicClient.getTransactionCount({
            address: ephemeralAddress,
            blockTag: 'pending',
        });
        // create authorization for calibur
        authorization = await ephemeralWallet.signAuthorization({
            chainId: Number(chainID),
            contractAddress: CALIBUR_ADDRESS,
            nonce,
        });
    }
    const request = {
        address: convertTo32Bytes(ephemeralAddress),
        authorization_list: [],
        calls: calls.map((c) => ({
            data: viem.toBytes(c.data),
            to_addr: viem.toBytes(c.to),
            value: convertTo32Bytes(c.value),
        })),
        chain_id: convertTo32Bytes(chainID),
        deadline: viem.toBytes(viem.maxUint256),
        key_hash: ZERO_BYTES_32,
        nonce: convertTo32Bytes(nonce),
        revert_on_failure: true,
        signature: viem.toBytes(packSignatureAndHookData(signature)),
        universe: caCommon.Universe.ETHEREUM,
    };
    if (authorization) {
        request.authorization_list.push({
            address: viem.toBytes(CALIBUR_ADDRESS),
            chain_id: convertTo32Bytes(authorization.chainId),
            nonce: authorization.nonce,
            sig_r: viem.toBytes(authorization.r),
            sig_s: viem.toBytes(authorization.s),
            sig_v: Number(authorization.yParity),
        });
    }
    logger$d.debug('createSBCTxFromCalls', {
        request,
    });
    return request;
};
const caliburExecute = async ({ actualAddress, actualWallet, calls, chain, ephemeralAddress, ephemeralWallet, value, }) => {
    const nonce = viem.bytesToBigInt(window.crypto.getRandomValues(new Uint8Array(24))) << 64n;
    const signature = await createBatchedCallSignature(calls, nonce, BigInt(chain.id), ephemeralAddress, ephemeralWallet);
    return actualWallet.writeContract({
        abi: CaliburABI,
        account: actualAddress,
        address: ephemeralAddress,
        args: [
            {
                batchedCall: {
                    calls,
                    revertOnFailure: true,
                },
                deadline: viem.maxUint256,
                executor: viem.toHex(ZERO_BYTES_20),
                keyHash: viem.toHex(ZERO_BYTES_32),
                nonce,
            },
            packSignatureAndHookData(signature),
        ],
        chain,
        functionName: 'execute',
        value,
    });
};
const packSignatureAndHookData = (signature, hookData = '0x') => {
    return viem.encodeAbiParameters([
        { name: 'signature', type: 'bytes' },
        { name: 'hookData', type: 'bytes' },
    ], [signature, hookData]);
};

const SWAP_START = {
    completed: true,
    type: 'SWAP_START',
    typeID: 'SWAP_START',
};
const DETERMINING_SWAP = (completed = false) => ({
    completed,
    type: 'DETERMINING_SWAP',
    typeID: DETERMINING_SWAP,
});
const CREATE_PERMIT_FOR_SOURCE_SWAP = (completed, symbol, chain) => ({
    chain: {
        id: chain.id,
        name: chain.name,
    },
    completed,
    symbol,
    type: 'CREATE_PERMIT_FOR_SOURCE_SWAP',
    typeID: `CREATE_PERMIT_FOR_SOURCE_SWAP_${chain.id}_${symbol}`,
});
const SOURCE_SWAP_HASH = (ops, chainList) => {
    const chainID = ops[0];
    const chain = chainList.getChainByID(Number(ops[0]));
    if (!chain) {
        throw new Error(`Unknown chain: ${ops[0]}`);
    }
    return {
        chain: {
            id: chain.id,
            name: chain.name,
        },
        completed: true,
        explorerURL: new URL(`/tx/${ops[1]}`, chain.blockExplorers?.default.url).toString(),
        type: 'SOURCE_SWAP_HASH',
        typeID: `SOURCE_SWAP_HASH_${chainID}`,
    };
};
const RFF_ID = (id) => ({
    completed: true,
    data: id,
    type: 'RFF_ID',
    typeID: 'RFF_ID',
});
const DESTINATION_SWAP_BATCH_TX = (completed) => ({
    completed,
    type: 'DESTINATION_SWAP_BATCH_TX',
    typeID: 'DESTINATION_SWAP_BATCH_TX',
});
const SWAP_COMPLETE = {
    completed: true,
    type: 'SWAP_COMPLETE',
    typeID: 'SWAP_COMPLETE',
};
const DESTINATION_SWAP_HASH = (op, chainList) => {
    const chain = chainList.getChainByID(Number(op[0]));
    if (!chain) {
        throw new Error(`Unknown chain: ${op[0]}`);
    }
    return {
        chain: {
            id: chain.id,
            name: chain.name,
        },
        completed: true,
        explorerURL: new URL(`/tx/${op[1]}`, chain.blockExplorers?.default.url).toString(),
        type: 'DESTINATION_SWAP_HASH',
        typeID: `DESTINATION_SWAP_HASH_${chain.id}`,
    };
};

const logger$c = getLogger();
const convertTo32Bytes = (input) => {
    if (typeof input === 'string') {
        return viem.toBytes(viem.pad(input, { dir: 'left', size: 32 }));
    }
    if (typeof input === 'bigint' || typeof input === 'number') {
        return viem.toBytes(input, {
            size: 32,
        });
    }
    return viem.pad(input, { dir: 'left', size: 32 });
};
const EADDRESS_32_BYTES = convertTo32Bytes(EADDRESS);
const convertToEVMAddress = (address) => {
    if (typeof address === 'string') {
        address = viem.toBytes(address);
    }
    if (address.length === 20) {
        return viem.toHex(address);
    }
    if (address.length == 32) {
        return viem.toHex(address.subarray(12));
    }
    throw new Error('Invalid address');
};
const bytesEqual = (bytes1, bytes2) => {
    logger$c.debug('bytesEqual', {
        bytes1,
        bytes2,
    });
    if (bytes1.length !== bytes2.length) {
        return false;
    }
    for (let i = 0; i < bytes1.length; i++) {
        if (bytes1[i] !== bytes2[i]) {
            return false;
        }
    }
    return true;
};
const AnkrChainIdMapping = new Map([
    ['arbitrum', 42161],
    ['avalanche_fuji', 43113],
    ['avalanche', 43114],
    ['base_sepolia', 84532],
    ['base', 8453],
    ['bsc', 56],
    ['eth_holesky', 17000],
    ['eth_sepolia', 11155111],
    ['eth', 1],
    ['fantom', 250],
    ['flare', 14],
    ['gnosis', 100],
    ['linea', 59144],
    ['optimism_testnet', 11155420],
    ['optimism', 10],
    ['polygon_amoy', 80002],
    ['polygon_zkevm', 1101],
    ['polygon', 137],
    ['rollux', 570],
    ['scroll', 534352],
    ['story_testnet', 1513],
    ['story', 1514],
    ['syscoin', 57],
    ['telos', 40],
    ['xai', 660279],
    ['xlayer', 196],
]);
const createPermitSignature = async (contractAddress, client, spender, walletAddress, variant, version) => {
    const contract = viem.getContract({
        abi: caCommon.ERC20ABI,
        address: contractAddress,
        client,
    });
    const [name, chainID, nonce] = await Promise.all([
        contract.read.name(),
        client.request({ method: 'eth_chainId' }, { dedupe: true }),
        contract.read.nonces([walletAddress]),
    ]);
    logger$c.debug('createPermitSigParams', {
        account: walletAddress,
        domain: {
            chainId: viem.hexToBigInt(chainID),
            name,
            verifyingContract: contractAddress,
            version,
        },
        message: {
            deadline: viem.maxUint256,
            nonce,
            owner: walletAddress,
            spender: spender,
            value: viem.maxUint256,
        },
        primaryType: 'Permit',
        types: ERC20PermitEIP712Type,
    });
    switch (variant) {
        case caCommon.PermitVariant.EIP2612Canonical: {
            return {
                signature: await client.signTypedData({
                    account: walletAddress,
                    domain: {
                        chainId: viem.hexToBigInt(chainID),
                        name,
                        verifyingContract: contractAddress,
                        version: version.toString(),
                    },
                    message: {
                        deadline: viem.maxUint256,
                        nonce,
                        owner: walletAddress,
                        spender: spender,
                        value: viem.maxUint256,
                    },
                    primaryType: 'Permit',
                    types: ERC20PermitEIP712Type,
                }),
                variant,
            };
        }
        case caCommon.PermitVariant.PolygonEMT: {
            return {
                signature: await client.signTypedData({
                    account: walletAddress,
                    domain: {
                        name,
                        salt: viem.pad(chainID, {
                            dir: 'left',
                            size: 32,
                        }),
                        verifyingContract: contract.address,
                        version: version.toString(10),
                    },
                    message: {
                        from: walletAddress,
                        functionSignature: packERC20Approve(spender),
                        nonce,
                    },
                    primaryType: 'MetaTransaction',
                    types: ERC20PermitEIP2612PolygonType,
                }),
                variant,
            };
        }
        default: {
            throw new Error('Token Not supported: (2612 details not found)');
        }
    }
};
const vscSBCTx = async (input, vscDomain) => {
    const ops = [];
    const connection = itWs.connect(new URL('/api/v1/create-sbc-tx', getVSCURL(vscDomain, 'wss')).toString());
    try {
        await connection.connected();
        connection.socket.send(msgpackr.pack(input));
        let count = 0;
        for await (const response of connection.source) {
            const data = msgpackr.unpack(response);
            logger$c.debug('vscSBCTx', { data });
            if (data.errored) {
                throw new Error('Error in VSC SBC Tx');
            }
            ops.push([viem.bytesToBigInt(input[data.part_idx].chain_id), viem.toHex(data.tx_hash)]);
            count += 1;
            if (count === input.length) {
                break;
            }
        }
    }
    finally {
        await connection.close();
    }
    return ops;
};
const cosmosCreateRFF = async ({ address, cosmosURL, msg, wallet, }) => {
    const client = await caCommon.createCosmosClient(wallet, getCosmosURL(cosmosURL, 'rpc'), {
        broadcastPollIntervalMs: 250,
    });
    const res = await client.signAndBroadcast(address, [
        {
            typeUrl: '/xarchain.chainabstraction.MsgCreateRequestForFunds',
            value: msg,
        },
    ], {
        amount: [],
        gas: 100000n.toString(10),
    });
    if (stargate.isDeliverTxFailure(res)) {
        throw new Error('Error creating RFF');
    }
    const decoded = caCommon.MsgCreateRequestForFundsResponse.decode(res.msgResponses[0].value);
    return decoded.id;
};
const cosmosCreateDoubleCheckTx = async ({ address, cosmosURL, msg, wallet, }) => {
    const client = await caCommon.createCosmosClient(wallet, getCosmosURL(cosmosURL, 'rpc'), {
        broadcastPollIntervalMs: 250,
    });
    logger$c.debug('cosmosCreateDoubleCheckTx:1', { doubleCheckMsg: msg });
    const res = await client.signAndBroadcast(address, [
        {
            typeUrl: '/xarchain.chainabstraction.MsgDoubleCheckTx',
            value: msg,
        },
    ], {
        amount: [],
        gas: 100000n.toString(10),
    });
    if (stargate.isDeliverTxFailure(res)) {
        throw new Error('Error creating MsgDoubleCheckTx');
    }
    logger$c.debug('cosmosCreateDoubleCheckTx:2', { doubleCheckTx: res });
};
const EXPECTED_CALIBUR_CODE = viem.concat(['0xef0100', CALIBUR_ADDRESS]);
const isAuthorizationCodeSet = async (chainID, address, cache) => {
    const code = cache.getCode({
        address,
        chainID,
    });
    logger$c.debug('isAuthorizationCodeSet', { code, EXPECTED_CALIBUR_CODE });
    if (!code) {
        return false;
    }
    return code != '0x' && equalFold(code, EXPECTED_CALIBUR_CODE);
};
const isNativeAddress = (contractAddress) => equalFold(contractAddress, ZERO_ADDRESS) || equalFold(contractAddress, EADDRESS);
/**
 * Creates EIP2612 signature or executes non sponsored approval and transferFrom Tx
 */
const createPermitAndTransferFromTx = async ({ amount, approval, cache, chain, contractAddress, owner, ownerWallet, publicClient, spender, }) => {
    const txList = [];
    await ownerWallet.switchChain({
        id: chain.id,
    });
    logger$c.debug('createPermitCalls', {
        contractAddress,
        EADDRESS,
    });
    let allowance = cache.getAllowance({
        chainID: chain.id,
        contractAddress,
        owner,
        spender,
    });
    if (allowance === undefined) {
        logger$c.debug('createPermitCalls: allowance not found in cache', {
            cache,
            chain,
            contractAddress,
            owner,
            spender,
        });
        allowance = await publicClient.readContract({
            abi: caCommon.ERC20ABI,
            address: contractAddress,
            args: [owner, spender],
            functionName: 'allowance',
        });
    }
    logger$c.debug('createPermitTx', { allowance, amount });
    if (allowance < amount) {
        const { variant, version } = getTokenVersion(contractAddress);
        if (variant === caCommon.PermitVariant.Unsupported) {
            const { request } = await publicClient.simulateContract({
                chain,
                abi: caCommon.ERC20ABI,
                account: owner,
                address: contractAddress,
                args: [spender, viem.maxUint256],
                functionName: 'approve',
            });
            const hash = await ownerWallet.writeContract(request);
            await waitForTxReceipt(hash, publicClient, 1);
            // On retry the value will be present, so no need to refetch allowance
            cache.addAllowanceValue({
                chainID: chain.id,
                contractAddress,
                owner,
                spender,
            }, viem.maxUint256);
        }
        else {
            const approvalTx = approval ??
                (await createPermitApprovalTx({
                    contractAddress,
                    owner,
                    ownerWallet,
                    spender,
                    variant,
                    version,
                }));
            txList.push(approvalTx);
        }
    }
    txList.push({
        data: viem.encodeFunctionData({
            abi: caCommon.ERC20ABI,
            args: [owner, spender, amount],
            functionName: 'transferFrom',
        }),
        to: contractAddress,
        value: 0n,
    });
    return txList;
};
const createPermitApprovalTx = async ({ contractAddress, owner, ownerWallet, spender, variant, version, }) => {
    const { signature } = await createPermitSignature(contractAddress, ownerWallet, spender, owner, variant, version);
    const { r, s, v } = viem.parseSignature(signature);
    if (!v) {
        throw new Error('invalid signature: v is not present');
    }
    return {
        data: variant === caCommon.PermitVariant.PolygonEMT
            ? viem.encodeFunctionData({
                abi: ERC20PermitABI,
                args: [owner, packERC20Approve(spender), r, s, Number(v)],
                functionName: 'executeMetaTransaction',
            })
            : viem.encodeFunctionData({
                abi: ERC20PermitABI,
                args: [owner, spender, viem.maxUint256, viem.maxUint256, Number(v), r, s],
                functionName: 'permit',
            }),
        to: contractAddress,
        value: 0n,
    };
};
const packERC20Approve = (spender, amount = viem.maxUint256) => {
    return viem.encodeFunctionData({
        abi: caCommon.ERC20ABI,
        args: [spender, amount],
        functionName: 'approve',
    });
};
const multiplierByChain = (chainID) => {
    switch (chainID) {
        case 534352:
            return 100n;
        default:
            return 3n;
    }
};
const getAnkrBalances = async (walletAddress, chainList, removeTransferFee = false) => {
    const publicClients = {};
    const res = await axios__default.default.post('https://rpc.ankr.com/multichain/269e541dd5773dac3204831e29b9538284dd3e9591d2b7cb2ac47d85eae213b9/', {
        id: Decimal__default.default.random(2).mul(100).toNumber(),
        jsonrpc: '2.0',
        method: 'ankr_getAccountBalance',
        params: {
            blockchain: chainList.getAnkrNameList(),
            onlyWhitelisted: true,
            pageSize: 500,
            walletAddress: walletAddress,
        },
    });
    if (!res.data?.result)
        throw new Error('balances cannot be retrieved');
    const filteredAssets = res.data.result.assets.filter((asset) => AnkrChainIdMapping.has(asset.blockchain) &&
        !new Decimal__default.default(asset.tokenPrice?.trim() || 0).equals(0));
    const assets = [];
    const promises = [];
    for (const asset of filteredAssets) {
        promises.push((async () => {
            let balance = asset.balance;
            if (removeTransferFee && asset.tokenType === 'NATIVE') {
                const chainID = AnkrChainIdMapping.get(asset.blockchain);
                const chain = chainList.getChainByID(AnkrChainIdMapping.get(asset.blockchain));
                if (!publicClients[chainID]) {
                    const client = viem.createPublicClient({
                        transport: viem.http(chain.rpcUrls.default.http[0]),
                    });
                    publicClients[chainID] = client;
                }
                const fee = await publicClients[chainID].estimateFeesPerGas();
                const multipler = multiplierByChain(Number(chainID));
                const transferFee = divDecimals(fee.maxFeePerGas * 1500000n * multipler, chain.nativeCurrency.decimals);
                logger$c.debug('getAnkrBalances', {
                    balance: asset.balance,
                    chainID,
                    transferFee: transferFee.toFixed(),
                });
                balance = new Decimal__default.default(asset.balance).gt(transferFee)
                    ? Decimal__default.default.sub(asset.balance, transferFee).toFixed(asset.tokenDecimals, Decimal__default.default.ROUND_FLOOR)
                    : '0';
                logger$c.debug('getAnkrBalances', {
                    chainID,
                    newBalance: balance,
                    oldBalance: asset.balance,
                    transferFee: transferFee.toFixed(),
                });
            }
            assets.push({
                balance,
                balanceUSD: asset.balanceUsd,
                chainID: AnkrChainIdMapping.get(asset.blockchain),
                tokenAddress: asset.tokenType === 'ERC20' ? asset.contractAddress : ZERO_ADDRESS,
                tokenData: {
                    decimals: asset.tokenDecimals,
                    icon: asset.thumbnail,
                    name: asset.tokenName,
                    symbol: getTokenSymbol(asset.tokenSymbol),
                },
                universe: caCommon.Universe.ETHEREUM,
            });
        })());
    }
    await Promise.all(promises);
    return assets;
};
function getTokenSymbol(symbol) {
    if (['USD₮', 'USD₮0', 'USDt'].includes(symbol)) {
        return 'USDT';
    }
    return symbol;
}
const toFlatBalance = (assets, currentChainID, selectedTokenAddress) => {
    logger$c.debug('toFlatBalance', {
        assets,
    });
    return assets
        .map((a) => a.breakdown.map((b) => {
        return {
            amount: b.balance,
            chainID: b.chain.id,
            decimals: b.decimals,
            symbol: a.symbol,
            tokenAddress: convertTo32BytesHex(b.contractAddress === ZERO_ADDRESS ? EADDRESS : b.contractAddress),
            universe: b.universe,
            value: b.balanceInFiat,
        };
    }))
        .flat()
        .filter((b) => {
        return !(b.chainID === currentChainID && equalFold(b.tokenAddress, selectedTokenAddress));
    })
        .filter((b) => b.universe === caCommon.Universe.ETHEREUM &&
        new Decimal__default.default(b.amount).gt(0) &&
        new Decimal__default.default(b.value).gt(0));
};
const balancesToAssets = (ankrBalances, evmBalances, fuelBalances, chainList) => {
    const assets = [];
    const vscBalances = evmBalances.concat(fuelBalances);
    logger$c.debug('balanceToAssets', {
        ankrBalances,
        evmBalances,
        fuelBalances,
    });
    for (const balance of vscBalances) {
        for (const currency of balance.currencies) {
            const chain = chainList.getChainByID(viem.bytesToNumber(balance.chain_id));
            if (!chain) {
                continue;
            }
            const tokenAddress = convertAddressByUniverse(viem.toHex(currency.token_address), balance.universe);
            const token = chainList.getTokenByAddress(chain.id, tokenAddress);
            const decimals = token ? token.decimals : chain.nativeCurrency.decimals;
            if (token) {
                const asset = assets.find((s) => s.symbol === token.symbol);
                if (asset) {
                    asset.balance = new Decimal__default.default(asset.balance).add(currency.balance).toFixed();
                    asset.balanceInFiat = new Decimal__default.default(asset.balanceInFiat)
                        .add(currency.value)
                        .toDecimalPlaces(2)
                        .toNumber();
                    asset.breakdown.push({
                        balance: currency.balance,
                        balanceInFiat: new Decimal__default.default(currency.value).toDecimalPlaces(2).toNumber(),
                        chain: {
                            id: viem.bytesToNumber(balance.chain_id),
                            logo: chain.custom.icon,
                            name: chain.name,
                        },
                        contractAddress: tokenAddress,
                        decimals,
                        universe: balance.universe,
                    });
                }
                else {
                    assets.push({
                        abstracted: true,
                        balance: currency.balance,
                        balanceInFiat: new Decimal__default.default(currency.value).toDecimalPlaces(2).toNumber(),
                        breakdown: [
                            {
                                balance: currency.balance,
                                balanceInFiat: new Decimal__default.default(currency.value).toDecimalPlaces(2).toNumber(),
                                chain: {
                                    id: viem.bytesToNumber(balance.chain_id),
                                    logo: chain.custom.icon,
                                    name: chain.name,
                                },
                                contractAddress: tokenAddress,
                                decimals,
                                universe: balance.universe,
                            },
                        ],
                        decimals: token.decimals,
                        icon: getLogoFromSymbol(token.symbol),
                        symbol: token.symbol,
                    });
                }
            }
        }
    }
    for (const asset of ankrBalances) {
        if (new Decimal__default.default(asset.balance).equals(0)) {
            continue;
        }
        const d = chainData.get(asset.chainID);
        if (!d) {
            continue;
        }
        const chain = chainList.getChainByID(asset.chainID);
        if (!chain) {
            continue;
        }
        const existingAsset = assets.find((a) => equalFold(a.symbol, asset.tokenData.symbol));
        if (existingAsset) {
            if (!existingAsset.breakdown.find((t) => t.chain.id === chain.id && equalFold(t.contractAddress, asset.tokenAddress))) {
                existingAsset.balance = Decimal__default.default.add(existingAsset.balance, asset.balance).toFixed();
                existingAsset.balanceInFiat = Decimal__default.default.add(existingAsset.balanceInFiat, asset.balanceUSD)
                    .toDecimalPlaces(2)
                    .toNumber();
                existingAsset.breakdown.push({
                    balance: asset.balance,
                    balanceInFiat: new Decimal__default.default(asset.balanceUSD).toDecimalPlaces(2).toNumber(),
                    chain: {
                        id: chain.id,
                        logo: chain.custom.icon,
                        name: chain.name,
                    },
                    contractAddress: asset.tokenAddress,
                    decimals: asset.tokenData.decimals,
                    universe: asset.universe,
                });
            }
        }
        else {
            assets.push({
                abstracted: true,
                balance: asset.balance,
                balanceInFiat: new Decimal__default.default(asset.balanceUSD).toDecimalPlaces(2).toNumber(),
                breakdown: [
                    {
                        balance: asset.balance,
                        balanceInFiat: new Decimal__default.default(asset.balanceUSD).toDecimalPlaces(2).toNumber(),
                        chain: {
                            id: chain.id,
                            logo: chain.custom.icon,
                            name: chain.name,
                        },
                        contractAddress: asset.tokenAddress,
                        decimals: asset.tokenData.decimals,
                        universe: asset.universe,
                    },
                ],
                decimals: asset.tokenData.decimals,
                icon: asset.tokenData.icon,
                symbol: asset.tokenData.symbol,
            });
        }
    }
    assets.forEach((asset) => {
        asset.breakdown.sort((a, b) => b.balanceInFiat - a.balanceInFiat);
    });
    assets.sort((a, b) => b.balanceInFiat - a.balanceInFiat);
    return assets;
};
class Cache {
    constructor(publicClientList) {
        this.publicClientList = publicClientList;
        this.allowanceValues = new Map();
        this.setCodeValues = new Map();
        this.allowanceQueries = new Set();
        this.nativeAllowanceQueries = new Set();
        this.setCodeQueries = new Set();
    }
    addAllowanceQuery(input) {
        this.allowanceQueries.add(input);
    }
    addAllowanceValue(input, value) {
        this.allowanceValues.set(getAllowanceCacheKey(input), value);
    }
    addNativeAllowanceQuery(input) {
        this.nativeAllowanceQueries.add(input);
    }
    addSetCodeQuery(input) {
        this.setCodeQueries.add(input);
    }
    addSetCodeValue(input, value) {
        this.setCodeValues.set(getSetCodeKey(input), value);
    }
    getAllowance(input) {
        return this.allowanceValues.get(getAllowanceCacheKey(input));
    }
    getCode(input) {
        return this.setCodeValues.get(getSetCodeKey(input));
    }
    async process() {
        await Promise.all([
            this.processNativeAllowanceRequests(),
            this.processAllowanceRequests(),
            this.processGetCodeRequests(),
        ]);
    }
    async processNativeAllowanceRequests() {
        const requests = [];
        for (const input of this.nativeAllowanceQueries) {
            const publicClient = this.publicClientList.get(input.chainID);
            requests.push((async (inp, publicClient) => {
                let allowance = 0n;
                const code = await publicClient.getCode({
                    address: inp.contractAddress,
                });
                if (equalFold(code, EXPECTED_CALIBUR_CODE)) {
                    allowance = await publicClient.readContract({
                        address: inp.contractAddress,
                        abi: CaliburABI,
                        functionName: 'nativeAllowance',
                        args: [inp.spender],
                    });
                }
                this.allowanceValues.set(getAllowanceCacheKey(inp), allowance);
            })(input, publicClient));
        }
        await Promise.all(requests);
    }
    async processAllowanceRequests() {
        // The request query list is small so don't care about performance here (for now)
        const unprocessedInput = [...this.allowanceQueries].filter((v) => this.getAllowance(v) === undefined);
        const inputByChainID = Map.groupBy(unprocessedInput, (i) => i.chainID);
        const requests = [];
        for (const [chainID, inputs] of inputByChainID) {
            const publicClient = this.publicClientList.get(chainID);
            for (const input of inputs) {
                requests.push(equalFold(input.contractAddress, EADDRESS)
                    ? Promise.resolve(this.allowanceValues.set(getAllowanceCacheKey(input), viem.maxUint256))
                    : publicClient
                        .readContract({
                        abi: caCommon.ERC20ABI,
                        address: input.contractAddress,
                        args: [input.owner, input.spender],
                        functionName: 'allowance',
                    })
                        .then((allowance) => {
                        this.allowanceValues.set(getAllowanceCacheKey(input), allowance);
                    }));
            }
        }
        await Promise.all(requests);
    }
    async processGetCodeRequests() {
        const requests = [];
        for (const input of this.setCodeQueries) {
            const publicClient = this.publicClientList.get(input.chainID);
            requests.push(publicClient
                .getCode({
                address: input.address,
            })
                .then((code) => {
                this.setCodeValues.set(getSetCodeKey(input), code);
            }));
        }
        await Promise.all(requests);
    }
}
// To remove duplication of publicClients
class PublicClientList {
    constructor(chainList) {
        this.chainList = chainList;
        this.list = {};
    }
    get(chainID) {
        let client = this.list[Number(chainID)];
        if (!client) {
            const chain = this.chainList.getChainByID(Number(chainID));
            if (!chain) {
                throw new Error(`Chain not found: ${chainID}`);
            }
            client = viem.createPublicClient({
                transport: viem.http(chain.rpcUrls.default.http[0]),
                batch: {
                    multicall: true,
                },
            });
            this.list[Number(chainID)] = client;
        }
        return client;
    }
}
const getAllowanceCacheKey = ({ chainID, contractAddress, owner, spender, }) => ('a' + contractAddress + chainID + owner + spender).toLowerCase();
const getSetCodeKey = (input) => ('a' + input.chainID + input.address).toLowerCase();
// const APPROVE_GAS_LIMIT = 63_000n;
// export const swapToGasIfPossible = async ({
//   actualAddress,
//   aggregators,
//   assetsUsed,
//   balances,
//   chainList,
//   ephemeralAddress,
//   oraclePrices,
// }: {
//   actualAddress: Bytes;
//   aggregators: Aggregator[];
//   assetsUsed: {
//     amount: string;
//     chainID: number;
//     contractAddress: `0x${string}`;
//   }[];
//   balances: Balances;
//   chainList: ChainList;
//   ephemeralAddress: Bytes;
//   grpcURL: string;
//   oraclePrices: OraclePriceResponse;
// }) => {
//   const aci: CreateAllowanceCacheInput = new Set();
//   const blacklist: Hex[] = [];
//   const data: {
//     [k: number]: {
//       amount: bigint;
//       contractAddress: Hex;
//       txs: Tx[];
//       unsupportedTokens: Hex[];
//     };
//   } = {};
//   let requote = false;
//   const chainToUnsupportedTokens: Record<number, Hex[]> = {};
//   const assetsGroupedByChain = Map.groupBy(
//     assetsUsed,
//     (asset) => asset.chainID,
//   );
//   for (const [chainID, swapQuotes] of assetsGroupedByChain) {
//     for (const sQuote of swapQuotes) {
//       if (!isEIP2612Supported(sQuote.contractAddress, BigInt(chainID))) {
//         if (!chainToUnsupportedTokens[Number(chainID)]) {
//           chainToUnsupportedTokens[Number(chainID)] = [];
//         }
//         aci.add({
//           chainID: Number(chainID),
//           contractAddress: sQuote.contractAddress,
//           owner: convertToEVMAddress(actualAddress),
//           spender: convertToEVMAddress(ephemeralAddress),
//         });
//         chainToUnsupportedTokens[Number(chainID)].push(sQuote.contractAddress);
//       }
//     }
//   }
//   logger.debug("checkAndSupplyGasForApproval:1", {
//     assetsGroupedByChain,
//     chainToUnsupportedTokens,
//   });
//   const allowanceCache = await createAllowanceCache(aci, chainList);
//   if (Object.keys(chainToUnsupportedTokens).length === 0) {
//     return { blacklist, data, requote: false };
//   }
//   for (const chainID in chainToUnsupportedTokens) {
//     const tokens: Hex[] = [];
//     for (const token of chainToUnsupportedTokens[chainID]) {
//       const allowance = allowanceCache.gget({
//         chainID: Number(chainID),
//         owner: convertToEVMAddress(actualAddress),
//         spender: convertToEVMAddress(ephemeralAddress),
//         tokenAddress: token,
//       });
//       if (!allowance || allowance < 100000000n) {
//         tokens.push(token);
//       }
//     }
//     if (tokens.length) {
//       chainToUnsupportedTokens[chainID] = tokens;
//     } else {
//       delete chainToUnsupportedTokens[chainID];
//     }
//     const quotes = assetsGroupedByChain.get(Number(chainID));
//     const balancesOnChain = balances.filter(
//       (b) =>
//         b.chain_id === Number(chainID) &&
//         isEIP2612Supported(b.token_address, BigInt(chainID)),
//     );
//     const chain = chainList.getChainByID(Number(chainID));
//     if (!chain) {
//       throw new Error(`chain not found: ${chainID}`);
//     }
//     const publicClient = createPublicClient({
//       transport: http(chain.rpcUrls.default.http[0]),
//     });
//     const gasPrice = await publicClient.estimateFeesPerGas();
//     const gas =
//       APPROVE_GAS_LIMIT *
//       gasPrice.maxFeePerGas *
//       BigInt(chainToUnsupportedTokens[chainID].length) *
//       3n;
//     const nativeBalance = balances.find(
//       (b) =>
//         b.chain_id === Number(chainID) && equalFold(b.token_address, EADDRESS),
//     );
//     logger.debug("checkAndSupplyGasForApproval:2", {
//       gas,
//       gasPrice,
//       nativeBalance,
//     });
//     if (new Decimal(nativeBalance?.amount ?? 0).gte(gas)) {
//       data[Number(chainID)] = {
//         // Since txs.length == 0, amount and contractAddress should not get used, only unsupported token
//         amount: 0n,
//         contractAddress: "0x",
//         txs: [],
//         unsupportedTokens: chainToUnsupportedTokens[chainID],
//       };
//       continue;
//     }
//     let done = false;
//     // Split between sources included and excluded in source swaps
//     const split = splitBalanceByQuotes(balancesOnChain, quotes!);
//     logger.debug("checkAndSupplyGasForApproval:3", {
//       chainID,
//       split,
//     });
//     for (const s of split.excluded) {
//       const gasInToken = convertGasToToken(
//         {
//           contractAddress: s.token_address,
//           decimals: s.decimals,
//           priceUSD: s.priceUSD,
//         },
//         oraclePrices,
//         chain.id,
//         divDecimals(gas, chain.nativeCurrency.decimals),
//       );
//       logger.debug("checkAndSupplyGasForApproval:3:excluded", {
//         amount: s.amount,
//         gasInToken: gasInToken.toFixed(),
//         token: s,
//       });
//       if (gasInToken.lt(s.amount)) {
//         const res = await swapToGasQuote(
//           ephemeralAddress,
//           actualAddress,
//           new OmniversalChainID(Universe.ETHEREUM, chainID),
//           {
//             tokenAddress: EADDRESS_32_BYTES,
//           },
//           aggregators,
//           {
//             amount: mulDecimals(gasInToken, s.decimals),
//             decimals: s.decimals,
//             tokenAddress: convertTo32Bytes(s.token_address),
//           },
//         );
//         if (res.quote) {
//           const txs = getTxsFromQuote(
//             res.aggregator,
//             res.quote,
//             convertTo32Bytes(s.token_address),
//           );
//           data[Number(chainID)] = {
//             amount: mulDecimals(gasInToken, s.decimals),
//             contractAddress: s.token_address,
//             txs: [txs.approval!, txs.swap],
//             unsupportedTokens: chainToUnsupportedTokens[chainID],
//           };
//           done = true;
//           break;
//         }
//       }
//     }
//     if (!done) {
//       for (const s of split.included) {
//         const gasInToken = convertGasToToken(
//           {
//             contractAddress: s.token_address,
//             decimals: s.decimals,
//             priceUSD: s.priceUSD,
//           },
//           oraclePrices,
//           chain.id,
//           divDecimals(gas, chain.nativeCurrency.decimals),
//         );
//         logger.debug("checkAndSupplyGasForApproval:3:included", {
//           amount: s.amount,
//           gasInToken: gasInToken.toFixed(),
//         });
//         if (gasInToken.gte(s.amount)) {
//           const res = await swapToGasQuote(
//             ephemeralAddress,
//             actualAddress,
//             new OmniversalChainID(Universe.ETHEREUM, chainID),
//             {
//               tokenAddress: EADDRESS_32_BYTES,
//             },
//             aggregators,
//             {
//               amount: mulDecimals(gasInToken, s.decimals),
//               decimals: s.decimals,
//               tokenAddress: convertTo32Bytes(s.token_address),
//             },
//           );
//           if (res.quote) {
//             const txs = getTxsFromQuote(
//               res.aggregator,
//               res.quote,
//               convertTo32Bytes(s.token_address),
//             );
//             data[Number(chainID)] = {
//               amount: mulDecimals(gasInToken, s.decimals),
//               contractAddress: s.token_address,
//               txs: [txs.approval!, txs.swap],
//               unsupportedTokens: chainToUnsupportedTokens[chainID],
//             };
//             // since we had to use source swap token for gas
//             // TODO: Check if we have enough if we swap for gas otherwise throw error
//             done = true;
//             requote = true;
//             break;
//           }
//         }
//       }
//     }
//     if (!done) {
//       throw new Error(`could not swap token for gas on chain: ${chainID}`);
//     }
//   }
//   return {
//     blacklist,
//     data,
//     requote,
//   };
// };
// const convertGasToToken = (
//   token: { contractAddress: Hex; decimals: number; priceUSD: string },
//   oraclePrices: OraclePriceResponse,
//   destinationChainID: number,
//   gas: Decimal,
// ) => {
//   const gasTokenPerUSD =
//     oraclePrices
//       .find(
//         (rate) =>
//           rate.chainId === destinationChainID &&
//           equalFold(rate.tokenAddress, ZERO_ADDRESS),
//       )
//       ?.tokensPerUsd.toString() ?? "0";
//   const transferTokenPerUSD = Decimal.div(1, token.priceUSD);
//   logger.debug("convertGasToToken", {
//     gas: gas.toFixed(),
//     gasTokenPerUSD,
//     transferTokenPerUSD,
//   });
//   const gasInUSD = new Decimal(1).div(gasTokenPerUSD).mul(gas);
//   const totalRequired = new Decimal(gasInUSD).div(transferTokenPerUSD);
//   return totalRequired.toDP(token.decimals, Decimal.ROUND_CEIL);
// };
const getTxsFromQuote = (aggregator, quote, inputToken, createApproval = true) => {
    logger$c.debug('getTxsFromQuote', {
        aggregator,
        createApproval,
        inputToken,
        quote,
    });
    if (aggregator instanceof caCommon.LiFiAggregator) {
        const originalResponse = quote.originalResponse;
        const tx = originalResponse.transactionRequest;
        logger$c.debug('getTxsFromQuote', {
            'approval.amount': quote.inputAmount,
            'approval.target': originalResponse.estimate.approvalAddress,
            tx: tx,
            'tx.amount': quote.inputAmount,
            'tx.inputToken': inputToken,
            'tx.outputAmount': quote.outputAmountMinimum,
        });
        const val = {
            amount: quote.inputAmount,
            approval: null,
            inputToken,
            outputAmount: quote.outputAmountMinimum,
            swap: {
                data: tx.data,
                to: tx.to,
                value: BigInt(tx.value),
            },
        };
        if (createApproval) {
            val.approval = {
                data: packERC20Approve(originalResponse.estimate.approvalAddress, quote.inputAmount),
                to: convertToEVMAddress(inputToken),
                value: 0n,
            };
        }
        return val;
    }
    else if (aggregator instanceof caCommon.BebopAggregator) {
        const originalResponse = quote.originalResponse;
        const tx = originalResponse.quote.tx;
        logger$c.debug('getTxsFromQuote', {
            'approval.amount': quote.inputAmount,
            'approval.target': originalResponse.quote.approvalTarget,
            tx: tx,
            'tx.amount': quote.inputAmount,
            'tx.inputToken': inputToken,
            'tx.outputAmount': quote.outputAmountMinimum,
        });
        const val = {
            amount: quote.inputAmount,
            approval: null,
            inputToken,
            outputAmount: quote.outputAmountMinimum,
            swap: {
                data: tx.data,
                to: tx.to,
                value: BigInt(tx.value),
            },
        };
        if (createApproval) {
            val.approval = {
                data: packERC20Approve(originalResponse.quote.approvalTarget, quote.inputAmount),
                to: convertToEVMAddress(inputToken),
                value: 0n,
            };
        }
        return val;
    }
    throw new Error('Unknown aggregator');
};
const createSwapIntent = (sources, destination, chainList) => {
    const chain = chainList.getChainByID(destination.chainID);
    if (!chain) {
        throw new Error(`chain not found: ${destination.chainID}`);
    }
    const intent = {
        destination: {
            amount: destination.amount,
            chain: {
                id: chain.id,
                logo: chain.custom.icon,
                name: chain.name,
            },
            token: {
                contractAddress: destination.contractAddress,
                decimals: destination.decimals,
                symbol: destination.symbol,
            },
        },
        sources: [],
    };
    for (const source of sources) {
        const chain = chainList.getChainByID(source.chainID);
        if (!chain) {
            throw new Error(`chain not found: ${source.chainID}`);
        }
        intent.sources.push({
            amount: source.amount,
            chain: {
                id: chain.id,
                logo: chain.custom.icon,
                name: chain.name,
            },
            token: {
                contractAddress: source.contractAddress,
                decimals: source.decimals,
                symbol: source.symbol,
            },
        });
    }
    return intent;
};
const getTokenInfo = async (contractAddress, publicClient, chain) => {
    if (isNativeAddress(contractAddress)) {
        return {
            contractAddress: ZERO_ADDRESS,
            decimals: chain.nativeCurrency.decimals,
            symbol: chain.nativeCurrency.symbol,
        };
    }
    else {
        const [decimals, symbol] = await Promise.all([
            publicClient.readContract({
                abi: caCommon.ERC20ABI,
                address: contractAddress,
                functionName: 'decimals',
            }),
            publicClient.readContract({
                abi: caCommon.ERC20ABI,
                address: contractAddress,
                functionName: 'symbol',
            }),
        ]);
        return { contractAddress, decimals, symbol };
    }
};
const metadataAxios = caCommon.msgpackableAxios.create({
    baseURL: 'https://metadata-cerise.arcana.network',
});
const types = {
    Record: [
        { name: 'rff_id', type: 'uint256' },
        { name: 'has_xcs', type: 'bool' },
        { name: 'src', type: 'Transaction[]' },
        { name: 'dst', type: 'Transaction' },
    ],
    Transaction: [
        { name: 'univ', type: 'uint8' },
        { name: 'chid', type: 'bytes32' },
        { name: 'tx_hash', type: 'bytes32' },
        { name: 'swaps', type: 'XCSSwap[]' },
    ],
    XCSSwap: [
        { name: 'input_contract', type: 'bytes32' },
        { name: 'input_amt', type: 'uint256' },
        { name: 'input_decimals', type: 'uint8' },
        { name: 'output_contract', type: 'bytes32' },
        { name: 'output_amt', type: 'uint256' },
        { name: 'output_decimals', type: 'uint8' },
        { name: 'agg', type: 'uint8' },
    ],
};
const convertSwapMetaToSwap = (src) => {
    const swaps = src.swaps.map((s) => {
        return {
            inputAmount: viem.bytesToBigInt(s.input_amt),
            inputContract: convertToEVMAddress(s.input_contract),
            inputDecimals: s.input_decimals,
            outputAmount: viem.bytesToBigInt(s.output_amt),
            outputContract: convertToEVMAddress(s.output_contract),
            outputDecimals: s.output_decimals,
        };
    });
    return {
        chainId: viem.bytesToNumber(src.chid),
        swaps,
        txHash: viem.toHex(src.tx_hash),
    };
};
const convertMetadataToSwapResult = (metadata, baseURL) => {
    return {
        sourceSwaps: metadata.src.map(convertSwapMetaToSwap),
        explorerURL: getExplorerURL(baseURL, Long__default.default.fromBigInt(metadata.rff_id)),
        destinationSwap: convertSwapMetaToSwap(metadata.dst),
    };
};
function mswap2eip712swap(input) {
    return {
        agg: input.agg,
        input_amt: viem.bytesToBigInt(input.input_amt),
        input_contract: viem.toHex(input.input_contract),
        input_decimals: input.input_decimals,
        output_amt: viem.bytesToBigInt(input.output_amt),
        output_contract: viem.toHex(input.output_contract),
        output_decimals: input.output_decimals,
    };
}
const calculateValue = (amount, value, newAmount) => {
    return Decimal__default.default.div(value, amount).mul(newAmount);
};
function mtx2eip712tx(input) {
    return {
        chid: viem.toHex(input.chid),
        swaps: input.swaps.map(mswap2eip712swap),
        tx_hash: viem.toHex(input.tx_hash),
        univ: input.univ,
    };
}
const postSwap = async ({ metadata, wallet, }) => {
    logger$c.debug('metadata', {
        metadata,
        msg: {
            ...metadata,
            dst: mtx2eip712tx(metadata.dst),
            src: metadata.src.map(mtx2eip712tx),
        },
    });
    const signature = await wallet.signTypedData({
        domain: {
            chainId: 1n,
            name: 'CA Metadata',
            verifyingContract: ZERO_ADDRESS,
            version: '0.0.1',
        },
        message: {
            ...metadata,
            dst: mtx2eip712tx(metadata.dst),
            src: metadata.src.map(mtx2eip712tx),
        },
        primaryType: 'Record',
        types,
    });
    logger$c.debug('metadata', {
        data: {
            record: metadata,
            rff_id: Number(metadata.rff_id),
            sig: viem.toBytes(signature),
        },
        signature,
    });
    const rffIDN = Number(metadata.rff_id);
    // @ts-ignore
    delete metadata.rff_id;
    const res = await metadataAxios({
        data: {
            record: metadata,
            rff_id: rffIDN,
            sig: viem.toBytes(signature),
        },
        method: 'POST',
        url: `/api/v1/save-metadata/${rffIDN === 0 ? 'unlinked' : 'linked'}`,
    });
    return rffIDN === 0 ? res.data.value : rffIDN;
};
const createSweeperTxs = ({ cache, chainID, COTCurrencyID, receiver, sender, tokenAddress, }) => {
    const txs = [];
    if (!tokenAddress) {
        const currency = caCommon.ChaindataMap.get(new caCommon.OmniversalChainID(caCommon.Universe.ETHEREUM, chainID)).Currencies.find((c) => c.currencyID === COTCurrencyID);
        if (!currency) {
            throw new Error(`cot not found on chain ${chainID}`);
        }
        tokenAddress = convertToEVMAddress(currency.tokenAddress);
    }
    if (isNativeAddress(tokenAddress)) {
        const nativeAllowance = cache.getAllowance({
            chainID: Number(chainID),
            contractAddress: sender,
            owner: SWEEPER_ADDRESS,
            spender: SWEEPER_ADDRESS,
        });
        logger$c.debug('createSweeperTxs', {
            nativeAllowance,
        });
        if (!nativeAllowance || nativeAllowance === 0n) {
            txs.push({
                to: sender,
                data: viem.encodeFunctionData({
                    abi: CaliburABI,
                    functionName: 'approveNative',
                    args: [SWEEPER_ADDRESS, viem.maxUint256],
                }),
                value: 0n,
            });
        }
        txs.push({
            data: viem.encodeFunctionData({
                abi: SWEEP_ABI,
                args: [receiver],
                functionName: 'sweepERC7914',
            }),
            to: SWEEPER_ADDRESS,
            value: 0n,
        });
    }
    else {
        const sweeperAllowance = cache.getAllowance({
            chainID: Number(chainID),
            contractAddress: convertToEVMAddress(tokenAddress),
            owner: sender,
            spender: SWEEPER_ADDRESS,
        });
        if (!sweeperAllowance || sweeperAllowance === 0n) {
            txs.push({
                data: packERC20Approve(SWEEPER_ADDRESS),
                to: convertToEVMAddress(tokenAddress),
                value: 0n,
            });
        }
        txs.push({
            data: viem.encodeFunctionData({
                abi: SWEEP_ABI,
                args: [convertToEVMAddress(tokenAddress), receiver],
                functionName: 'sweepERC20',
            }),
            to: SWEEPER_ADDRESS,
            value: 0n,
        });
    }
    return txs;
};
const performDestinationSwap = async ({ actualAddress, cache, calls, chain, chainList, COT, emitter, ephemeralAddress, ephemeralWallet, hasDestinationSwap, publicClientList, vscDomain, }) => {
    try {
        // If destination swap token is COT then calls is an empty array,
        // sweeper txs will send from ephemeral -> eoa, other cases it sweeps the dust
        const hash = await esToolkit.retry(async () => {
            const sbcTx = await createSBCTxFromCalls({
                cache,
                calls: calls.concat(createSweeperTxs({
                    cache,
                    chainID: chain.id,
                    COTCurrencyID: COT,
                    receiver: actualAddress,
                    sender: ephemeralAddress,
                })),
                chainID: chain.id,
                ephemeralAddress,
                ephemeralWallet,
                publicClient: publicClientList.get(chain.id),
            });
            performance.mark('destination-swap-start');
            const ops = await vscSBCTx([sbcTx], vscDomain);
            performance.mark('destination-swap-end');
            if (hasDestinationSwap) {
                emitter.emit(DESTINATION_SWAP_HASH(ops[0], chainList));
            }
            performance.mark('destination-swap-mining-start');
            await waitForSBCTxReceipt(ops, chainList, publicClientList);
            performance.mark('destination-swap-mining-end');
            return ops[0][1];
        }, 2);
        return hash;
    }
    catch (e) {
        logger$c.error('destination swap failed twice, sweeping to eoa', e);
        await vscSBCTx([
            await createSBCTxFromCalls({
                cache,
                calls: createSweeperTxs({
                    cache,
                    chainID: chain.id,
                    COTCurrencyID: COT,
                    receiver: actualAddress,
                    sender: ephemeralAddress,
                }),
                chainID: chain.id,
                ephemeralAddress,
                ephemeralWallet,
                publicClient: publicClientList.get(chain.id),
            }),
        ], vscDomain).catch((e) => {
            logger$c.error('error during destination sweep', e);
        });
        throw e;
    }
};
const getSwapSupportedChains = (chainList) => {
    const chains = [];
    for (const c of chainData.keys()) {
        const chain = chainList.getChainByID(c);
        if (!chain) {
            continue;
        }
        const data = {
            id: chain.id,
            logo: chain.custom.icon,
            name: chain.name,
            tokens: [],
        };
        const tokens = chainData.get(c);
        if (!tokens) {
            continue;
        }
        tokens.forEach((t) => {
            if (t.PermitVariant !== caCommon.PermitVariant.Unsupported) {
                data.tokens.push({
                    contractAddress: convertToEVMAddress(t.TokenContractAddress),
                    decimals: t.TokenDecimals,
                    logo: '',
                    name: t.Name,
                    symbol: t.Name,
                });
            }
        });
        chains.push(data);
    }
    return chains;
};

var CurrencyID;
(function (CurrencyID) {
    CurrencyID[CurrencyID["AVAX"] = 5] = "AVAX";
    CurrencyID[CurrencyID["DAI"] = 6] = "DAI";
    CurrencyID[CurrencyID["ETH"] = 3] = "ETH";
    CurrencyID[CurrencyID["HYPE"] = 16] = "HYPE";
    CurrencyID[CurrencyID["KAIA"] = 17] = "KAIA";
    CurrencyID[CurrencyID["POL"] = 4] = "POL";
    CurrencyID[CurrencyID["USDC"] = 1] = "USDC";
    CurrencyID[CurrencyID["USDS"] = 99] = "USDS";
    CurrencyID[CurrencyID["USDT"] = 2] = "USDT";
    CurrencyID[CurrencyID["WETH"] = 7] = "WETH";
})(CurrencyID || (CurrencyID = {}));
const chainData = new Map([
    [
        10,
        [
            {
                CurrencyID: CurrencyID.USDC,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDC],
                PermitContractVersion: 2,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0xb2c639c533813f4aa9d7837caf62653d097ff85'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.USDT,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDT],
                PermitContractVersion: 0,
                PermitVariant: caCommon.PermitVariant.Unsupported,
                TokenContractAddress: convertTo32BytesHex('0x94b008aa00579c1307b0ef2c499ad98a8ce58e58'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.USDT,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDT],
                PermitContractVersion: 1,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0x01bff41798a0bcf287b996046ca68b395dbc1071'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.DAI,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.DAI],
                PermitContractVersion: 2,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0xda10009cbd5d07dd0cecc66161fc93d7c9000da1'),
                TokenDecimals: 18,
            },
            {
                CurrencyID: CurrencyID.ETH,
                IsGasToken: true,
                Name: CurrencyID[CurrencyID.ETH],
                PermitContractVersion: 0,
                PermitVariant: caCommon.PermitVariant.Unsupported,
                TokenContractAddress: convertTo32BytesHex(EADDRESS),
                TokenDecimals: 18,
            },
            {
                CurrencyID: CurrencyID.WETH,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.WETH],
                PermitContractVersion: 0,
                PermitVariant: caCommon.PermitVariant.Unsupported,
                TokenContractAddress: convertTo32BytesHex('0x4200000000000000000000000000000000000006'),
                TokenDecimals: 18,
            },
        ],
    ],
    [
        137,
        [
            {
                CurrencyID: CurrencyID.POL,
                IsGasToken: true,
                Name: CurrencyID[CurrencyID.POL],
                PermitContractVersion: 0,
                PermitVariant: caCommon.PermitVariant.Unsupported,
                TokenContractAddress: convertTo32BytesHex(EADDRESS),
                TokenDecimals: 18,
            },
            {
                CurrencyID: CurrencyID.USDC,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDC],
                PermitContractVersion: 2,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0x3c499c542cef5e3811e1192ce70d8cc03d5c3359'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.USDT,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDT],
                PermitContractVersion: 1,
                PermitVariant: caCommon.PermitVariant.PolygonEMT,
                TokenContractAddress: convertTo32BytesHex('0xc2132d05d31c914a87c6611c10748aeb04b58e8f'),
                TokenDecimals: 6,
            },
        ],
    ],
    [
        42161,
        [
            {
                CurrencyID: CurrencyID.WETH,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.WETH],
                PermitContractVersion: 1,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0x82af49447d8a07e3bd95bd0d56f35241523fbab1'),
                TokenDecimals: 18,
            },
            {
                CurrencyID: CurrencyID.USDC,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDC],
                PermitContractVersion: 2,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0xaf88d065e77c8cc2239327c5edb3a432268e5831'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.USDT,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDT],
                PermitContractVersion: 1,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.DAI,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.DAI],
                PermitContractVersion: 2,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0xda10009cbd5d07dd0cecc66161fc93d7c9000da1'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.ETH,
                IsGasToken: true,
                Name: CurrencyID[CurrencyID.ETH],
                PermitContractVersion: 0,
                PermitVariant: caCommon.PermitVariant.Unsupported,
                TokenContractAddress: convertTo32BytesHex(EADDRESS),
                TokenDecimals: 18,
            },
        ],
    ],
    [
        534352,
        [
            {
                CurrencyID: CurrencyID.WETH,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.WETH],
                PermitContractVersion: 1,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0x5300000000000000000000000000000000000004'),
                TokenDecimals: 18,
            },
            {
                CurrencyID: CurrencyID.USDC,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDC],
                PermitContractVersion: 2,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0x6efdbff2a14a7c8e15944d1f4a48f9f95f663a4'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.USDT,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDT],
                PermitContractVersion: 1,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0xf55bec9cafdbe8730f096aa55dad6d22d44099df'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.DAI,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.DAI],
                PermitContractVersion: 1,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0xcA77eB3fEFe3725Dc33bccB54eDEFc3D9f764f97'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.ETH,
                IsGasToken: true,
                Name: CurrencyID[CurrencyID.ETH],
                PermitContractVersion: 0,
                PermitVariant: caCommon.PermitVariant.Unsupported,
                TokenContractAddress: convertTo32BytesHex(EADDRESS),
                TokenDecimals: 18,
            },
        ],
    ],
    [
        8453,
        [
            {
                CurrencyID: CurrencyID.WETH,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.WETH],
                PermitContractVersion: 0,
                PermitVariant: caCommon.PermitVariant.Unsupported,
                TokenContractAddress: convertTo32BytesHex('0x4200000000000000000000000000000000000006'),
                TokenDecimals: 18,
            },
            {
                CurrencyID: CurrencyID.USDC,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDC],
                PermitContractVersion: 2,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.USDT,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDT],
                PermitContractVersion: 0,
                PermitVariant: caCommon.PermitVariant.Unsupported,
                TokenContractAddress: convertTo32BytesHex('0xfde4c96c8593536e31f229ea8f37b2ada2699bb2'),
                TokenDecimals: 6,
            },
            {
                CurrencyID: CurrencyID.USDS,
                IsGasToken: false,
                Name: CurrencyID[CurrencyID.USDS],
                PermitContractVersion: 1,
                PermitVariant: caCommon.PermitVariant.EIP2612Canonical,
                TokenContractAddress: convertTo32BytesHex('0x820C137fa70C8691f0e44Dc420a5e53c168921Dc'),
                TokenDecimals: 18,
            },
            {
                CurrencyID: CurrencyID.ETH,
                IsGasToken: true,
                Name: CurrencyID[CurrencyID.ETH],
                PermitContractVersion: 0,
                PermitVariant: caCommon.PermitVariant.Unsupported,
                TokenContractAddress: convertTo32BytesHex(EADDRESS),
                TokenDecimals: 18,
            },
        ],
    ],
]);
const filterSupportedTokens = (tokens) => {
    return tokens.filter((t) => {
        const d = chainData.get(t.chainID);
        if (!d) {
            return false;
        }
        const token = d.find((dt) => equalFold(dt.TokenContractAddress, t.tokenAddress));
        if (!token) {
            return false;
        }
        if (token.IsGasToken) {
            return true;
        }
        // if (token.PermitVariant === PermitVariant.Unsupported) {
        //   return false;
        // }
        return true;
    });
};
const getTokenVersion = (tokenAddress) => {
    for (const [, tokens] of chainData.entries()) {
        const t = tokens.find((t) => equalFold(convertTo32BytesHex(tokenAddress), t.TokenContractAddress));
        if (t) {
            return { variant: t.PermitVariant, version: t.PermitContractVersion };
        }
    }
    throw new Error('token not available or has no version');
};
const getTokenDecimals = (chainID, contractAddress) => {
    const cData = chainData.get(Number(chainID));
    if (!cData) {
        throw new Error(`chain data not found for chain:${chainID}`);
    }
    const token = cData.find((c) => equalFold(utils.toHex(contractAddress), c.TokenContractAddress));
    if (!token) {
        throw new Error(`token not found: ${utils.toHex(contractAddress)}`);
    }
    return {
        decimals: token.TokenDecimals,
        symbol: CurrencyID[token.CurrencyID],
    };
};

const ErrorChainDataNotFound = new Error('Chain data not found.');
const ErrorCOTNotFound = (chainID) => new Error(`COT not found on chain: ${chainID}`);
const ErrorTokenNotFound = (address, chainID) => new Error(`Token(${address}) not found on chain: ${chainID}`);
const ErrorInsufficientBalance = (available, required) => new Error(`Insufficient balance: available:${available}, required:${required}.`);

const logger$b = getLogger();
const createEmptyIntent = ({ chainID, decimals, }) => ({
    allSources: [],
    destination: {
        amount: new Decimal__default.default(0),
        chainID,
        decimals,
        gas: 0n,
        tokenContract: '0x',
        universe: caCommon.Universe.ETHEREUM,
    },
    fees: {
        caGas: '0',
        collection: '0',
        fulfilment: '0',
        gasSupplied: '0',
        protocol: '0',
        solver: '0',
    },
    isAvailableBalanceInsufficient: false,
    sources: [],
});
const createIntent = ({ assets, feeStore, output, }) => {
    const eoaToEphemeralCalls = {};
    const intent = createEmptyIntent({ chainID: output.chainID, decimals: output.decimals });
    let borrow = output.amount;
    intent.destination.amount = borrow;
    intent.destination.tokenContract = output.tokenAddress;
    const protocolFee = feeStore.calculateProtocolFee(borrow);
    borrow = borrow.add(protocolFee);
    intent.fees.protocol = protocolFee.toFixed();
    const fulfilmentFee = feeStore.calculateFulfilmentFee({
        decimals: output.decimals,
        destinationChainID: output.chainID,
        destinationTokenAddress: output.tokenAddress,
    });
    borrow = borrow.add(fulfilmentFee);
    intent.fees.fulfilment = fulfilmentFee.toFixed();
    let accountedBalance = new Decimal__default.default(0);
    logger$b.debug('createBridgeRFF:1', {
        assets: assets.map((i) => ({
            ...i,
            eoaBalance: i.eoaBalance.toFixed(),
            ephemeralBalance: i.ephemeralBalance.toFixed(),
        })),
        borrow: borrow.toFixed(),
        fulfilmentFee: fulfilmentFee.toFixed(),
        protocolFee: protocolFee.toFixed(),
    });
    for (const asset of assets) {
        if (asset.chainID === output.chainID ||
            Decimal__default.default.add(asset.eoaBalance, asset.ephemeralBalance).lte(0)) {
            continue;
        }
        if (accountedBalance.gte(borrow)) {
            break;
        }
        const unaccountedBalance = borrow.minus(accountedBalance);
        const estimatedBorrowFromThisChain = Decimal__default.default.add(asset.eoaBalance.toString(), asset.ephemeralBalance.toString()).lte(unaccountedBalance)
            ? Decimal__default.default.add(asset.eoaBalance.toString(), asset.ephemeralBalance.toString())
            : unaccountedBalance;
        const solverFee = feeStore.calculateSolverFee({
            borrowAmount: estimatedBorrowFromThisChain,
            decimals: asset.decimals,
            destinationChainID: output.chainID,
            destinationTokenAddress: output.tokenAddress,
            sourceChainID: asset.chainID,
            sourceTokenAddress: asset.contractAddress,
        });
        intent.fees.solver = solverFee.add(intent.fees.solver).toFixed();
        borrow = borrow.add(solverFee);
        const unaccountedBalance2 = borrow.minus(accountedBalance);
        let borrowFromThisChain = new Decimal__default.default(0);
        if (Decimal__default.default.add(asset.eoaBalance, asset.ephemeralBalance).lte(unaccountedBalance2)) {
            logger$b.debug('createBridgeRFF:2.1', {
                assetBalance: Decimal__default.default.add(asset.eoaBalance.toString(), asset.ephemeralBalance.toString()).toFixed(),
                unaccountedBalance: unaccountedBalance2.toFixed(),
            });
            borrowFromThisChain = Decimal__default.default.add(asset.eoaBalance.toString(), asset.ephemeralBalance.toString());
            // Create allowance and deposit tx for (asset.eoaBalance) from usdc(eoa) -> usdc(eph)
            if (!asset.eoaBalance.eq(0)) {
                eoaToEphemeralCalls[asset.chainID] = {
                    amount: mulDecimals(asset.eoaBalance, asset.decimals),
                    decimals: asset.decimals,
                    tokenAddress: asset.contractAddress,
                };
            }
        }
        else {
            borrowFromThisChain = unaccountedBalance2;
            if (borrowFromThisChain.gt(asset.ephemeralBalance.toString())) {
                logger$b.debug('createBridgeRFF:2.2', {
                    assetEphemeral: asset.ephemeralBalance,
                    borrowFromThisChain: borrowFromThisChain.toFixed(),
                });
                eoaToEphemeralCalls[asset.chainID] = {
                    amount: mulDecimals(borrowFromThisChain.minus(asset.ephemeralBalance.toString()), asset.decimals),
                    decimals: asset.decimals,
                    tokenAddress: asset.contractAddress,
                };
            }
        }
        intent.sources.push({
            amount: borrowFromThisChain,
            chainID: asset.chainID,
            tokenContract: asset.contractAddress,
            universe: caCommon.Universe.ETHEREUM,
        });
        accountedBalance = accountedBalance.add(borrowFromThisChain);
    }
    if (accountedBalance < borrow) {
        intent.isAvailableBalanceInsufficient = true;
    }
    return { eoaToEphemeralCalls, intent };
};
const createBridgeRFF = async ({ config, input, output, }) => {
    logger$b.debug('createBridgeRFF', { input, output });
    const feeStore = await getFeeStore(config.network.GRPC_URL);
    const depositCalls = {};
    const { eoaToEphemeralCalls, intent } = createIntent({
        assets: input.assets,
        feeStore,
        output,
    });
    if (intent.isAvailableBalanceInsufficient) {
        throw ErrorInsufficientBalance$1;
    }
    const { msgBasicCosmos, omniversalRFF, signatureData, sources } = await createRFFromIntent(intent, {
        chainList: config.chainList,
        cosmos: {
            address: config.cosmos.address,
            client: config.cosmos.wallet,
        },
        evm: {
            address: config.evm.address,
            client: config.evm.client,
        },
    }, caCommon.Universe.ETHEREUM);
    logger$b.debug('createIntent', { intent });
    let intentID = Long__default.default.fromNumber(0);
    const createRFF = async () => {
        intentID = await cosmosCreateRFF({
            address: config.cosmos.address,
            cosmosURL: config.network.COSMOS_URL,
            msg: msgBasicCosmos,
            wallet: config.cosmos.wallet,
        });
        storeIntentHashToStore(config.evm.address, intentID.toNumber());
        const doubleCheckTxMap = {};
        omniversalRFF.protobufRFF.sources.map((s) => {
            doubleCheckTxMap[viem.bytesToNumber(s.chainID)] = createDoubleCheckTx(s.chainID, config.cosmos, intentID, config.network.COSMOS_URL);
        });
        return {
            createDoubleCheckTx: async () => {
                try {
                    for (const k in doubleCheckTxMap) {
                        logger$b.debug('Starting double check tx', { chain: k });
                        await doubleCheckTxMap[k]();
                    }
                }
                catch (error) {
                    logger$b.error('Error during double check tx', error);
                }
            },
            intentID,
        };
    };
    const allowances = await getAllowances(intent.sources.map((s) => ({
        chainID: s.chainID,
        tokenContract: s.tokenContract,
    })), config.evm.address, config.chainList);
    for (const [index, source] of sources.entries()) {
        const evmSignatureData = signatureData.find((s) => s.universe === caCommon.Universe.ETHEREUM);
        if (!evmSignatureData) {
            throw new Error('Unknown signature type');
        }
        const chain = config.chainList.getChainByID(Number(source.chainID));
        if (!chain) {
            throw new Error('chain not found');
        }
        const allowance = allowances[Number(source.chainID)];
        logger$b.debug('allowances', { allowance, chainID: Number(source.chainID) });
        if (allowance == null) {
            throw new Error('Allowance not applicable');
        }
        const tx = [];
        if (allowance < source.value) {
            const allowanceTx = {
                data: packERC20Approve(config.chainList.getVaultContractAddress(Number(source.chainID))),
                to: convertAddressByUniverse(source.tokenAddress, caCommon.Universe.ETHEREUM),
                value: 0n,
            };
            tx.push(allowanceTx);
        }
        console.log({
            argsForRFFDeposit: [
                omniversalRFF.asEVMRFF(),
                viem.toHex(evmSignatureData.signature),
                BigInt(index),
            ],
        });
        tx.push({
            data: viem.encodeFunctionData({
                abi: caCommon.EVMVaultABI,
                args: [omniversalRFF.asEVMRFF(), viem.toHex(evmSignatureData.signature), BigInt(index)],
                functionName: 'deposit',
            }),
            to: config.chainList.getVaultContractAddress(Number(source.chainID)),
            value: 0n,
        });
        depositCalls[Number(source.chainID)] = {
            amount: source.value,
            tokenAddress: convertAddressByUniverse(source.tokenAddress, source.universe),
            tx: tx,
        };
    }
    const chain = config.chainList.getChainByID(Number(output.chainID));
    if (!chain) {
        throw new Error('Unknown destination chain');
    }
    const ws = viem.webSocket(chain.rpcUrls.default.webSocket[0]);
    const pc = viem.createPublicClient({
        transport: ws,
    });
    const waitForFill = () => {
        const s = signatureData.find((s) => s.universe === caCommon.Universe.ETHEREUM);
        if (!s) {
            throw new Error('Unknown signature type');
        }
        logger$b.debug(`Waiting for fill: ${intentID}`);
        const r = {
            filled: false,
            intentID,
            promise: evmWaitForFill(config.chainList.getVaultContractAddress(chain.id), pc, s.requestHash, intentID, config.network.GRPC_URL, config.network.COSMOS_URL),
        };
        r.promise.then(() => {
            r.filled = true;
            removeIntentHashFromStore(config.evm.address, r.intentID);
        });
        return r;
    };
    return {
        createRFF,
        depositCalls,
        eoaToEphemeralCalls,
        intent,
        waitForFill,
    };
};
const createDoubleCheckTx = (chainID, cosmos, intentID, cosmosURL) => {
    const msg = caCommon.MsgDoubleCheckTx.create({
        creator: cosmos.address,
        packet: {
            $case: 'depositPacket',
            value: caCommon.DepositVEPacket.create({
                gasRefunded: false,
                id: intentID,
            }),
        },
        txChainID: chainID,
        txUniverse: caCommon.Universe.ETHEREUM,
    });
    return () => {
        return cosmosCreateDoubleCheckTx({
            address: cosmos.address,
            cosmosURL,
            msg,
            wallet: cosmos.wallet,
        });
    };
};

const logger$a = getLogger();
const getBalances = async (input) => {
    const removeTransferFee = input.removeTransferFee ?? false;
    const filter = input.filter ?? true;
    const [ankrBalances, evmBalances, fuelBalances] = await Promise.all([
        input.networkHint === caCommon.Environment.FOLLY
            ? Promise.resolve([])
            : getAnkrBalances(input.evmAddress, input.chainList, removeTransferFee),
        getEVMBalancesForAddress(input.vscDomain, input.evmAddress),
        input.fuelAddress
            ? getFuelBalancesForAddress(input.vscDomain, input.fuelAddress)
            : Promise.resolve([]),
    ]);
    const assets = balancesToAssets(ankrBalances, evmBalances, fuelBalances, input.chainList);
    let balances = toFlatBalance(assets);
    if (filter) {
        balances = filterSupportedTokens(balances);
    }
    logger$a.debug('getBalances', {
        assets,
        balances,
        removeTransferFee,
    });
    return { assets, balances };
};
const determineSwapRoute = async (input, options) => {
    logger$a.debug('determineSwapRoute', {
        input,
        options,
    });
    if (input.mode === commons.SwapMode.EXACT_OUT) {
        return _exactOutRoute(input.data, options);
    }
    else {
        return _exactInRoute(input.data, options);
    }
};
const _exactOutRoute = async (input, params) => {
    const [feeStore, { assets, balances }, oraclePrices] = await Promise.all([
        getFeeStore(params.networkConfig.GRPC_URL),
        getBalances({
            networkHint: params.networkConfig.NETWORK_HINT,
            evmAddress: params.address.eoa,
            chainList: params.chainList,
            removeTransferFee: true,
            filter: true,
            vscDomain: params.networkConfig.VSC_DOMAIN,
        }),
        fetchPriceOracle(params.networkConfig.GRPC_URL),
    ]);
    // Any existing COT balance on dst chain
    let dstEOAToEphTx = null;
    logger$a.debug('determineSwapRoute', { assets, balances, input });
    const userAddressInBytes = convertTo32Bytes(params.address.ephemeral);
    const dstOmniversalChainID = new caCommon.OmniversalChainID(caCommon.Universe.ETHEREUM, input.toChainId);
    logger$a.debug('determineSwapRoute:destinationSwapInput', {
        dstOmniversalChainID,
        s: {
            amount: BigInt(input.toAmount),
            tokenAddress: viem.toBytes(input.toTokenAddress),
        },
        userAddressInBytes,
    });
    const dstChainDataMap = caCommon.ChaindataMap.get(dstOmniversalChainID);
    if (!dstChainDataMap) {
        throw ErrorChainDataNotFound;
    }
    const cotSymbol = caCommon.CurrencyID[params.cotCurrencyID];
    const dstChainCOT = dstChainDataMap.Currencies.find((c) => c.currencyID === params.cotCurrencyID);
    if (!dstChainCOT) {
        throw ErrorCOTNotFound(input.toChainId);
    }
    const dstChainCOTAddress = convertToEVMAddress(dstChainCOT.tokenAddress);
    const dstChainCOTBalance = balances.find((b) => b.chainID === Number(input.toChainId) &&
        equalFold(convertToEVMAddress(b.tokenAddress), dstChainCOTAddress));
    const getDDS = async () => {
        let dds = {
            aggregator: params.aggregators[0],
            inputAmount: divDecimals(input.toAmount, dstChainCOT.decimals),
            outputAmount: 0n,
            quote: null,
        };
        // If output token is not COT then only destination swap should exist
        if (!equalFold(input.toTokenAddress, dstChainCOTAddress)) {
            dds = await caCommon.determineDestinationSwaps(userAddressInBytes, null, dstOmniversalChainID, {
                amount: BigInt(input.toAmount),
                tokenAddress: convertTo32Bytes(input.toTokenAddress),
            }, params.aggregators);
        }
        const createdAt = Date.now();
        // If destination has COT then need to send it to ephemeral so that it can be used in swap
        if (new Decimal__default.default(dstChainCOTBalance?.amount ?? 0).gt(0)) {
            dstEOAToEphTx = {
                amount: mulDecimals(dstChainCOTBalance?.amount ?? 0, dstChainCOTBalance?.decimals ?? 0),
                contractAddress: dstChainCOTAddress,
            };
        }
        return {
            ...dds,
            createdAt,
            dstChainCOT: dstChainCOT,
            dstEOAToEphTx,
            inputAmountWithBuffer: dds.inputAmount
                .mul(1.02)
                .toDP(dstChainCOT.decimals, Decimal__default.default.ROUND_CEIL),
            req: {
                chain: dstOmniversalChainID,
                inputToken: dstChainCOT.tokenAddress,
                outputToken: viem.toBytes(input.toTokenAddress),
            },
        };
    };
    const destinationSwap = await getDDS();
    logger$a.debug('destination swaps', destinationSwap);
    const cotAsset = assets.find((asset) => {
        return asset.abstracted && equalFold(asset.symbol, cotSymbol);
    });
    const dstSwapInputAmountInDecimal = destinationSwap.inputAmount
        .mul(1.02)
        .toDP(dstChainCOT.decimals, Decimal__default.default.ROUND_CEIL);
    logger$a.debug('determineSwapRoute:3', {
        cotAsset,
        dstChainCOTAddress,
        dstChainCOTBalance,
    });
    const cotTotalBalance = new Decimal__default.default(cotAsset?.balance ?? '0');
    const fulfilmentFee = feeStore.calculateFulfilmentFee({
        decimals: dstChainCOT.decimals,
        destinationChainID: Number(input.toChainId),
        destinationTokenAddress: dstChainCOTAddress,
    });
    const fees = fulfilmentFee;
    logger$a.debug('determineSwapRoute:4', {
        cotAsset,
        cotTotalBalance: cotTotalBalance.toFixed(),
        diff: fees.toFixed(),
        dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),
    });
    console.log({ cotAsset, dstChainCOTBalance });
    let sourceSwaps = [];
    let sourceSwapsRequired = false;
    if (!dstChainCOTBalance) {
        sourceSwapsRequired = true;
    }
    if (!cotAsset || new Decimal__default.default(cotAsset.balance).lt(dstSwapInputAmountInDecimal)) {
        sourceSwapsRequired = true;
    }
    if (sourceSwapsRequired) {
        sourceSwaps = await caCommon.autoSelectSources(userAddressInBytes, balances.map((balance) => ({
            amount: mulDecimals(balance.amount, balance.decimals),
            chainID: new caCommon.OmniversalChainID(balance.universe, balance.chainID),
            tokenAddress: viem.toBytes(balance.tokenAddress),
            value: balance.value,
        })), dstSwapInputAmountInDecimal
            .add(fees)
            .mul(1.01)
            .minus(cotAsset?.balance ?? '0'), params.aggregators, feeStore.data.fee.collection.map((f) => ({
            ...f,
            chainID: convertTo32Bytes(Number(f.chainID)),
            fee: convertTo32Bytes(BigInt(f.fee)),
            tokenAddress: convertTo32Bytes(f.tokenAddress),
        })));
    }
    const sourceSwapCreationTime = Date.now();
    console.log({
        dstChainCOTBalance,
        inequality: new Decimal__default.default(dstChainCOTBalance?.amount ?? 0).lt(dstSwapInputAmountInDecimal.add(fees)),
    });
    let bridgeInput = null;
    const bridgeAssets = cotAsset?.breakdown.map((b) => ({
        chainID: b.chain.id,
        contractAddress: b.contractAddress,
        decimals: b.decimals,
        eoaBalance: new Decimal__default.default(b.balance),
        ephemeralBalance: new Decimal__default.default(0),
    })) ?? [];
    if (new Decimal__default.default(dstChainCOTBalance?.amount ?? 0n).lt(dstSwapInputAmountInDecimal.add(fees))) {
        // If swap happens to COT on destination chain
        // then that amount doesn't needs to be in RFF
        let dstCOTSwapAmount = new Decimal__default.default(0);
        for (const swap of sourceSwaps) {
            const bAsset = bridgeAssets.find((ba) => {
                return (ba.chainID === Number(swap.req.chain.chainID) &&
                    equalFold(ba.contractAddress, convertToEVMAddress(swap.req.outputToken)));
            });
            const token = params.chainList.getTokenByAddress(Number(swap.req.chain.chainID), convertToEVMAddress(swap.req.outputToken));
            if (!token) {
                throw ErrorTokenNotFound(convertToEVMAddress(swap.req.outputToken), Number(swap.req.chain.chainID));
            }
            const outputAmount = swap.quote.outputAmountMinimum;
            if (bAsset) {
                bAsset.ephemeralBalance = Decimal__default.default.add(bAsset.ephemeralBalance, divDecimals(outputAmount, token.decimals));
            }
            else {
                bridgeAssets.push({
                    chainID: Number(swap.req.chain.chainID),
                    contractAddress: convertToEVMAddress(swap.req.outputToken),
                    decimals: token.decimals,
                    eoaBalance: new Decimal__default.default(0),
                    ephemeralBalance: divDecimals(outputAmount, token.decimals),
                });
            }
            if (Number(swap.req.chain.chainID) === input.toChainId) {
                dstCOTSwapAmount = dstCOTSwapAmount.plus(divDecimals(outputAmount, token.decimals));
            }
            logger$a.debug('determineSwapRoute:sourceSwap', {
                outputAmountLikely: swap.quote.outputAmountLikely ?? 0,
                outputAmountMinimum: swap.quote.outputAmountMinimum ?? 0,
                swap,
            });
        }
        // If COT from source swap at destination chain + existing COT accounts
        // for requirement then RFF shouldn't be created
        if (new Decimal__default.default(dstChainCOTBalance?.amount ?? 0)
            .plus(dstCOTSwapAmount)
            .lt(dstSwapInputAmountInDecimal)) {
            bridgeInput = {
                amount: dstSwapInputAmountInDecimal
                    .minus(dstChainCOTBalance?.amount ?? 0)
                    .minus(dstCOTSwapAmount),
                assets: bridgeAssets,
                chainID: input.toChainId,
                decimals: dstChainCOT.decimals,
                tokenAddress: convertToEVMAddress(dstChainCOT.tokenAddress),
            };
        }
    }
    const assetsUsed = [];
    for (const swap of sourceSwaps) {
        const { decimals, symbol } = getTokenDecimals(Number(swap.req.chain.chainID), swap.req.inputToken);
        assetsUsed.push({
            amount: divDecimals(swap.quote.inputAmount, decimals).toFixed(),
            chainID: Number(swap.req.chain.chainID),
            contractAddress: convertToEVMAddress(swap.req.inputToken),
            decimals,
            symbol,
        });
    }
    if (bridgeInput) {
        const { eoaToEphemeralCalls } = createIntent({
            assets: bridgeAssets,
            feeStore,
            output: bridgeInput,
        });
        for (const chain in eoaToEphemeralCalls) {
            assetsUsed.push({
                amount: divDecimals(eoaToEphemeralCalls[chain].amount, eoaToEphemeralCalls[chain].decimals).toFixed(),
                chainID: Number(chain),
                contractAddress: eoaToEphemeralCalls[chain].tokenAddress,
                decimals: eoaToEphemeralCalls[chain].decimals,
                symbol: cotSymbol,
            });
        }
    }
    return {
        aggregators: params.aggregators,
        assetsUsed,
        balances,
        bridgeInput,
        cotSymbol,
        destinationSwap,
        getDDS,
        oraclePrices,
        sourceSwapCreationTime,
        sourceSwaps,
    };
};
const calculateMaxBridgeFees = ({ assets, feeStore, dst, }) => {
    const borrow = assets.reduce((accumulator, asset) => {
        return accumulator.add(Decimal__default.default.add(asset.eoaBalance, asset.ephemeralBalance));
    }, new Decimal__default.default(0));
    const protocolFee = feeStore.calculateProtocolFee(new Decimal__default.default(borrow));
    let borrowWithFee = borrow.add(protocolFee);
    const fulfilmentFee = feeStore.calculateFulfilmentFee({
        decimals: dst.decimals,
        destinationChainID: dst.chainId,
        destinationTokenAddress: dst.tokenAddress,
    });
    borrowWithFee = borrowWithFee.add(fulfilmentFee);
    logger$a.debug('calculateMaxBridgeFees:1', {
        borrow: borrow.toFixed(),
        protocolFee: protocolFee.toFixed(),
        fulfilmentFee: fulfilmentFee.toFixed(),
        borrowWithFee: borrowWithFee.toFixed(),
    });
    for (const asset of assets) {
        const solverFee = feeStore.calculateSolverFee({
            borrowAmount: Decimal__default.default.add(asset.eoaBalance, asset.ephemeralBalance),
            decimals: asset.decimals,
            destinationChainID: dst.chainId,
            destinationTokenAddress: dst.tokenAddress,
            sourceChainID: asset.chainID,
            sourceTokenAddress: convertToEVMAddress(asset.contractAddress),
        });
        borrowWithFee = borrowWithFee.add(solverFee);
        logger$a.debug('calculateMaxBridgeFees:2', {
            borrow: borrow.toFixed(),
            borrowWithFee: borrowWithFee.toFixed(),
            solverFee: solverFee.toFixed(),
        });
    }
    return borrowWithFee.minus(borrow);
};
const _exactInRoute = async (input, params) => {
    logger$a.debug('exactInRoute', {
        input,
        params,
    });
    const [feeStore, balanceResponse, oraclePrices] = await Promise.all([
        getFeeStore(params.networkConfig.GRPC_URL),
        getBalances({
            networkHint: params.networkConfig.NETWORK_HINT,
            evmAddress: params.address.eoa,
            chainList: params.chainList,
            removeTransferFee: true,
            vscDomain: params.networkConfig.VSC_DOMAIN,
        }),
        fetchPriceOracle(params.networkConfig.GRPC_URL),
    ]);
    let { balances } = balanceResponse;
    logger$a.debug('ExactIN:1', {
        balances,
    });
    const assetsUsed = [];
    let srcBalances = [];
    if (input.from) {
        for (const f of input.from) {
            const srcBalance = balances.find((b) => {
                logger$a.debug('ExactIN:2:input.src', {
                    a: b.tokenAddress,
                    b: convertTo32BytesHex(f.tokenAddress),
                });
                // We are keeping ZERO_ADDRESS as EAddress so have to make the comparisonAddr like this
                let comparisonTokenAddress = convertTo32BytesHex(f.tokenAddress);
                if (equalFold(comparisonTokenAddress, ZERO_ADDRESS)) {
                    comparisonTokenAddress = EADDRESS;
                }
                return equalFold(b.tokenAddress, comparisonTokenAddress) && f.chainId === b.chainID;
            });
            if (!srcBalance) {
                throw ErrorInsufficientBalance(f.amount.toString(), '0');
            }
            const requiredBalance = divDecimals(f.amount, srcBalance.decimals);
            if (requiredBalance.gt(srcBalance.amount)) {
                throw ErrorInsufficientBalance(srcBalance.amount, requiredBalance.toFixed());
            }
            srcBalances.push({
                ...srcBalance,
                amount: requiredBalance.toFixed(),
                value: calculateValue(srcBalance.amount, srcBalance.value, f.amount).toNumber(),
            });
            assetsUsed.push({
                amount: requiredBalance.toFixed(),
                chainID: srcBalance.chainID,
                contractAddress: srcBalance.tokenAddress,
                decimals: srcBalance.decimals,
                symbol: srcBalance.symbol,
            });
        }
        // } else {
        //   throw new Error('should have gone to single source swap route');
        // }
    }
    else {
        srcBalances = balances;
    }
    logger$a.debug('ExactIN:3', {
        srcBalances,
        assetsUsed,
    });
    const userAddressInBytes = convertTo32Bytes(params.address.ephemeral);
    const dstOmniversalChainID = new caCommon.OmniversalChainID(caCommon.Universe.ETHEREUM, input.toChainId);
    const dstChainDataMap = caCommon.ChaindataMap.get(dstOmniversalChainID);
    if (!dstChainDataMap) {
        throw new Error('chaindataMap not found');
    }
    const cotSymbol = caCommon.CurrencyID[params.cotCurrencyID];
    const dstChainCOT = dstChainDataMap.Currencies.find((c) => c.currencyID === params.cotCurrencyID);
    if (!dstChainCOT) {
        throw ErrorCOTNotFound(input.toChainId);
    }
    const dstChainCOTAddress = convertToEVMAddress(dstChainCOT.tokenAddress);
    const bridgeAssets = [];
    // Filter out COT's in sources
    const cotSources = [];
    let cotCombinedBalance = new Decimal__default.default(0);
    for (const source of srcBalances) {
        const cot = caCommon.ChaindataMap.get(new caCommon.OmniversalChainID(caCommon.Universe.ETHEREUM, source.chainID))?.Currencies.find((c) => c.currencyID === params.cotCurrencyID);
        if (cot &&
            equalFold(convertToEVMAddress(source.tokenAddress), convertToEVMAddress(cot.tokenAddress))) {
            cotSources.push(source);
            cotCombinedBalance = cotCombinedBalance.add(source.amount);
            bridgeAssets.push({
                chainID: source.chainID,
                contractAddress: convertToEVMAddress(source.tokenAddress),
                decimals: source.decimals,
                eoaBalance: new Decimal__default.default(source.amount),
                ephemeralBalance: new Decimal__default.default(0),
            });
        }
    }
    logger$a.debug('ExactIN:4', {
        cotCombinedBalance,
        cotSources,
        bridgeAssets,
    });
    // Add COT's to bridge asset eoaBalance
    // Check if source swap is required (if all source balances are not COT currencyID)
    const isSrcSwapRequired = cotSources.length !== srcBalances.length;
    // Check if bridge is required (if all source balances are not on destination chain)
    const isBridgeRequired = !srcBalances.every((b) => b.chainID === input.toChainId);
    logger$a.debug('ExactIN:5', {
        isSrcSwapRequired,
        isBridgeRequired,
    });
    let sourceSwaps = [];
    if (isSrcSwapRequired) {
        const response = await caCommon.liquidateInputHoldings(userAddressInBytes, srcBalances.map((b) => ({
            amount: mulDecimals(b.amount, b.decimals),
            chainID: new caCommon.OmniversalChainID(b.universe, b.chainID),
            tokenAddress: viem.toBytes(b.tokenAddress),
            value: b.value,
        })), params.aggregators, feeStore.data.fee.collection.map((f) => ({
            chainID: convertTo32Bytes(Number(f.chainID)),
            fee: convertTo32Bytes(BigInt(f.fee)),
            tokenAddress: convertTo32Bytes(f.tokenAddress),
            universe: f.universe,
        })));
        sourceSwaps = response.quotes;
    }
    const sourceSwapCreationTime = Date.now();
    let swapCombinedBalance = new Decimal__default.default(0);
    for (const swap of sourceSwaps) {
        const outputTokenAddress = convertToEVMAddress(swap.req.outputToken);
        const token = params.chainList.getTokenByAddress(Number(swap.req.chain.chainID), outputTokenAddress);
        if (!token) {
            throw ErrorTokenNotFound(outputTokenAddress, Number(swap.req.chain.chainID));
        }
        const bridgeAsset = bridgeAssets.find((b) => equalFold(b.contractAddress, outputTokenAddress));
        const outputAmountInDecimal = divDecimals(swap.quote.outputAmountMinimum, token.decimals);
        if (bridgeAsset) {
            bridgeAsset.ephemeralBalance = bridgeAsset.ephemeralBalance.add(outputAmountInDecimal);
        }
        else {
            bridgeAssets.push({
                chainID: Number(swap.req.chain.chainID),
                contractAddress: outputTokenAddress,
                decimals: token.decimals,
                eoaBalance: new Decimal__default.default(0),
                ephemeralBalance: outputAmountInDecimal,
            });
        }
        swapCombinedBalance = swapCombinedBalance.add(outputAmountInDecimal);
    }
    let dstSwapInputAmountInDecimal = Decimal__default.default.add(cotCombinedBalance, swapCombinedBalance);
    logger$a.debug('ExactIN:6', {
        dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),
        bridgeAssets,
    });
    let bridgeInput = null;
    if (isBridgeRequired) {
        const maxFee = calculateMaxBridgeFees({
            assets: bridgeAssets,
            dst: {
                chainId: input.toChainId,
                tokenAddress: dstChainCOTAddress,
                decimals: dstChainCOT.decimals,
            },
            feeStore,
        });
        dstSwapInputAmountInDecimal = dstSwapInputAmountInDecimal.minus(maxFee).mul(0.98);
        logger$a.debug('ExactIN:7', {
            dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),
            maxFee: maxFee.toFixed(),
        });
        bridgeInput = {
            amount: dstSwapInputAmountInDecimal,
            assets: bridgeAssets,
            chainID: input.toChainId,
            decimals: dstChainCOT.decimals,
            tokenAddress: convertToEVMAddress(dstChainCOT.tokenAddress),
        };
    }
    logger$a.debug('beforeDDS: ExactIN', {
        dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),
    });
    const getDDS = async () => {
        let dds = {
            aggregator: params.aggregators[0],
            inputAmount: dstSwapInputAmountInDecimal,
            outputAmount: mulDecimals(dstSwapInputAmountInDecimal, dstChainCOT.decimals),
            quote: null,
        };
        logger$a.debug('getDDS: ExactIN: Before', {
            dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),
        });
        dstSwapInputAmountInDecimal = dstSwapInputAmountInDecimal.toDP(dstChainCOT.decimals, Decimal__default.default.ROUND_FLOOR);
        // If toTokenAddress is not same as cot then create dstSwap
        if (!equalFold(input.toTokenAddress, dstChainCOTAddress)) {
            dds = await caCommon.destinationSwapWithExactIn(userAddressInBytes, dstOmniversalChainID, mulDecimals(dstSwapInputAmountInDecimal, dstChainCOT.decimals), convertTo32Bytes(input.toTokenAddress), params.aggregators, dstChainCOT.currencyID);
        }
        const createdAt = Date.now();
        let dstEOAToEphTx = null;
        const hasDstChainCOTInInput = cotSources.find((c) => equalFold(convertToEVMAddress(c.tokenAddress), dstChainCOTAddress));
        if (hasDstChainCOTInInput) {
            dstEOAToEphTx = {
                amount: mulDecimals(hasDstChainCOTInInput.amount, hasDstChainCOTInInput.decimals),
                contractAddress: dstChainCOTAddress,
            };
        }
        logger$a.debug('ExactIN: getDDS: SingleSrcSwap: After', {
            dds,
            dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),
        });
        return {
            ...dds,
            createdAt,
            dstChainCOT: dstChainCOT,
            dstEOAToEphTx,
            inputAmountWithBuffer: dstSwapInputAmountInDecimal,
            req: {
                chain: dstOmniversalChainID,
                inputToken: dstChainCOT.tokenAddress,
                outputToken: viem.toBytes(input.toTokenAddress),
            },
        };
    };
    const destinationSwap = await getDDS();
    logger$a.debug('getSwapRoute: ExactIN: After', {
        destinationSwap,
        dstSwapInputAmountInDecimal: dstSwapInputAmountInDecimal.toFixed(),
    });
    return {
        aggregators: params.aggregators,
        assetsUsed,
        balances,
        bridgeInput,
        cotSymbol,
        destinationSwap,
        getDDS,
        oraclePrices,
        sourceSwapCreationTime,
        sourceSwaps,
    };
};

const logger$9 = getLogger();
class BaseRequest {
    constructor(input) {
        this.input = input;
        this.steps = [];
        this.buildIntent = async (sourceChains = []) => {
            console.time('process:preIntentSteps');
            console.time('preIntentSteps:API');
            const [simulation, [balances, oraclePrices, feeStore]] = await Promise.all([
                this.simulateTx(),
                Promise.all([
                    getBalances({
                        networkHint: this.input.options.networkConfig.NETWORK_HINT,
                        vscDomain: this.input.options.networkConfig.VSC_DOMAIN,
                        evmAddress: this.input.evm.address,
                        chainList: this.chainList,
                        fuelAddress: this.input.fuel?.address,
                    }),
                    fetchPriceOracle(this.input.options.networkConfig.GRPC_URL),
                    getFeeStore(this.input.options.networkConfig.GRPC_URL),
                ]),
            ]);
            // if simulation is null, then the transaction is not a supported token transfer, so skip
            if (!simulation) {
                return;
            }
            console.timeEnd('preIntentSteps:API');
            logger$9.debug('Step 1:', {
                balances,
                feeStore,
                oraclePrices,
                simulation,
            });
            console.time('preIntentSteps: Parse');
            const { assets } = balances;
            // Step 2: parse simulation results
            const userAssets = new UserAssets(assets);
            const { amount, gas, isIntentRequired } = this.parseSimulation({
                assets: userAssets,
                simulation,
            });
            console.timeEnd('preIntentSteps: Parse');
            if (!isIntentRequired) {
                return;
            }
            console.time('preIntentSteps: CalculateGas');
            const gasInToken = convertGasToToken(simulation.token, oraclePrices, this.input.chain.id, this.input.chain.universe, gas);
            console.timeEnd('preIntentSteps: CalculateGas');
            logger$9.debug('preIntent:1', {
                gasInNative: gas.toFixed(),
                gasInToken: gasInToken.toFixed(),
            });
            // Step 4: create intent
            console.time('preIntentSteps: CreateIntent');
            const intent = this.createIntent({
                amount,
                assets: userAssets,
                feeStore,
                gas,
                gasInToken,
                sourceChains,
                token: simulation.token,
            });
            console.timeEnd('preIntentSteps: CreateIntent');
            console.timeEnd('process:preIntentSteps');
            if (intent.isAvailableBalanceInsufficient) {
                throw ErrorInsufficientBalance$1;
            }
            return { intent, token: simulation.token };
        };
        this.process = async () => {
            const i = await this.buildIntent(this.input.options.sourceChains);
            if (!i) {
                return;
            }
            let intent = i.intent;
            const token = i.token;
            if (intent.isAvailableBalanceInsufficient) {
                throw ErrorInsufficientBalance$1;
            }
            // Create steps like a crazy person to create another one again
            const allowances = await getAllowances(intent.allSources, this.input.evm.address, this.input.chainList);
            let unallowedSources = this.getUnallowedSources(intent, allowances);
            this.createExpectedSteps(intent, unallowedSources);
            let accepted = false;
            const refresh = async (sourceChains) => {
                if (accepted) {
                    logger$9.warn('Intent refresh called after acceptance');
                    return convertIntent(intent, token, this.chainList);
                }
                const i = await this.buildIntent(sourceChains);
                intent = i.intent;
                logger$9.debug('in refresh', {
                    i,
                    intent,
                });
                if (intent.isAvailableBalanceInsufficient) {
                    throw ErrorInsufficientBalance$1;
                }
                unallowedSources = this.getUnallowedSources(intent, allowances);
                this.createExpectedSteps(intent, unallowedSources);
                return convertIntent(intent, token, this.chainList);
            };
            // wait for intent acceptance hook
            await new Promise((resolve, reject) => {
                const allow = () => {
                    accepted = true;
                    return resolve('User allowed intent');
                };
                const deny = () => {
                    return reject(ErrorUserDeniedIntent$1);
                };
                this.input.hooks.onIntent({
                    allow,
                    deny,
                    intent: convertIntent(intent, token, this.chainList),
                    refresh,
                });
            });
            this.markStepDone(INTENT_ACCEPTED);
            console.time('process:AllowanceHook');
            // Step 5: set allowance if not set
            await this.waitForOnAllowanceHook(unallowedSources);
            console.timeEnd('process:AllowanceHook');
            // FIXME: Add showing intent again if prices change?
            // Step 6: process intent
            return await this.processIntent(intent);
        };
        this.markStepDone = (step, data) => {
            const s = this.steps.find((s) => s.typeID === step.typeID);
            if (s) {
                this.input.options.emit('step_complete', {
                    ...s,
                    ...(data ? { data } : {}),
                });
            }
        };
        this.chainList = this.input.chainList;
    }
    getUnallowedSources(intent, allowances) {
        const sources = [];
        for (const s of intent.sources) {
            if (s.chainID === intent.destination.chainID ||
                isNativeAddress$1(s.universe, s.tokenContract)) {
                continue;
            }
            const chain = this.chainList.getChainByID(s.chainID);
            if (!chain) {
                throw new Error('chain is not supported');
            }
            const token = this.chainList.getTokenByAddress(s.chainID, s.tokenContract);
            if (!token) {
                throw new Error('token is not supported');
            }
            const requiredAllowance = mulDecimals(s.amount, token.decimals);
            const currentAllowance = allowances[s.chainID] ?? 0n;
            logger$9.debug('getUnallowedSources:1', {
                currentAllowance: currentAllowance.toString(),
                requiredAllowance: requiredAllowance.toString(),
                token,
            });
            if (requiredAllowance > currentAllowance) {
                const d = {
                    allowance: {
                        current: currentAllowance.toString(),
                        minimum: requiredAllowance.toString(),
                    },
                    chain: {
                        id: chain.id,
                        logo: chain.custom.icon,
                        name: chain.name,
                    },
                    token: {
                        contractAddress: token.contractAddress,
                        decimals: token.decimals,
                        logo: token.logo || '',
                        name: token.name,
                        symbol: token.symbol,
                    },
                };
                sources.push(d);
            }
        }
        return sources;
    }
    async processIntent(intent) {
        logger$9.debug('intent', { intent });
        const { explorerURL, id, requestHash, waitForDoubleCheckTx } = await this.processRFF(intent);
        storeIntentHashToStore(this.input.evm.address, id.toNumber());
        await this.waitForFill(requestHash, id, waitForDoubleCheckTx);
        removeIntentHashFromStore(this.input.evm.address, id);
        this.markStepDone(INTENT_FULFILLED);
        return { explorerURL };
    }
    async processRFF(intent) {
        const { destinations, sources, universes } = getSourcesAndDestinationsForRFF(intent, this.input.chainList, this.destinationUniverse);
        const parties = [];
        for (const universe of universes) {
            if (universe === caCommon.Universe.ETHEREUM) {
                parties.push({
                    address: convertTo32BytesHex(this.input.evm.address),
                    universe: universe,
                });
            }
            if (universe === caCommon.Universe.FUEL) {
                parties.push({
                    address: convertTo32BytesHex(this.input.fuel.address),
                    universe,
                });
            }
        }
        logger$9.debug('processRFF:1', {
            destinations,
            parties,
            sources,
            universes,
        });
        const omniversalRff = new caCommon.OmniversalRFF({
            destinationChainID: convertTo32Bytes$1(intent.destination.chainID),
            destinations: destinations.map((dest) => ({
                tokenAddress: viem.toBytes(dest.tokenAddress),
                value: viem.toBytes(dest.value),
            })),
            destinationUniverse: intent.destination.universe,
            expiry: Long__default.default.fromString((BigInt(Date.now() + INTENT_EXPIRY) / 1000n).toString()),
            nonce: window.crypto.getRandomValues(new Uint8Array(32)),
            // @ts-ignore
            signatureData: parties.map((p) => ({
                address: viem.toBytes(p.address),
                universe: p.universe,
            })),
            // @ts-ignore
            sources: sources.map((source) => ({
                chainID: convertTo32Bytes$1(source.chainID),
                tokenAddress: convertTo32Bytes$1(source.tokenAddress),
                universe: source.universe,
                value: viem.toBytes(source.value),
            })),
        });
        const signatureData = [];
        for (const universe of universes) {
            if (universe === caCommon.Universe.ETHEREUM) {
                const { requestHash, signature } = await createRequestEVMSignature(omniversalRff.asEVMRFF(), this.input.evm.address, this.input.evm.client);
                signatureData.push({
                    address: convertTo32Bytes$1(this.input.evm.address),
                    requestHash,
                    signature,
                    universe: caCommon.Universe.ETHEREUM,
                });
            }
            if (universe === caCommon.Universe.FUEL) {
                if (!this.input.fuel?.address ||
                    !this.input.fuel?.provider ||
                    !this.input.fuel?.connector) {
                    logger$9.error('universe has fuel but not expected input', {
                        fuelInput: this.input.fuel,
                    });
                    throw new Error('universe has fuel but not expected input');
                }
                const { requestHash, signature } = await createRequestFuelSignature(this.input.chainList.getVaultContractAddress(fuels.CHAIN_IDS.fuel.mainnet), this.input.fuel.provider, this.input.fuel.connector, omniversalRff.asFuelRFF());
                signatureData.push({
                    address: viem.toBytes(this.input.fuel.address),
                    requestHash,
                    signature,
                    universe: caCommon.Universe.FUEL,
                });
            }
        }
        logger$9.debug('processRFF:2', { omniversalRff, signatureData });
        this.markStepDone(INTENT_HASH_SIGNED);
        const cosmosWalletAddress = (await this.input.cosmosWallet.getAccounts())[0].address;
        const msgBasicCosmos = caCommon.MsgCreateRequestForFunds.create({
            destinationChainID: omniversalRff.protobufRFF.destinationChainID,
            destinations: omniversalRff.protobufRFF.destinations,
            destinationUniverse: omniversalRff.protobufRFF.destinationUniverse,
            expiry: omniversalRff.protobufRFF.expiry,
            nonce: omniversalRff.protobufRFF.nonce,
            signatureData: signatureData.map((s) => ({
                address: s.address,
                signature: s.signature,
                universe: s.universe,
            })),
            sources: omniversalRff.protobufRFF.sources,
            user: cosmosWalletAddress,
        });
        logger$9.debug('processRFF:3', { msgBasicCosmos });
        const intentID = await cosmosCreateRFF$1({
            address: cosmosWalletAddress,
            cosmosURL: this.input.options.networkConfig.COSMOS_URL,
            msg: msgBasicCosmos,
            wallet: this.input.cosmosWallet,
        });
        const explorerURL = getExplorerURL(this.input.options.networkConfig.EXPLORER_URL, intentID);
        this.markStepDone(INTENT_SUBMITTED, {
            explorerURL,
            intentID: intentID.toNumber(),
        });
        const tokenCollections = [];
        for (const [i, s] of sources.entries()) {
            if (!isNativeAddress$1(s.universe, s.tokenAddress)) {
                tokenCollections.push(i);
            }
        }
        const evmDeposits = [];
        const fuelDeposits = [];
        const evmSignatureData = signatureData.find((d) => d.universe === caCommon.Universe.ETHEREUM);
        if (!evmSignatureData && universes.has(caCommon.Universe.ETHEREUM)) {
            throw new Error('ethereum in universe list but no signature data present');
        }
        const fuelSignatureData = signatureData.find((d) => d.universe === caCommon.Universe.FUEL);
        if (!fuelSignatureData && universes.has(caCommon.Universe.FUEL)) {
            throw new Error('fuel in universe list but no signature data present');
        }
        const doubleCheckTxs = [];
        for (const [i, s] of sources.entries()) {
            const chain = this.input.chainList.getChainByID(Number(s.chainID));
            if (!chain) {
                throw new Error('chain not found');
            }
            if (s.universe === caCommon.Universe.FUEL) {
                if (!this.input.fuel) {
                    throw new Error('fuel is involved but no associated data');
                }
                const account = new fuels.Account(this.input.fuel.address, this.input.fuel.provider, this.input.fuel.connector);
                const vault = new caCommon.ArcanaVault(this.chainList.getVaultContractAddress(fuels.CHAIN_IDS.fuel.mainnet), account);
                const tx = await vault.functions
                    .deposit(omniversalRff.asFuelRFF(), fuels.hexlify(fuelSignatureData.signature), i)
                    .callParams({
                    forward: {
                        amount: new fuels.BN(s.value.toString()),
                        assetId: s.tokenAddress,
                    },
                })
                    .call();
                this.markStepDone(INTENT_DEPOSIT_REQ(i + 1));
                fuelDeposits.push((async function () {
                    const txResult = await tx.waitForResult();
                    logger$9.debug('PostIntentSubmission: Fuel deposit result', {
                        txResult,
                    });
                    if (txResult.transactionResult.isStatusFailure) {
                        throw new Error('fuel deposit failed');
                    }
                })());
            }
            else if (s.universe === caCommon.Universe.ETHEREUM && isNativeAddress$1(s.universe, s.tokenAddress)) {
                const chain = this.input.chainList.getChainByID(Number(s.chainID));
                if (!chain) {
                    throw new Error('chain not found');
                }
                await switchChain(this.input.evm.client, chain);
                const publicClient = createPublicClientWithFallback(chain);
                const { request } = await publicClient.simulateContract({
                    abi: caCommon.EVMVaultABI,
                    account: this.input.evm.address,
                    address: this.input.chainList.getVaultContractAddress(chain.id),
                    args: [omniversalRff.asEVMRFF(), viem.toHex(evmSignatureData.signature), BigInt(i)],
                    chain: chain,
                    functionName: 'deposit',
                    value: s.value,
                });
                const hash = await this.input.evm.client.writeContract(request);
                this.markStepDone(INTENT_DEPOSIT_REQ(i + 1));
                evmDeposits.push(waitForTxReceipt(hash, publicClient));
            }
            doubleCheckTxs.push(createDepositDoubleCheckTx(convertTo32Bytes$1(chain.id), {
                address: cosmosWalletAddress,
                wallet: this.input.cosmosWallet,
            }, intentID, this.input.options.networkConfig));
        }
        if (evmDeposits.length || fuelDeposits.length) {
            await Promise.all([Promise.all(evmDeposits), Promise.all(fuelDeposits)]);
            this.markStepDone(INTENT_DEPOSITS_CONFIRMED);
        }
        logger$9.debug('PostIntentSubmission: Intent ID', {
            id: intentID.toNumber(),
        });
        if (tokenCollections.length > 0) {
            logger$9.debug('processRFF', {
                intentID: intentID.toString(),
                message: 'going to create RFF',
                tokenCollections,
            });
            await vscCreateRFF(this.input.options.networkConfig.VSC_DOMAIN, intentID, this.markStepDone, tokenCollections);
        }
        else {
            logger$9.debug('processRFF', {
                message: 'going to publish RFF',
            });
            await vscPublishRFF(this.input.options.networkConfig.VSC_DOMAIN, intentID);
        }
        const destinationSigData = signatureData.find((s) => s.universe === intent.destination.universe);
        if (!destinationSigData) {
            throw new Error('requestHash not found for destination');
        }
        return {
            explorerURL,
            id: intentID,
            requestHash: destinationSigData.requestHash,
            waitForDoubleCheckTx: waitForDoubleCheckTx(doubleCheckTxs),
        };
    }
    async setAllowances(input) {
        const originalChain = this.input.chain.id;
        logger$9.debug('setAllowances', { originalChain });
        const sponsoredApprovalParams = [];
        try {
            for (const source of input) {
                logger$9.debug('setAllowances', { originalChain });
                const chain = this.chainList.getChainByID(source.chainID);
                if (!chain) {
                    throw new Error('chain not supported');
                }
                const publicClient = createPublicClientWithFallback(chain);
                const vc = this.input.chainList.getVaultContractAddress(chain.id);
                const chainId = new caCommon.OmniversalChainID(caCommon.Universe.ETHEREUM, source.chainID);
                const chainDatum = caCommon.ChaindataMap.get(chainId);
                if (!chainDatum) {
                    throw new Error('Chain data not found');
                }
                const currency = chainDatum.CurrencyMap.get(convertTo32Bytes$1(source.tokenContract));
                if (!currency) {
                    throw new Error('Currency not found');
                }
                await switchChain(this.input.evm.client, chain);
                if (currency.permitVariant === caCommon.PermitVariant.Unsupported) {
                    const h = await this.input.evm.client.writeContract({
                        abi: caCommon.ERC20ABI,
                        account: this.input.evm.address,
                        address: source.tokenContract,
                        args: [vc, BigInt(source.amount)],
                        chain,
                        functionName: 'approve',
                    });
                    this.markStepDone(ALLOWANCE_APPROVAL_REQ(source.chainID));
                    await publicClient.waitForTransactionReceipt({
                        hash: h,
                    });
                    this.markStepDone(ALLOWANCE_APPROVAL_MINED(source.chainID));
                }
                else {
                    const account = {
                        address: this.input.evm.address,
                        type: 'json-rpc',
                    };
                    const signed = viem.parseSignature(await signPermitForAddressAndValue(currency, this.input.evm.client, publicClient, account, vc, source.amount));
                    this.markStepDone(ALLOWANCE_APPROVAL_REQ(source.chainID));
                    sponsoredApprovalParams.push({
                        address: convertTo32Bytes$1(account.address),
                        chain_id: chainDatum.ChainID32,
                        operations: [
                            {
                                sig_r: viem.hexToBytes(signed.r),
                                sig_s: viem.hexToBytes(signed.s),
                                sig_v: signed.yParity < 27 ? signed.yParity + 27 : signed.yParity,
                                token_address: currency.tokenAddress,
                                value: convertTo32Bytes$1(source.amount),
                                variant: currency.permitVariant === caCommon.PermitVariant.PolygonEMT ? 2 : 1,
                            },
                        ],
                        universe: chainDatum.Universe,
                    });
                }
            }
            if (sponsoredApprovalParams.length) {
                logger$9.debug('setAllowances:sponsoredApprovals', {
                    sponsoredApprovalParams,
                });
                await vscCreateSponsoredApprovals(this.input.options.networkConfig.VSC_DOMAIN, sponsoredApprovalParams, this.markStepDone);
            }
        }
        catch (e) {
            console.error('Error setting allowances', e);
            throw ErrorUserDeniedAllowance;
        }
        finally {
            if (this.input.chain.universe === caCommon.Universe.ETHEREUM) {
                await switchChain(this.input.evm.client, this.input.chain);
            }
            this.markStepDone(ALLOWANCE_COMPLETE);
        }
    }
    async waitForOnAllowanceHook(sources) {
        if (sources.length === 0) {
            return false;
        }
        await new Promise((resolve, reject) => {
            const allow = (allowances) => {
                if (sources.length !== allowances.length) {
                    return reject(new Error(`invalid input length for allow(). expected: ${sources.length} got: ${allowances.length}`));
                }
                logger$9.debug('CA:BaseRequest:Allowances', {
                    allowances,
                    sources,
                });
                const val = [];
                for (let i = 0; i < sources.length; i++) {
                    const source = sources[i];
                    const allowance = allowances[i];
                    let amount = 0n;
                    if (typeof allowance === 'string' && equalFold(allowance, 'max')) {
                        amount = viem.maxUint256;
                    }
                    else if (typeof allowance === 'string' && equalFold(allowance, 'min')) {
                        amount = BigInt(source.allowance.minimum);
                    }
                    else if (typeof allowance === 'string') {
                        amount = mulDecimals(allowance, source.token.decimals);
                    }
                    else {
                        amount = allowance;
                    }
                    val.push({
                        amount,
                        chainID: source.chain.id,
                        tokenContract: source.token.contractAddress,
                    });
                }
                this.setAllowances(val).then(resolve).catch(reject);
            };
            const deny = () => {
                return reject(ErrorUserDeniedAllowance);
            };
            this.input.hooks.onAllowance({
                allow,
                deny,
                sources,
            });
        });
        return true;
    }
    createExpectedSteps(intent, unallowedSources) {
        this.steps = createSteps(intent, this.chainList, unallowedSources);
        this.input.options.emit('expected_steps', this.steps);
        logger$9.debug('ExpectedSteps', this.steps);
    }
    createIntent(input) {
        const { amount, assets, feeStore, gas, gasInToken, token } = input;
        const intent = {
            allSources: [],
            destination: {
                amount: new Decimal__default.default('0'),
                chainID: this.input.chain.id,
                decimals: token.decimals,
                gas: 0n,
                tokenContract: token.contractAddress,
                universe: this.destinationUniverse,
            },
            fees: {
                caGas: '0',
                collection: '0',
                fulfilment: '0',
                gasSupplied: input.gasInToken.toFixed(),
                protocol: '0',
                solver: '0',
            },
            isAvailableBalanceInsufficient: false,
            sources: [],
        };
        const asset = assets.find(token.symbol);
        if (!asset) {
            throw new Error(`Asset ${token.symbol} not found in UserAssets`);
        }
        const allSources = asset.iterate(feeStore).map((v) => ({ ...v, amount: v.balance }));
        intent.allSources = allSources;
        const destinationBalance = asset.getBalanceOnChain(this.input.chain.id, token.contractAddress);
        let borrow = new Decimal__default.default(0);
        if (this.input.options.bridge) {
            borrow = amount;
        }
        else {
            if (amount.greaterThan(destinationBalance)) {
                borrow = amount.minus(destinationBalance);
            }
            if (destinationBalance !== '0') {
                intent.sources.push({
                    amount: amount.greaterThan(destinationBalance) ? new Decimal__default.default(destinationBalance) : amount,
                    chainID: this.input.chain.id,
                    tokenContract: token.contractAddress,
                    universe: this.destinationUniverse,
                });
            }
        }
        const protocolFee = feeStore.calculateProtocolFee(borrow);
        intent.fees.protocol = protocolFee.toFixed();
        let borrowWithFee = borrow.add(gasInToken).add(protocolFee);
        logger$9.debug('createIntent:0', {
            borrow: borrow.toFixed(),
            borrowWithFee: borrowWithFee.toFixed(),
            destinationBalance,
            gasInToken: gasInToken.toFixed(),
            protocolFee: protocolFee.toFixed(),
        });
        const fulfilmentFee = feeStore.calculateFulfilmentFee({
            decimals: token.decimals,
            destinationChainID: this.input.chain.id,
            destinationTokenAddress: token.contractAddress,
        });
        logger$9.debug('createIntent:1', { fulfilmentFee });
        intent.fees.fulfilment = fulfilmentFee.toFixed();
        borrowWithFee = borrowWithFee.add(fulfilmentFee);
        let accountedAmount = new Decimal__default.default(0);
        const allowedSources = allSources.filter((b) => {
            if (input.sourceChains.length === 0) {
                return true;
            }
            return input.sourceChains.includes(b.chainID);
        });
        logger$9.debug('createIntent:1.1', { allowedSources });
        for (const assetC of allowedSources) {
            if (accountedAmount.greaterThanOrEqualTo(borrowWithFee)) {
                break;
            }
            if (assetC.chainID === this.input.chain.id) {
                continue;
            }
            if (assetC.chainID === fuels.CHAIN_IDS.fuel.mainnet) {
                const fuelChain = this.chainList.getChainByID(fuels.CHAIN_IDS.fuel.mainnet);
                const baseAssetBalanceOnFuel = assets.getNativeBalance(fuelChain);
                if (new Decimal__default.default(baseAssetBalanceOnFuel).lessThan('0.000_003')) {
                    logger$9.debug('fuel base asset balance is lesser than min expected deposit fee, so skip', {
                        current: baseAssetBalanceOnFuel,
                        minimum: '0.000_003',
                    });
                    continue;
                }
            }
            if (!isNativeAddress$1(assetC.universe, assetC.tokenContract)) {
                const collectionFee = feeStore.calculateCollectionFee({
                    decimals: assetC.decimals,
                    sourceChainID: assetC.chainID,
                    sourceTokenAddress: assetC.tokenContract,
                });
                intent.fees.collection = collectionFee.add(intent.fees.collection).toFixed();
                borrowWithFee = borrowWithFee.add(collectionFee);
                logger$9.debug('createIntent:2', { collectionFee });
            }
            const unaccountedAmount = borrowWithFee.minus(accountedAmount);
            let borrowFromThisChain = new Decimal__default.default(assetC.balance).lessThanOrEqualTo(unaccountedAmount)
                ? new Decimal__default.default(assetC.balance)
                : unaccountedAmount;
            logger$9.debug('createIntent:2.1', {
                accountedAmount: accountedAmount.toFixed(),
                asset: assetC,
                balance: assetC.balance.toFixed(),
                borrowFromThisChain: borrowFromThisChain.toFixed(),
                unaccountedAmount: unaccountedAmount.toFixed(),
            });
            const solverFee = feeStore.calculateSolverFee({
                borrowAmount: borrowFromThisChain,
                decimals: assetC.decimals,
                destinationChainID: this.input.chain.id,
                destinationTokenAddress: token.contractAddress,
                sourceChainID: assetC.chainID,
                sourceTokenAddress: assetC.tokenContract,
            });
            intent.fees.solver = solverFee.add(intent.fees.solver).toFixed();
            logger$9.debug('createIntent:3', { solverFee });
            borrowWithFee = borrowWithFee.add(solverFee);
            const unaccountedBalance = borrowWithFee.minus(accountedAmount);
            borrowFromThisChain = new Decimal__default.default(assetC.balance).lessThanOrEqualTo(unaccountedBalance)
                ? new Decimal__default.default(assetC.balance)
                : unaccountedBalance;
            intent.sources.push({
                amount: borrowFromThisChain,
                chainID: assetC.chainID,
                tokenContract: assetC.tokenContract,
                universe: assetC.universe,
            });
            accountedAmount = accountedAmount.add(borrowFromThisChain);
        }
        intent.destination.amount = borrow;
        if (accountedAmount.lt(borrowWithFee)) {
            intent.isAvailableBalanceInsufficient = true;
        }
        if (!gas.equals(0)) {
            intent.destination.gas = mulDecimals(gas, this.input.chain.nativeCurrency.decimals);
        }
        logger$9.debug('createIntent:4', { intent });
        return intent;
    }
}
const waitForDoubleCheckTx = (input) => {
    return async () => {
        await Promise.allSettled(input.map((i) => i()));
    };
};

const logger$8 = getLogger();
const tokenRequestParseSimulation = ({ assets, bridge, chain, iGas, simulation, }) => {
    const tokenContract = simulation.token.contractAddress;
    const amount = simulation.amount ?? new Decimal__default.default(0);
    const nativeToken = chain.nativeCurrency;
    logger$8.debug('ERC20RequestBase:ParseSimulation:1', {
        assets,
        tokenContract,
    });
    const { chainsWithBalance, destinationAssetBalance, destinationGasBalance } = assets.getAssetDetails(chain, tokenContract);
    const gasMultiple = simulation.gasFee
        .mul(chain.id === SOPHON_CHAIN_ID ? 3 : 2)
        .add(divDecimals(iGas, nativeToken.decimals));
    logger$8.debug('ERC20RequestBase:ParseSimulation:0', {
        destinationGasBalance,
        expectedGas: gasMultiple.toFixed(),
        simGas: simulation.gasFee.toFixed(),
    });
    const isGasRequiredToBeBorrowed = bridge
        ? gasMultiple.greaterThan(0)
        : gasMultiple.greaterThan(destinationGasBalance);
    let isIntentRequired = false;
    if (bridge) {
        isIntentRequired = true;
    }
    let gas = new Decimal__default.default(0);
    logger$8.debug('ERC20RequestBase:parseSimulation:1', {
        chainsWithBalance,
        destinationAssetBalance,
        isGasRequiredToBeBorrowed,
    });
    if (chainsWithBalance) {
        if (amount.greaterThan(destinationAssetBalance)) {
            isIntentRequired = true;
        }
        if (isGasRequiredToBeBorrowed) {
            isIntentRequired = true;
            gas = bridge ? gasMultiple : gasMultiple.minus(destinationGasBalance);
        }
    }
    return {
        amount,
        gas,
        isIntentRequired,
    };
};
const nativeRequestParseSimulation = ({ assets, bridge, chain, simulation, }) => {
    const { chainsWithBalance, destinationGasBalance } = assets.getAssetDetails(chain, simulation.token.contractAddress);
    const gasMultiple = simulation.gasFee.mul(2);
    let isIntentRequired = false;
    if (bridge) {
        isIntentRequired = true;
    }
    if (chainsWithBalance) {
        if (simulation.amount.add(gasMultiple).greaterThan(destinationGasBalance)) {
            isIntentRequired = true;
        }
    }
    logger$8.debug('parseSimulation', {
        amount: simulation.amount.toFixed(),
        destinationGasBalance: destinationGasBalance,
        gas: gasMultiple.toFixed(),
    });
    return {
        amount: simulation.amount,
        gas: gasMultiple,
        isIntentRequired,
    };
};

const logger$7 = getLogger();
class ERC20Transfer extends BaseRequest {
    constructor(input) {
        super(input);
        this.input = input;
        this.destinationUniverse = caCommon.Universe.ETHEREUM;
        this.publicClient = viem.createPublicClient({
            transport: viem.webSocket(this.input.chain.rpcUrls.default.webSocket[0]),
        });
    }
    parseSimulation({ assets, simulation }) {
        return tokenRequestParseSimulation({
            assets,
            bridge: this.input.options.bridge,
            chain: this.input.chain,
            iGas: this.input.options.gas,
            simulation,
        });
    }
    async simulateTx() {
        const { data, to } = this.input.evm.tx;
        const from = this.input.evm.address;
        const token = this.chainList.getTokenByAddress(this.input.chain.id, to);
        const nativeToken = this.chainList.getNativeToken(this.input.chain.id);
        if (!token) {
            return;
        }
        const { args } = viem.decodeFunctionData({
            abi: [ERC20TransferABI],
            data: data ?? '0x00',
        });
        const amount = args[1];
        const amountInDecimal = divDecimals(amount, token.decimals);
        if (this.input.options.bridge) {
            this.simulateTxRes = {
                amount: amountInDecimal,
                gas: this.input.options.gas,
                gasFee: new Decimal__default.default(0),
                token,
            };
        }
        else if ([HYPEREVM_CHAIN_ID, KAIA_CHAIN_ID, MONAD_TESTNET_CHAIN_ID].includes(this.input.chain.id)) {
            this.simulateTxRes = {
                amount: amountInDecimal,
                gas: 100000n,
                gasFee: new Decimal__default.default(0),
                token,
            };
        }
        if (this.simulateTxRes) {
            let gasFee = 0n;
            if (this.simulateTxRes.gas > 0n) {
                const [{ gasPrice, maxFeePerGas }, l1Fee] = await Promise.all([
                    this.publicClient.estimateFeesPerGas(),
                    this.input.options.bridge
                        ? Promise.resolve(0n)
                        : getL1Fee(this.input.chain, viem.serializeTransaction({
                            chainId: this.input.chain.id,
                            data: data ?? '0x00',
                            to: to,
                            type: 'eip1559',
                        })),
                ]);
                const gasUnitPrice = maxFeePerGas ?? gasPrice ?? 0n;
                if (gasUnitPrice === 0n) {
                    throw new Error('could not get maxFeePerGas or gasPrice from RPC');
                }
                gasFee = this.simulateTxRes.gas * gasUnitPrice + l1Fee;
            }
            return {
                ...this.simulateTxRes,
                gasFee: divDecimals(gasFee, nativeToken.decimals),
            };
        }
        const amountToAdd = new Decimal__default.default(args[1].toString())
            .toHexadecimal()
            .split('0x')[1]
            .padStart(40, '0');
        let txsToSimulate = [];
        if (AaveTokenContracts[this.input.chain.id]?.[token.symbol]) {
            txsToSimulate.push({
                from: AaveTokenContracts[this.input.chain.id][token.symbol],
                input: `0xa9059cbb000000000000000000000000${from
                    .replace('0x', '')
                    .toLowerCase()}000000000000000000000000${amountToAdd}`,
                to: token.contractAddress,
            });
        }
        else if (TOKEN_MINTER_CONTRACTS[this.input.chain.id]?.[token.symbol]) {
            txsToSimulate.push({
                from: TOKEN_MINTER_CONTRACTS[this.input.chain.id]?.[token.symbol],
                input: `0x40c10f19000000000000000000000000${from
                    .replace('0x', '')
                    .toLowerCase()}000000000000000000000000000000000000000000000000000000003b9aca00`,
                to: token.contractAddress,
            });
        }
        txsToSimulate.push({
            from,
            input: data,
            to,
        });
        if (TOP_OWNER[this.input.chain.id]?.[token.symbol]) {
            const ownerAddress = TOP_OWNER[this.input.chain.id][token.symbol];
            txsToSimulate = [
                {
                    from: ownerAddress,
                    input: data,
                    to,
                },
            ];
        }
        const [simulation, feeData, l1Fee] = await Promise.all([
            simulateTransaction(this.input.chain.id, txsToSimulate, this.input.options.networkConfig.SIMULATION_URL),
            this.publicClient.estimateFeesPerGas(),
            getL1Fee(this.input.chain, viem.serializeTransaction({
                chainId: this.input.chain.id,
                data: data ?? '0x00',
                to: to,
                type: 'eip1559',
            })),
        ]);
        logger$7.debug('simulateTx', { feeData });
        const gasUnitPrice = feeData.maxFeePerGas ?? feeData.gasPrice ?? 0n;
        if (gasUnitPrice === 0n) {
            throw new Error('could not get maxFeePerGas or gasPrice from RPC');
        }
        let gasFee = (this.input.chain.id === SOPHON_CHAIN_ID
            ? BigInt(simulation.data.gas)
            : BigInt(simulation.data.gas_used)) *
            gasUnitPrice +
            l1Fee;
        logger$7.debug('erc20:simulateTx', {
            args,
            feeData,
            l1Fee,
            maxFeePerGas: gasUnitPrice,
            simulation,
            totalGas: gasFee,
            totalGasInDecimal: divDecimals(gasFee, nativeToken.decimals).toFixed(),
        });
        if (this.input.options.bridge) {
            gasFee = 0n;
        }
        this.simulateTxRes = {
            amount: divDecimals(amount, token.decimals),
            gas: this.input.chain.id === SOPHON_CHAIN_ID
                ? BigInt(simulation.data.gas)
                : BigInt(simulation.data.gas_used),
            gasFee: divDecimals(gasFee, nativeToken.decimals),
            token,
        };
        return this.simulateTxRes;
    }
    async waitForFill(requestHash, intentID, waitForDoubleCheckTx) {
        logger$7.debug('waitForFill', {
            intentID,
            requestHash,
            waitForDoubleCheckTx,
        });
        waitForDoubleCheckTx();
        try {
            await evmWaitForFill(this.input.chainList.getVaultContractAddress(this.input.chain.id), this.publicClient, requestHash, intentID, this.input.options.networkConfig.GRPC_URL, this.input.options.networkConfig.COSMOS_URL);
        }
        finally {
            (await this.publicClient.transport.getRpcClient()).close();
        }
    }
}

const logger$6 = getLogger();
class NativeTransfer extends BaseRequest {
    constructor(input) {
        super(input);
        this.input = input;
        this.destinationUniverse = caCommon.Universe.ETHEREUM;
        const wsUrls = this.input.chain.rpcUrls?.default?.webSocket;
        if (!wsUrls?.length) {
            throw new Error(`Web-Socket RPC URL missing for chain ${this.input.chain.id}`);
        }
        this.publicClient = viem.createPublicClient({
            transport: viem.webSocket(wsUrls[0]),
        });
    }
    parseSimulation({ assets, simulation }) {
        return nativeRequestParseSimulation({
            assets,
            bridge: this.input.options.bridge,
            chain: this.input.chain,
            simulation,
        });
    }
    async simulateTx() {
        const { data, to, value } = this.input.evm.tx;
        const nativeToken = this.input.chainList.getNativeToken(this.input.chain.id);
        const amount = viem.hexToBigInt(value ?? `0x00`);
        const amountInDecimal = divDecimals(amount, nativeToken.decimals);
        if (this.input.options.bridge) {
            this.simulateTxRes = {
                amount: amountInDecimal,
                gas: this.input.options.gas,
                gasFee: new Decimal__default.default(0),
                token: nativeToken,
            };
        }
        if (this.simulateTxRes) {
            let gasFee = 0n;
            if (this.simulateTxRes.gas > 0n) {
                const [{ gasPrice, maxFeePerGas }, l1Fee] = await Promise.all([
                    this.publicClient.estimateFeesPerGas(),
                    this.input.options.bridge
                        ? Promise.resolve(0n)
                        : getL1Fee(this.input.chain, viem.serializeTransaction({
                            chainId: this.input.chain.id,
                            data: data ?? '0x00',
                            to: to,
                            type: 'eip1559',
                            value: amount,
                        })),
                ]);
                const gasUnitPrice = maxFeePerGas ?? gasPrice ?? 0n;
                if (gasUnitPrice === 0n) {
                    throw new Error('could not get maxFeePerGas or gasPrice from RPC');
                }
                gasFee = this.simulateTxRes.gas * gasUnitPrice + l1Fee;
            }
            return {
                ...this.simulateTxRes,
                gasFee: divDecimals(gasFee, nativeToken.decimals),
            };
        }
        const txsToSimulate = [
            {
                from: ZERO_ADDRESS,
                input: data ?? '0x00',
                to,
                value: value ?? '0x00',
            },
        ];
        const [simulation, feeData, l1Fee] = await Promise.all([
            simulateTransaction(this.input.chain.id, txsToSimulate, this.input.options.networkConfig.SIMULATION_URL),
            this.publicClient.estimateFeesPerGas(),
            getL1Fee(this.input.chain, viem.serializeTransaction({
                chainId: this.input.chain.id,
                data: data ?? '0x00',
                to: to,
                type: 'eip1559',
                value: viem.hexToBigInt(value ?? '0x00'),
            })),
        ]);
        const gasUnitPrice = feeData.maxFeePerGas ?? feeData.gasPrice ?? 0n;
        if (gasUnitPrice === 0n) {
            throw new Error('could not get maxFeePerGas or gasPrice from RPC');
        }
        let gasFee = BigInt(simulation.data.gas_used) * gasUnitPrice + l1Fee;
        logger$6.debug('native:simulateTx', {
            feeData,
            l1Fee,
            maxFeePerGas: gasUnitPrice,
            simulation,
            totalGas: gasFee,
            totalGasInDecimal: divDecimals(gasFee, nativeToken.decimals),
        });
        this.simulateTxRes = {
            amount: amountInDecimal,
            gas: BigInt(simulation.data.gas_used),
            gasFee: divDecimals(gasFee, nativeToken.decimals),
            token: {
                contractAddress: ZERO_ADDRESS,
                decimals: nativeToken.decimals,
                name: nativeToken.name,
                symbol: nativeToken.symbol,
            },
        };
        return this.simulateTxRes;
    }
    async waitForFill(requestHash, intentID, waitForDoubleCheckTx) {
        waitForDoubleCheckTx();
        try {
            await evmWaitForFill(this.input.chainList.getVaultContractAddress(this.input.chain.id), this.publicClient, requestHash, intentID, this.input.options.networkConfig.GRPC_URL, this.input.options.networkConfig.COSMOS_URL);
        }
        finally {
            (await this.publicClient.transport.getRpcClient()).close();
        }
    }
}

const logger$5 = getLogger();
class FuelNativeTransfer extends BaseRequest {
    constructor(input) {
        super(input);
        this.input = input;
        this.allowances = null;
        this.destinationUniverse = caCommon.Universe.FUEL;
        if (!this.input.fuel?.tx) {
            throw new Error('Invalid request');
        }
        if (!this.input.fuel.address) {
            throw new Error('fuel address missing');
        }
        this.tx = this.input.fuel.tx;
        this.fuelAddress = this.input.fuel.address;
    }
    parseSimulation(input) {
        return nativeRequestParseSimulation({
            ...input,
            bridge: this.input.options.bridge,
            chain: this.input.chain,
        });
    }
    async simulateTx() {
        logger$5.debug('fuel: reached simulate tx');
        const nativeCurrency = this.input.chain.nativeCurrency;
        if (this.simulateTxRes) {
            let gasFee = new Decimal__default.default(0);
            if (!this.input.options.bridge) {
                const { assembledRequest } = await this.input.fuel.provider.assembleTx({
                    feePayerAccount: new fuels.Account(this.input.fuel.address),
                    request: this.input.fuel.tx,
                });
                gasFee = divDecimals(BigInt(assembledRequest.maxFee.toString()) * 2n, nativeCurrency.decimals);
            }
            return {
                ...this.simulateTxRes,
                gasFee,
            };
        }
        this.simulateTxRes = await simulate(this.tx, this.fuelAddress, this.input.fuel.provider, this.input.chainList);
        if (this.input.options.bridge && this.simulateTxRes) {
            this.simulateTxRes.gasFee = new Decimal__default.default(0);
        }
        return this.simulateTxRes;
    }
    async waitForFill(_, intentID) {
        const ac = new AbortController();
        await Promise.race([
            requestTimeout(3, ac),
            cosmosFillCheck(intentID, this.input.options.networkConfig.GRPC_URL, this.input.options.networkConfig.COSMOS_URL, ac),
        ]);
    }
}

const logger$4 = getLogger();
class FuelTokenTransfer extends BaseRequest {
    constructor(input) {
        super(input);
        this.input = input;
        this.allowances = null;
        this.destinationUniverse = caCommon.Universe.FUEL;
        if (!this.input.fuel?.tx) {
            throw new Error('Invalid request');
        }
        if (!this.input.fuel.address) {
            throw new Error('fuel address missing');
        }
        this.tx = this.input.fuel.tx;
        this.fuelAddress = this.input.fuel.address;
    }
    parseSimulation({ assets, simulation }) {
        return tokenRequestParseSimulation({
            assets,
            bridge: this.input.options.bridge,
            chain: this.input.chain,
            iGas: this.input.options.gas,
            simulation,
        });
    }
    async simulateTx() {
        logger$4.debug('fuel: reached simulate tx');
        const nativeCurrency = this.input.chain.nativeCurrency;
        if (this.simulateTxRes) {
            let gasFee = new Decimal__default.default(0);
            if (!this.input.options.bridge) {
                const { assembledRequest } = await this.input.fuel.provider.assembleTx({
                    feePayerAccount: new fuels.Account(this.input.fuel.address),
                    request: this.input.fuel.tx,
                });
                gasFee = divDecimals(BigInt(assembledRequest.maxFee.toString()) * 2n, nativeCurrency.decimals);
            }
            return {
                ...this.simulateTxRes,
                gasFee,
            };
        }
        this.simulateTxRes = await simulate(this.tx, this.fuelAddress, this.input.fuel.provider, this.input.chainList);
        if (this.input.options.bridge && this.simulateTxRes) {
            this.simulateTxRes.gasFee = new Decimal__default.default(0);
        }
        return this.simulateTxRes;
    }
    async waitForFill(_, intentID) {
        const ac = new AbortController();
        await Promise.race([
            requestTimeout(3, ac),
            cosmosFillCheck(intentID, this.input.options.networkConfig.GRPC_URL, this.input.options.networkConfig.COSMOS_URL, ac),
        ]);
    }
}

const logger$3 = getLogger();
var TxType;
(function (TxType) {
    TxType[TxType["EVMERC20Transfer"] = 0] = "EVMERC20Transfer";
    TxType[TxType["EVMNativeTransfer"] = 1] = "EVMNativeTransfer";
    TxType[TxType["FuelTokenTransfer"] = 2] = "FuelTokenTransfer";
    TxType[TxType["FuelNativeTransfer"] = 3] = "FuelNativeTransfer";
})(TxType || (TxType = {}));
const handlers = {
    [TxType.EVMERC20Transfer]: ERC20Transfer,
    [TxType.EVMNativeTransfer]: NativeTransfer,
    [TxType.FuelNativeTransfer]: FuelNativeTransfer,
    [TxType.FuelTokenTransfer]: FuelTokenTransfer,
};
const createHandler = (input) => {
    logger$3.debug('router', { input });
    let handler = null;
    let processTx = async () => { };
    if (input.evm.tx) {
        const tx = input.evm.tx;
        if (isERC20TokenTransfer(input)) {
            handler = handlers[TxType.EVMERC20Transfer];
        }
        else if (isNativeTokenTransfer(input)) {
            handler = handlers[TxType.EVMNativeTransfer];
        }
        processTx = async () => {
            if (!input.options.bridge && !input.options.skipTx) {
                logger$3.debug('in processTx', {
                    tx: input.evm.tx,
                });
                await switchChain(input.evm.client, input.chain);
                return input.evm.client.request({
                    method: 'eth_sendTransaction',
                    params: [tx],
                });
            }
            return;
        };
    }
    else if (input.fuel?.tx) {
        if (isFuelNativeTransfer(input.fuel.tx)) {
            handler = handlers[TxType.FuelNativeTransfer];
        }
        else {
            handler = handlers[TxType.FuelTokenTransfer];
        }
        processTx = async () => {
            if (!input.options.bridge && !input.options.skipTx) {
                logger$3.debug('in processTx', {
                    address: input.fuel.address,
                    provider: input.fuel.provider,
                    tx: input.fuel?.tx,
                });
                const tx = await fixTx(input.fuel.address, input.fuel.tx, input.fuel.provider);
                return input.fuel.connector.sendTransaction(input.fuel.address, tx, {
                    provider: {
                        url: FUEL_NETWORK_URL,
                    },
                });
            }
            return;
        };
    }
    else {
        throw Error('Unknown handler');
    }
    return {
        handler: handler ? new handler(input) : null,
        processTx,
    };
};

const logger$2 = getLogger();
class BridgeHandler {
    constructor(input, options) {
        this.input = input;
        this.options = options;
        this.depositCalls = {};
        this.eoaToEphCalls = {};
        this.status = {
            filled: true,
            intentID: Long__default.default.fromInt(0),
            promise: Promise.resolve(),
        };
        this.waitForFill = () => ({
            filled: true,
            intentID: Long__default.default.fromNumber(0),
            promise: Promise.resolve(),
        });
        this.createDoubleCheckTx = async () => { };
        if (input) {
            for (const asset of input.assets) {
                options.cache.addAllowanceQuery({
                    chainID: asset.chainID,
                    contractAddress: asset.contractAddress,
                    owner: options.address.ephemeral,
                    spender: options.chainList.getVaultContractAddress(asset.chainID),
                });
            }
        }
    }
    async createRFFDeposits() {
        const waitingPromises = [];
        if (Object.keys(this.depositCalls).length > 0) {
            const sbcTx = [];
            for (const c in this.depositCalls) {
                const chain = this.options.chainList.getChainByID(Number(c));
                if (!chain) {
                    throw new Error('chain not found');
                }
                const publicClient = this.options.publicClientList.get(c);
                const calls = [];
                const e2e = this.eoaToEphCalls[Number(c)];
                logger$2.debug('Eoa->Eph and deposit calls', {
                    allEoAToEphemeralCalls: this.eoaToEphCalls,
                    chain: c,
                    eoAToEphemeralCalls: e2e,
                    rffDepositCalls: { ...this.depositCalls },
                });
                await this.options.wallet.eoa.switchChain({
                    id: Number(c),
                });
                if (e2e) {
                    await this.options.wallet.eoa.switchChain({ id: chain.id });
                    const txs = await createPermitAndTransferFromTx({
                        amount: e2e.amount,
                        cache: this.options.cache,
                        chain,
                        contractAddress: e2e.tokenAddress,
                        owner: this.options.address.eoa,
                        ownerWallet: this.options.wallet.eoa,
                        publicClient,
                        spender: this.options.address.ephemeral,
                    });
                    calls.push(...txs);
                }
                sbcTx.push(await createSBCTxFromCalls({
                    cache: this.options.cache,
                    calls: calls.concat(this.depositCalls[c].tx).concat(createSweeperTxs({
                        cache: this.options.cache,
                        chainID: chain.id,
                        COTCurrencyID: this.options.cot.currencyID,
                        receiver: this.options.address.eoa,
                        sender: this.options.address.ephemeral,
                    })),
                    chainID: chain.id,
                    ephemeralAddress: this.options.address.ephemeral,
                    ephemeralWallet: this.options.wallet.ephemeral,
                    publicClient,
                }));
            }
            if (sbcTx.length) {
                const ops = await vscSBCTx(sbcTx, this.options.networkConfig.VSC_DOMAIN);
                ops.forEach((op) => {
                    this.options.emitter.emit(SOURCE_SWAP_HASH(op, this.options.chainList));
                });
                waitingPromises.push(...ops.map(([chainID, hash]) => wrap(Number(chainID), waitForTxReceipt(hash, this.options.publicClientList.get(chainID), 2))));
            }
        }
        await Promise.all(waitingPromises);
    }
    async process(metadata, inputAssets) {
        if (this.input) {
            for (const asset of this.input.assets) {
                const updatedAsset = inputAssets.find((i) => i.chainID === asset.chainID && equalFold(i.tokenAddress, asset.contractAddress));
                if (updatedAsset) {
                    asset.ephemeralBalance = updatedAsset.amount;
                }
            }
            const response = await createBridgeRFF({
                config: {
                    chainList: this.options.chainList,
                    cosmos: {
                        address: this.options.address.cosmos,
                        wallet: this.options.wallet.cosmos,
                    },
                    evm: {
                        address: this.options.address.ephemeral,
                        client: this.options.wallet.ephemeral,
                        eoaAddress: this.options.address.eoa,
                    },
                    network: {
                        COSMOS_URL: this.options.networkConfig.COSMOS_URL,
                        GRPC_URL: this.options.networkConfig.GRPC_URL,
                    },
                },
                input: { assets: this.input.assets },
                output: this.input,
            });
            this.depositCalls = response.depositCalls;
            this.eoaToEphCalls = response.eoaToEphemeralCalls;
            const [, { createDoubleCheckTx }] = await Promise.all([
                this.createRFFDeposits(),
                response.createRFF(),
            ]);
            this.waitForFill = response.waitForFill;
            this.createDoubleCheckTx = createDoubleCheckTx;
        }
        this.status = this.waitForFill();
        if (this.status.intentID.toNumber() != 0) {
            await esToolkit.retry(async () => {
                await this.createDoubleCheckTx().then(() => {
                    logger$2.info('double-check-returned');
                    return true;
                });
            }, { delay: 3000, retries: 3 });
            metadata.rff_id = BigInt(this.status.intentID.toNumber());
            this.options.emitter.emit(RFF_ID(this.status.intentID.toNumber()));
            // will just resolve immediately if no CA was required
            logger$2.debug('Fill wait start');
            performance.mark('fill-wait-start');
            if (!this.status.filled) {
                await this.status.promise;
            }
            performance.mark('fill-wait-end');
            logger$2.debug('Fill wait complete');
        }
    }
}
class DestinationSwapHandler {
    constructor(dstSwap, dstTokenInfo, dst, options) {
        this.dstSwap = dstSwap;
        this.dstTokenInfo = dstTokenInfo;
        this.dst = dst;
        this.options = options;
        this.destinationCalls = [];
        if (dstSwap.dstEOAToEphTx) {
            options.cache.addAllowanceQuery({
                chainID: dst.chainID,
                contractAddress: dstSwap.dstEOAToEphTx.contractAddress,
                owner: options.address.eoa,
                spender: options.address.ephemeral,
            });
        }
        options.cache.addSetCodeQuery({
            address: options.address.ephemeral,
            chainID: dst.chainID,
        });
        logger$2.debug('dstSwapHandler:constructor', {
            isNativeAddress: isNativeAddress(dst.token),
        });
        if (isNativeAddress(dst.token)) {
            options.cache.addNativeAllowanceQuery({
                chainID: dst.chainID,
                contractAddress: options.address.ephemeral,
                owner: SWEEPER_ADDRESS,
                spender: SWEEPER_ADDRESS,
            });
        }
        options.cache.addAllowanceQuery({
            chainID: dst.chainID,
            contractAddress: convertToEVMAddress(dstSwap.req.inputToken),
            owner: options.address.ephemeral,
            spender: SWEEPER_ADDRESS,
        });
    }
    async createPermit() {
        if (this.dstSwap.dstEOAToEphTx) {
            const txs = await createPermitAndTransferFromTx({
                amount: this.dstSwap.dstEOAToEphTx.amount,
                cache: this.options.cache,
                chain: this.options.chainList.getChainByID(this.dst.chainID),
                contractAddress: this.dstSwap.dstEOAToEphTx.contractAddress,
                owner: this.options.address.eoa,
                ownerWallet: this.options.wallet.eoa,
                publicClient: this.options.publicClientList.get(this.dst.chainID),
                spender: this.options.address.ephemeral,
            });
            this.destinationCalls = this.destinationCalls.concat(txs);
        }
    }
    // FIXME: Need to add retry and reqoute
    async process(metadata) {
        await this.options.wallet.eoa.switchChain({
            id: Number(this.options.destinationChainID),
        });
        let hasDestinationSwap = false;
        if (this.dstSwap.quote) {
            hasDestinationSwap = true;
            await this.requoteIfRequired( /*inputAmount*/);
            const txs = getTxsFromQuote(this.dstSwap.aggregator, this.dstSwap.quote, this.dstSwap.req.inputToken, true);
            if (txs.approval) {
                this.destinationCalls.push(txs.approval);
            }
            this.destinationCalls.push(txs.swap);
            logger$2.debug('swap:destinationCalls', {
                destinationCalls: this.destinationCalls,
            });
            metadata.dst.swaps.push({
                agg: 0,
                input_amt: viem.toBytes(txs.amount),
                input_contract: this.dstSwap.req.inputToken,
                input_decimals: this.dstSwap.dstChainCOT.decimals,
                output_amt: convertTo32Bytes(this.dst.amount ?? 0),
                output_contract: convertTo32Bytes(this.dst.token),
                output_decimals: this.dstTokenInfo.decimals,
            });
        }
        if (hasDestinationSwap) {
            this.options.emitter.emit(DESTINATION_SWAP_BATCH_TX(false));
        }
        // So whatever amount is swapped gets transferred ephemeral -> eoa
        this.destinationCalls = this.destinationCalls.concat(createSweeperTxs({
            cache: this.options.cache,
            chainID: this.dst.chainID,
            COTCurrencyID: this.options.cot.currencyID,
            receiver: this.options.address.eoa,
            sender: this.options.address.ephemeral,
            tokenAddress: this.dst.token,
        }));
        // Destination swap batched tx to VSC and waiting for receipt (sweep after)
        const hash = await performDestinationSwap({
            actualAddress: this.options.address.eoa,
            cache: this.options.cache,
            calls: this.destinationCalls,
            chain: this.options.chainList.getChainByID(this.dst.chainID),
            chainList: this.options.chainList,
            COT: this.options.cot.currencyID,
            emitter: this.options.emitter,
            ephemeralAddress: this.options.address.ephemeral,
            ephemeralWallet: this.options.wallet.ephemeral,
            hasDestinationSwap,
            publicClientList: this.options.publicClientList,
            vscDomain: this.options.networkConfig.VSC_DOMAIN,
        });
        if (hasDestinationSwap) {
            this.options.emitter.emit(DESTINATION_SWAP_BATCH_TX(true));
        }
        this.options.emitter.emit(SWAP_COMPLETE);
        performance.mark('xcs-ops-end');
        logger$2.debug('before dst metadata', {
            metadata,
        });
        metadata.dst.tx_hash = convertTo32Bytes(hash);
    }
    async requoteIfRequired() {
        let requote = false;
        if (this.dstSwap.aggregator instanceof caCommon.BebopAggregator) {
            const quote = this.dstSwap.quote;
            if (quote.originalResponse.quote.expiry * 1000 < Date.now()) {
                logger$2.debug('DDS: BEBOP', {
                    expiry: quote.originalResponse.quote.expiry * 1000,
                    now: Date.now(),
                });
                requote = true;
            }
        }
        else if (Date.now() - this.dstSwap.createdAt > minutesToMs(0.4)) {
            requote = true;
        }
        // else if (this.dstSwap.quote?.inputAmount !== inputAmount) {
        //   requote = true;
        // }
        if (requote) {
            const ddsResponse = await this.dstSwap.getDDS();
            if (!ddsResponse.quote) {
                throw new Error('could not requote DS');
            }
            logger$2.debug('reqoutedDstSwap', {
                inputAmountWithBuffer: this.dstSwap.inputAmountWithBuffer.toFixed(),
                newInputAmount: ddsResponse.inputAmount.toFixed(),
            });
            const isExactIn = this.dst.amount == undefined;
            if (!isExactIn && ddsResponse.inputAmount.gt(this.dstSwap.inputAmountWithBuffer)) {
                throw new Error(`Rates changed for destination swap and could not be filled even with buffer. Before: ${this.dstSwap.inputAmountWithBuffer.toFixed()} ,After: ${ddsResponse.inputAmount.toFixed()}`);
            }
            this.dstSwap = { ...ddsResponse, getDDS: this.dstSwap.getDDS };
        }
    }
}
class SourceSwapsHandler {
    constructor(quotes, options) {
        this.options = options;
        this.disposableCache = {};
        this.swaps = this.groupAndOrder(quotes);
        for (const [chainID, swapQuotes] of this.iterate(this.swaps)) {
            this.options.cache.addSetCodeQuery({
                address: this.options.address.ephemeral,
                chainID: Number(chainID),
            });
            for (const sQuote of swapQuotes) {
                this.options.cache.addAllowanceQuery({
                    chainID: Number(chainID),
                    contractAddress: convertToEVMAddress(sQuote.input.req.inputToken),
                    owner: this.options.address.eoa,
                    spender: this.options.address.ephemeral,
                });
                this.options.cache.addAllowanceQuery({
                    chainID: Number(chainID),
                    contractAddress: convertToEVMAddress(sQuote.input.req.inputToken),
                    owner: this.options.address.ephemeral,
                    spender: SWEEPER_ADDRESS,
                });
            }
        }
    }
    getSwapsAndMetadata(input) {
        const swaps = [];
        const metadata = [];
        for (const swap of input) {
            const td = swap.getTxsData();
            const md = swap.getMetadata();
            metadata.push(md);
            swaps.push(td);
        }
        return { metadata, swaps };
    }
    *iterate(input) {
        for (const [chainID, swaps] of input) {
            const d = swaps.map((swap) => new Swap(swap));
            yield [chainID, d];
        }
    }
    async process(metadata, input = this.swaps, retry = true) {
        logger$2.debug('sourceSwapsHandler', {
            input,
            metadata,
            retry,
        });
        const waitingPromises = [];
        const chains = [];
        const assets = [];
        for (const [chainID, swapQuotes] of this.iterate(input)) {
            chains.push(chainID);
            const sbcCalls = {
                calls: [],
                value: 0n,
            };
            const metadataTx = {
                chid: convertTo32Bytes(chainID),
                swaps: [],
                tx_hash: new Uint8Array(),
                univ: caCommon.Universe.ETHEREUM,
            };
            const { metadata: mtd, swaps } = this.getSwapsAndMetadata(swapQuotes);
            const publicClient = this.options.publicClientList.get(chainID);
            const chain = this.options.chainList.getChainByID(Number(chainID));
            if (!chain) {
                throw new Error(`chain not found: ${chainID}`);
            }
            logger$2.debug('srcSwapHandler:process', {
                swaps,
                mtd,
            });
            metadataTx.swaps = metadataTx.swaps.concat(mtd);
            // 1. Source swap calls
            let amount = 0n;
            {
                for (const swap of swaps) {
                    amount += swap.outputAmount;
                    const { symbol } = getTokenDecimals(Number(chainID), swap.inputToken);
                    if (isNativeAddress(convertToEVMAddress(swap.inputToken))) {
                        sbcCalls.value += swap.amount;
                    }
                    else {
                        this.options.emitter.emit(CREATE_PERMIT_FOR_SOURCE_SWAP(false, symbol, chain));
                        const allowanceCacheKey = getAllowanceCacheKey({
                            chainID: chain.id,
                            contractAddress: convertToEVMAddress(swap.inputToken),
                            owner: this.options.address.eoa,
                            spender: this.options.address.ephemeral,
                        });
                        const txs = await createPermitAndTransferFromTx({
                            amount: swap.amount,
                            approval: this.disposableCache[allowanceCacheKey],
                            cache: this.options.cache,
                            chain,
                            contractAddress: convertToEVMAddress(swap.inputToken),
                            owner: this.options.address.eoa,
                            ownerWallet: this.options.wallet.eoa,
                            publicClient,
                            spender: this.options.address.ephemeral,
                        });
                        // Approval & transferFrom
                        if (txs.length === 2) {
                            const approvalTx = txs[0];
                            this.disposableCache[allowanceCacheKey] = approvalTx;
                        }
                        this.options.emitter.emit(CREATE_PERMIT_FOR_SOURCE_SWAP(true, symbol, chain));
                        logger$2.debug('sourceSwap', {
                            chainID,
                            permitCalls: txs,
                            swap,
                        });
                        sbcCalls.calls.push(...txs);
                    }
                    if (swap.approval) {
                        sbcCalls.calls.push(swap.approval);
                    }
                    sbcCalls.calls.push(swap.swap);
                }
            }
            // 2. Create batched calls
            {
                if (sbcCalls.value > 0n) {
                    if (!(await checkAuthCodeSet(Number(chainID), this.options.address.ephemeral, this.options.cache))) {
                        const ops = await vscSBCTx([
                            await createSBCTxFromCalls({
                                cache: this.options.cache,
                                calls: [],
                                chainID: chain.id,
                                ephemeralAddress: this.options.address.ephemeral,
                                ephemeralWallet: this.options.wallet.ephemeral,
                                publicClient,
                            }),
                        ], this.options.networkConfig.VSC_DOMAIN);
                        logger$2.debug('SetAuthCodeWithoutCalls', {
                            ops,
                        });
                        await waitForSBCTxReceipt(ops, this.options.chainList, this.options.publicClientList);
                        // We know its set since we got receipt,
                        // and so if we come back on retry it is already set
                        this.options.cache.addSetCodeValue({
                            address: this.options.address.ephemeral,
                            chainID: Number(chainID),
                        }, EXPECTED_CALIBUR_CODE);
                    }
                    await this.options.wallet.eoa.switchChain({ id: Number(chainID) });
                    /*
                     * EOA creates & sends tx {
                       to: ephemeralAddress (we check above it its delegated to calibur),
                       value: sbcCalls.value,
                       data: SignUsingEphemeral(AggregatorTx(approval(iff non native is involved) and swap))
                     }
                     */
                    const hash = await caliburExecute({
                        actualAddress: this.options.address.eoa,
                        actualWallet: this.options.wallet.eoa,
                        calls: sbcCalls.calls,
                        chain,
                        ephemeralAddress: this.options.address.ephemeral,
                        ephemeralWallet: this.options.wallet.ephemeral,
                        value: sbcCalls.value,
                    });
                    metadataTx.tx_hash = convertTo32Bytes(hash);
                    this.options.emitter.emit(SOURCE_SWAP_HASH([BigInt(chain.id), hash], this.options.chainList));
                    waitingPromises.push(wrap(Number(chainID), waitForTxReceipt(hash, publicClient, 2)));
                }
                else {
                    logger$2.debug('sourceSwapsHandler', {
                        calls: sbcCalls.calls,
                    });
                    waitingPromises.push((async () => {
                        logger$2.debug('waitingPromises:1');
                        const ops = await vscSBCTx([
                            await createSBCTxFromCalls({
                                cache: this.options.cache,
                                calls: sbcCalls.calls,
                                chainID: chain.id,
                                ephemeralAddress: this.options.address.ephemeral,
                                ephemeralWallet: this.options.wallet.ephemeral,
                                publicClient,
                            }),
                        ], this.options.networkConfig.VSC_DOMAIN);
                        const [chainID, hash] = ops[0];
                        metadataTx.tx_hash = convertTo32Bytes(hash);
                        this.options.emitter.emit(SOURCE_SWAP_HASH([chainID, hash], this.options.chainList));
                        return wrap(Number(chainID), waitForTxReceipt(hash, this.options.publicClientList.get(chainID), 2));
                    })());
                }
            }
            assets.push({
                amount: divDecimals(amount, getTokenDecimals(Number(chainID), swaps[0].outputToken).decimals),
                chainID: Number(chainID),
                tokenAddress: convertToEVMAddress(swaps[0].outputToken),
            });
            metadata.src.push(metadataTx);
        }
        // 3. Check status of all source swaps
        // Refund COT(Ephemeral -> EOA) on failure of any source swap post retry
        {
            const responses = await Promise.allSettled(waitingPromises);
            const someSrcSwapFailed = responses.some((r) => r.status === 'rejected');
            const successfulSwaps = responses.filter((r) => r.status === 'fulfilled').map((r) => r.value);
            const failedChains = chains.filter((c) => !successfulSwaps.includes(Number(c)));
            logger$2.debug('sourceSwapProcessResults', {
                failedChains,
                responses,
                retry,
                someSrcSwapFailed,
                successfulSwaps,
                waitingPromises,
            });
            // Sweep from all other src swap if any failed
            if (someSrcSwapFailed) {
                if (retry) {
                    try {
                        const response = await this.retryWithSlippageCheck(metadata, failedChains);
                        return response;
                    }
                    catch (e) {
                        logger$2.debug('src swp failed', {
                            e,
                            successfulSwaps,
                        });
                        const sbcTxs = [];
                        for (const chainID of successfulSwaps) {
                            sbcTxs.push(await createSBCTxFromCalls({
                                cache: this.options.cache,
                                calls: createSweeperTxs({
                                    cache: this.options.cache,
                                    chainID,
                                    COTCurrencyID: this.options.cot.currencyID,
                                    receiver: this.options.address.eoa,
                                    sender: this.options.address.ephemeral,
                                }),
                                chainID: chainID,
                                ephemeralAddress: this.options.address.ephemeral,
                                ephemeralWallet: this.options.wallet.ephemeral,
                                publicClient: this.options.publicClientList.get(chainID),
                            }));
                        }
                        try {
                            const ops = await vscSBCTx(sbcTxs, this.options.networkConfig.VSC_DOMAIN);
                            await waitForSBCTxReceipt(ops, this.options.chainList, this.options.publicClientList);
                        }
                        catch {
                            // TODO: What to do here? Store it or something?
                        }
                        throw new Error('source swap failed');
                    }
                }
                else {
                    throw new Error('some source swap failed even after retry');
                }
            }
            return assets;
        }
    }
    async retryWithSlippageCheck(metadata, failedChains) {
        let oldTotalOutputAmount = 0n;
        logger$2.debug('sourceSwapsHandler:retryWithSlippageCheck:0', {
            failedChains,
        });
        const quoteResponses = await esToolkit.retry(() => {
            const quoteRequests = [];
            // if it comes to retry it should be set to 0
            oldTotalOutputAmount = 0n;
            for (const fChain of failedChains) {
                const oldQuotes = this.swaps.get(fChain);
                if (!oldQuotes) {
                    logger$2.debug('how can old quote not be there???? we are iterating on it');
                    continue;
                }
                for (const oq of oldQuotes) {
                    oldTotalOutputAmount += oq.quote.outputAmountMinimum;
                    logger$2.debug('retryWithSlippage:quoteRequests:1', {
                        holding: {
                            amount: oq.quote.inputAmount,
                            tokenAddress: oq.req.inputToken,
                        },
                    });
                    quoteRequests.push(caCommon.liquidateInputHoldings(oq.req.userAddress, [
                        {
                            ...oq.originalHolding,
                            amount: oq.quote.inputAmount,
                            tokenAddress: oq.req.inputToken,
                        },
                    ], this.options.aggregators, [], oq.cur.currencyID).then((nq) => {
                        logger$2.debug('retryWithSlippage:quoteRequests:2', {
                            returnData: {},
                        });
                        return nq.quotes[0];
                    }));
                }
            }
            return Promise.all(quoteRequests);
        }, 2);
        logger$2.debug('sourceSwapsHandler:retryWithSlippageCheck:1', {
            oldTotalOutputAmount,
            quoteResponses,
        });
        let newTotalOutputAmount = 0n;
        for (const q of quoteResponses) {
            newTotalOutputAmount += q.quote.outputAmountMinimum;
        }
        const diff = oldTotalOutputAmount - newTotalOutputAmount;
        if (diff > 0) {
            if (!this.isSwapQuoteValid({
                newAmount: newTotalOutputAmount,
                oldAmount: oldTotalOutputAmount,
                slippage: this.options.slippage,
            })) {
                throw new Error('slippage greater than max slippage');
            }
        }
        logger$2.debug('sourceSwapsHandler:retryWithSlippageCheck:2', {
            diff,
            newTotalOutputAmount,
            oldTotalOutputAmount,
        });
        return this.process(metadata, this.groupAndOrder(quoteResponses), false);
    }
    groupAndOrder(input) {
        return Map.groupBy(esToolkit.orderBy(input, [
            (s) => 
            // if native currency is involved move it up
            equalFold(convertToEVMAddress(s.req.inputToken), EADDRESS) ? -1 : 1,
        ], ['asc']), (s) => s.req.chain.chainID);
    }
    isSwapQuoteValid({ newAmount, oldAmount, slippage, }) {
        const minAcceptable = Decimal__default.default.mul(oldAmount, Decimal__default.default.sub(1, slippage));
        logger$2.debug('isSwapQuoteValid', {
            minAcceptable: minAcceptable.toFixed(),
            newAmount,
            oldAmount,
        });
        return new Decimal__default.default(newAmount).gte(minAcceptable);
    }
}
class Swap {
    constructor(input) {
        this.input = input;
        this.txs = null;
    }
    getMetadata() {
        const txs = this.getTxsData();
        const { decimals: inputDecimals } = getTokenDecimals(Number(this.input.req.chain.chainID), this.input.req.inputToken);
        const { decimals: outputDecimals } = getTokenDecimals(Number(this.input.req.chain.chainID), this.input.req.outputToken);
        return {
            agg: 1,
            input_amt: convertTo32Bytes(this.input.req.inputAmount),
            input_contract: this.input.req.inputToken,
            input_decimals: inputDecimals,
            output_amt: convertTo32Bytes(txs.amount),
            output_contract: this.input.req.outputToken,
            output_decimals: outputDecimals,
        };
    }
    getTxsData() {
        return {
            ...getTxsFromQuote(this.input.agg, this.input.quote, this.input.req.inputToken, !bytesEqual(EADDRESS_32_BYTES, this.input.req.inputToken)),
            outputToken: this.input.req.outputToken,
        };
    }
}
// class SwapGroup {
//   requoted = true;
//   constructor(
//     public swaps: Swap[],
//     public chainID: number,
//   ) {}
//   execute() {
//     // Requote
//     // Execute
//   }
//   requote() {}
// }
const wrap = async (chainID, promise) => {
    await promise;
    return chainID;
};

const logger$1 = getLogger();
const ErrorUserDeniedIntent = new Error('User denied swap');
const swap = async (input, options, COT = caCommon.CurrencyID.USDC) => {
    performance.clearMarks();
    performance.clearMeasures();
    const publicClientList = new PublicClientList(options.chainList);
    const cache = new Cache(publicClientList);
    const dstChain = options.chainList.getChainByID(input.data.toChainId);
    if (!dstChain) {
        throw new Error('destination chain not supported');
    }
    performance.mark('swap-start');
    const emitter = {
        emit: (step) => {
            options.emit('swap_step', step);
        },
    };
    emitter.emit(SWAP_START);
    logger$1.debug('swapBegin', { options, input });
    performance.mark('determine-swaps-start');
    emitter.emit(DETERMINING_SWAP());
    const aggregators = [
        new caCommon.LiFiAggregator(LIFI_API_KEY),
        new caCommon.BebopAggregator(BEBOP_API_KEY),
        // new ZeroExAggregator(ZERO_X_API_KEY),
    ];
    const swapRouteParams = { ...options, aggregators, cotCurrencyID: COT };
    const [swapRoute, dstTokenInfo] = await Promise.all([
        determineSwapRoute(input, swapRouteParams),
        getTokenInfo(input.data.toTokenAddress, publicClientList.get(input.data.toChainId), dstChain),
    ]);
    logger$1.debug('initial-swap-route', {
        dstTokenInfo,
        swapRoute,
    });
    let { assetsUsed, bridgeInput, destinationSwap, sourceSwaps } = swapRoute;
    logger$1.debug('initial-swap-route', {
        assetsUsed,
        bridgeInput,
        destinationSwap,
        dstTokenInfo,
        sourceSwaps,
        swapRoute,
    });
    emitter.emit(DETERMINING_SWAP(true));
    performance.mark('determine-swaps-end');
    performance.mark('xcs-ops-start');
    // Swap Intent hook handling
    {
        if (options?.swapIntentHook) {
            const hook = options?.swapIntentHook;
            const destination = {
                amount: divDecimals(input.mode === commons.SwapMode.EXACT_OUT ? input.data.toAmount : destinationSwap.outputAmount, dstTokenInfo.decimals).toFixed(),
                chainID: input.data.toChainId,
                contractAddress: input.data.toTokenAddress,
                decimals: dstTokenInfo.decimals,
                symbol: dstTokenInfo.symbol,
            };
            let accepted = false;
            const refresh = async () => {
                if (accepted) {
                    logger$1.warn('Swap Intent refresh called after acceptance');
                    return createSwapIntent(assetsUsed, destination, options.chainList);
                }
                const swapRouteResponse = await determineSwapRoute(input, swapRouteParams);
                sourceSwaps = swapRouteResponse.sourceSwaps;
                assetsUsed = swapRouteResponse.assetsUsed;
                destinationSwap = swapRouteResponse.destinationSwap;
                bridgeInput = swapRouteResponse.bridgeInput;
                logger$1.debug('refresh-swap-route', {
                    dstTokenInfo,
                    swapRoute: swapRouteResponse,
                });
                return createSwapIntent(assetsUsed, destination, options.chainList);
            };
            // wait for intent acceptance hook
            await new Promise((resolve, reject) => {
                const allow = () => {
                    accepted = true;
                    return resolve('User allowed intent');
                };
                const deny = () => {
                    return reject(ErrorUserDeniedIntent);
                };
                hook({
                    allow,
                    deny,
                    intent: createSwapIntent(assetsUsed, destination, options.chainList),
                    refresh,
                });
            });
        }
    }
    const metadata = {
        dst: {
            chid: convertTo32Bytes(input.data.toChainId),
            swaps: [],
            tx_hash: ZERO_BYTES_32,
            univ: caCommon.Universe.ETHEREUM,
        },
        has_xcs: true,
        rff_id: 0n,
        src: [],
    };
    const opt = {
        address: options.address,
        aggregators,
        cache,
        chainList: options.chainList,
        cot: {
            currencyID: COT,
            symbol: caCommon.CurrencyID[COT],
        },
        destinationChainID: input.data.toChainId,
        emitter,
        networkConfig: options.networkConfig,
        publicClientList,
        slippage: 0.005,
        wallet: options.wallet,
    };
    const srcSwapsHandler = new SourceSwapsHandler(sourceSwaps, opt);
    const bridgeHandler = new BridgeHandler(bridgeInput, opt);
    const dstSwapHandler = new DestinationSwapHandler({ ...destinationSwap, getDDS: swapRoute.getDDS }, dstTokenInfo, {
        chainID: input.data.toChainId,
        token: input.data.toTokenAddress,
        amount: input.mode === commons.SwapMode.EXACT_OUT ? input.data.toAmount : destinationSwap.outputAmount,
    }, opt);
    performance.mark('allowance-cache-start');
    await cache.process();
    performance.mark('allowance-cache-end');
    // 0.5: Destination swap: create permit
    await dstSwapHandler.createPermit();
    // 1: Source swap
    const assets = await srcSwapsHandler.process(metadata);
    // 2: Bridge, takes source swap output as input so bridge assets are adjusted accordingly
    // wait for RFF Fill (if RFF required)
    await bridgeHandler.process(metadata, assets);
    // 3: Destination swap
    await dstSwapHandler.process(metadata);
    const result = convertMetadataToSwapResult(metadata, options.networkConfig.EXPLORER_URL);
    performance.mark('swap-end');
    try {
        const id = await postSwap({
            metadata,
            wallet: options.wallet.ephemeral,
        });
        logger$1.debug('SwapID', { id });
    }
    catch (e) {
        logger$1.error('postSwap', e);
    }
    calculatePerformance();
    return result;
};
const calculatePerformance = () => {
    try {
        const measures = [];
        measures.push(performance.measure('xcs-total-duration', 'swap-start', 'swap-end'), performance.measure('xcs-ops-duration', 'xcs-ops-start', 'xcs-ops-end'), performance.measure('allowance-calls-duration', 'allowance-cache-start', 'allowance-cache-end'), performance.measure('determine-swaps-duration', 'determine-swaps-start', 'determine-swaps-end'));
        const entries = performance.getEntries();
        if (entries.find((entry) => entry.name === 'source-swap-tx-start')) {
            measures.push(performance.measure('source-swap-tx-duration', 'source-swap-tx-start', 'source-swap-tx-end'), performance.measure('source-swap-mining-duration', 'source-swap-mining-start', 'source-swap-mining-end'));
        }
        measures.push(performance.measure('fill-wait-duration', 'fill-wait-start', 'fill-wait-end'), performance.measure('destination-swap-tx-duration', 'destination-swap-start', 'destination-swap-end'), performance.measure('destination-swap-mining-duration', 'destination-swap-mining-start', 'destination-swap-mining-end'));
        console.log('Timings for XCS:');
        measures.forEach((measure) => {
            console.log(`${measure.name}: ${measure.duration}`);
        });
    }
    catch (e) {
        logger$1.error('calculatePerformance', e);
    }
    finally {
        performance.clearMarks();
        performance.clearMeasures();
    }
};

var _CA_cosmosWallet, _CA_ephemeralWallet;
setLogLevel(LOG_LEVEL.NOLOGS);
const logger = getLogger();
var INIT_STATUS;
(function (INIT_STATUS) {
    INIT_STATUS[INIT_STATUS["CREATED"] = 0] = "CREATED";
    INIT_STATUS[INIT_STATUS["RUNNING"] = 1] = "RUNNING";
    INIT_STATUS[INIT_STATUS["DONE"] = 2] = "DONE";
})(INIT_STATUS || (INIT_STATUS = {}));
const SIWE_STATEMENT = 'Sign in to enable Nexus';
class CA {
    constructor(config = { debug: false, network: 'testnet' }) {
        this._caEvents = new SafeEventEmitter__default.default();
        _CA_cosmosWallet.set(this, void 0);
        _CA_ephemeralWallet.set(this, void 0);
        this._hooks = {
            onAllowance: (data) => data.allow(data.sources.map(() => 'max')),
            onIntent: (data) => data.allow(),
        };
        this._initPromises = [];
        this._initStatus = INIT_STATUS.CREATED;
        this._isArcanaProvider = false;
        this._deinit = () => {
            tslib.__classPrivateFieldSet(this, _CA_cosmosWallet, undefined, "f");
            if (this._evm) {
                this._evm.provider.removeListener('accountsChanged', this.onAccountsChanged);
            }
            if (this._refundInterval) {
                clearInterval(this._refundInterval);
                this._refundInterval = undefined;
            }
            this._initStatus = INIT_STATUS.CREATED;
        };
        this._getEVMProviderWithCA = () => {
            if (!this._evm) {
                throw new Error('EVM provider is not set');
            }
            return this._evm.modProvider;
        };
        this._init = async () => {
            if (!this._evm) {
                throw new Error('use setEVMProvider before calling init()');
            }
            if (this._initStatus === INIT_STATUS.CREATED) {
                this._initStatus = INIT_STATUS.RUNNING;
                try {
                    const address = await this._getEVMAddress();
                    this._setProviderHooks();
                    if (!this._isArcanaProvider) {
                        tslib.__classPrivateFieldSet(this, _CA_cosmosWallet, await this._createCosmosWallet(), "f");
                        this._checkPendingRefunds();
                    }
                    this._initStatus = INIT_STATUS.DONE;
                    this._resolveInitPromises();
                    this._caEvents.emit('accountsChanged', [address]);
                }
                catch (e) {
                    this._initStatus = INIT_STATUS.CREATED;
                    logger.error('Error initializing CA', e);
                    throw new Error('Error initializing CA');
                }
            }
            else if (this._initStatus === INIT_STATUS.RUNNING) {
                return await this._waitForInit();
            }
        };
        this.onAccountsChanged = (accounts) => {
            this._deinit();
            if (accounts.length !== 0) {
                this._init();
            }
        };
        this._config = getSDKConfig(config);
        this._networkConfig = getNetworkConfig(this._config.network);
        this.chainList = new ChainList(this._networkConfig.NETWORK_HINT);
        if (this._config.debug) {
            setLogLevel(LOG_LEVEL.DEBUG);
        }
    }
    _allowance() {
        if (!this._evm) {
            throw new Error('EVM provider is not set');
        }
        return new AllowanceQuery(this._evm.client, this._networkConfig, this.chainList);
    }
    async _bridge(input) {
        const bq = new BridgeQuery(input, this._init, this._changeChain.bind(this), this._createEVMHandler.bind(this), this._createFuelHandler.bind(this), await this._getEVMAddress(), this.chainList, this._fuel?.account);
        await bq.initHandler();
        return { exec: bq.exec, simulate: bq.simulate };
    }
    async _getFuelWithCA() {
        if (!this._fuel) {
            throw new Error('Fuel connector is not set.');
        }
        return {
            connector: this._fuel.modConnector,
            provider: this._fuel.modProvider,
        };
    }
    async _getMyIntents(page = 1) {
        const wallet = await this._getCosmosWallet();
        const address = (await wallet.getAccounts())[0].address;
        return fetchMyIntents(address, this._networkConfig.GRPC_URL, page);
    }
    async _getUnifiedBalance(symbol) {
        const balances = await this._getUnifiedBalances();
        return balances.find((s) => equalFold(s.symbol, symbol));
    }
    async _getUnifiedBalances() {
        if (!this._evm) {
            throw new Error('CA not initialized');
        }
        const { assets } = await getBalances({
            networkHint: this._networkConfig.NETWORK_HINT,
            evmAddress: (await this._evm.client.requestAddresses())[0],
            chainList: this.chainList,
            filter: false,
            vscDomain: this._networkConfig.VSC_DOMAIN,
            fuelAddress: this._fuel?.address,
        });
        return assets;
    }
    _isInitialized() {
        return this._initStatus === INIT_STATUS.DONE;
    }
    async _swapWithExactIn(input, options) {
        return swap({
            mode: commons.SwapMode.EXACT_IN,
            data: input,
        }, await this.getCommonSwapParams(options));
    }
    async _swapWithExactOut(input, options) {
        return swap({
            mode: commons.SwapMode.EXACT_OUT,
            data: input,
        }, await this.getCommonSwapParams(options));
    }
    async getCommonSwapParams(options) {
        return {
            emit: this._caEvents.emit.bind(this._caEvents),
            chainList: this.chainList,
            address: {
                cosmos: (await tslib.__classPrivateFieldGet(this, _CA_cosmosWallet, "f").getAccounts())[0].address,
                eoa: (await this._evm.client.getAddresses())[0],
                ephemeral: tslib.__classPrivateFieldGet(this, _CA_ephemeralWallet, "f").address,
            },
            wallet: {
                cosmos: tslib.__classPrivateFieldGet(this, _CA_cosmosWallet, "f"),
                ephemeral: tslib.__classPrivateFieldGet(this, _CA_ephemeralWallet, "f"),
                eoa: this._evm.client,
            },
            networkConfig: this._networkConfig,
            ...options,
        };
    }
    async _handleEVMTx(args, options = {}) {
        const response = await this._createEVMHandler(args.params[0], getTxOptions(options));
        if (response) {
            await response.handler?.process();
            return response.processTx();
        }
        return;
    }
    async _setEVMProvider(provider) {
        if (this._evm?.provider === provider) {
            return;
        }
        this._evm = {
            client: viem.createWalletClient({
                transport: viem.custom(provider),
            }).extend(viem.publicActions),
            modProvider: Object.assign({}, provider, {
                request: async (args) => {
                    if (args.method === 'eth_sendTransaction') {
                        if (!this._isArcanaProvider) {
                            return this._handleEVMTx(args);
                        }
                    }
                    return provider.request(args);
                },
            }),
            provider,
        };
        this._isArcanaProvider = isArcanaWallet(provider);
    }
    async _setFuelConnector(connector) {
        if (this._fuel?.connector === connector) {
            return;
        }
        logger.debug('setFuelConnector', {
            connected: connector.connected,
            connector: connector,
        });
        if (!(await connector.isConnected())) {
            await connector.connect();
        }
        const address = await connector.currentAccount();
        if (!address) {
            throw new Error('could not get current account from connector');
        }
        const modProvider = getFuelProvider(this._getUnifiedBalances.bind(this), address, this.chainList.getChainByID(fuels.CHAIN_IDS.fuel.mainnet));
        const provider = new fuels.Provider(FUEL_NETWORK_URL, {
            resourceCacheTTL: -1,
        });
        const clone = Object.create(connector);
        clone.sendTransaction = async (_address, _transaction, _params) => {
            logger.debug('fuelClone:sendTransaction:1', {
                _address,
                _params,
                _transaction,
            });
            const handlerResponse = await this._createFuelHandler(_transaction, {
                bridge: false,
                gas: 0n,
            });
            if (handlerResponse) {
                await handlerResponse.handler?.process();
            }
            logger.debug('fuelClone:sendTransaction:2', {
                request: Object.assign({
                    inputs: [],
                }, _transaction),
            });
            const tx = await fixTx(_address, _transaction, provider);
            return connector.sendTransaction(_address, tx, _params);
        };
        this._fuel = {
            account: new fuels.Account(address, modProvider, connector),
            address,
            connector: connector,
            modConnector: clone,
            modProvider,
            provider,
        };
    }
    _setOnAllowanceHook(hook) {
        this._hooks.onAllowance = hook;
    }
    _setOnIntentHook(hook) {
        this._hooks.onIntent = hook;
    }
    async _transfer(input) {
        const tq = new TransferQuery(input, this._init, this._changeChain.bind(this), this._createEVMHandler.bind(this), this._createFuelHandler.bind(this), await this._getEVMAddress(), this.chainList, this._fuel?.account);
        await tq.initHandler();
        return { exec: tq.exec, simulate: tq.simulate };
    }
    _changeChain(chainID) {
        if (!this._evm) {
            throw new Error('EVM provider is not set');
        }
        const chain = this.chainList.getChainByID(chainID);
        if (!chain) {
            throw new Error('chain not supported');
        }
        return switchChain(this._evm.client, chain);
    }
    async _checkPendingRefunds() {
        await this._init();
        const account = await this._getEVMAddress();
        try {
            await refundExpiredIntents(account, this._networkConfig.COSMOS_URL, tslib.__classPrivateFieldGet(this, _CA_cosmosWallet, "f"));
            this._refundInterval = window.setInterval(async () => {
                await refundExpiredIntents(account, this._networkConfig.COSMOS_URL, tslib.__classPrivateFieldGet(this, _CA_cosmosWallet, "f"));
            }, minutesToMs(10));
        }
        catch (e) {
            logger.error('Error checking pending refunds', e);
        }
    }
    async _createCosmosWallet() {
        const sig = await this._signatureForLogin();
        const pvtKey = starkwareCryptoUtils.keyDerivation.getPrivateKeyFromEthSignature(sig);
        const cosmosWallet = await caCommon.createCosmosWallet(`0x${pvtKey.padStart(64, '0')}`);
        tslib.__classPrivateFieldSet(this, _CA_ephemeralWallet, accounts.privateKeyToAccount(`0x${pvtKey.padStart(64, '0')}`), "f");
        const address = (await cosmosWallet.getAccounts())[0].address;
        await cosmosFeeGrant(this._networkConfig.COSMOS_URL, this._networkConfig.VSC_DOMAIN, address);
        return cosmosWallet;
    }
    async _createEVMHandler(tx, options = {}) {
        if (!this._evm) {
            throw new Error('EVM provider is not set');
        }
        if (!isEVMTx(tx)) {
            logger.debug('invalid evm tx, returning', { tx });
            return null;
        }
        const opt = getTxOptions(options);
        const chainId = await this._getChainID();
        const chain = this.chainList.getChainByID(chainId);
        if (!chain) {
            logger.info('chain not supported, returning', {
                chainId,
            });
            return null;
        }
        return createHandler({
            chain,
            chainList: this.chainList,
            cosmosWallet: await this._getCosmosWallet(),
            evm: {
                address: await this._getEVMAddress(),
                client: this._evm.client,
                tx,
            },
            fuel: this._fuel,
            hooks: this._hooks,
            options: {
                emit: this._caEvents.emit.bind(this._caEvents),
                networkConfig: this._networkConfig,
                ...opt,
            },
        });
    }
    getEVMClient() {
        if (!this._evm) {
            throw new Error('EVM provider is not set');
        }
        return this._evm.client;
    }
    async _createFuelHandler(tx, options = {}) {
        const chain = this.chainList.getChainByID(fuels.CHAIN_IDS.fuel.mainnet);
        if (!chain) {
            throw new Error(`chain not found: ${fuels.CHAIN_IDS.fuel.mainnet}`);
        }
        if (!this._fuel) {
            throw new Error('Fuel provider is not connected');
        }
        const address = await this._fuel.connector.currentAccount();
        if (!address) {
            throw new Error('could not get current account from connector');
        }
        const opt = getTxOptions(options);
        return createHandler({
            chain,
            chainList: this.chainList,
            cosmosWallet: await this._getCosmosWallet(),
            evm: {
                address: await this._getEVMAddress(),
                client: this._evm.client,
            },
            fuel: {
                address,
                connector: this._fuel.connector,
                provider: this._fuel.provider,
                tx,
            },
            hooks: {
                onAllowance: this._hooks.onAllowance,
                onIntent: this._hooks.onIntent,
            },
            options: {
                emit: this._caEvents.emit.bind(this._caEvents),
                networkConfig: this._networkConfig,
                ...opt,
            },
        });
    }
    _getChainID() {
        if (!this._evm) {
            throw new Error('EVM provider is not set');
        }
        return this._evm.client.getChainId();
    }
    async _getCosmosWallet() {
        if (!tslib.__classPrivateFieldGet(this, _CA_cosmosWallet, "f")) {
            tslib.__classPrivateFieldSet(this, _CA_cosmosWallet, await this._createCosmosWallet(), "f");
        }
        return tslib.__classPrivateFieldGet(this, _CA_cosmosWallet, "f");
    }
    async _getEVMAddress() {
        if (!this._evm) {
            throw new Error('EVM provider is not set');
        }
        return (await this._evm.client.requestAddresses())[0];
    }
    _resolveInitPromises() {
        const list = this._initPromises;
        this._initPromises = [];
        for (const r of list) {
            r();
        }
    }
    async _setProviderHooks() {
        if (!this._evm) {
            throw new Error('EVM provider is not set');
        }
        if (this._evm.provider) {
            this._evm.provider.on('accountsChanged', this.onAccountsChanged);
        }
    }
    async _signatureForLogin() {
        if (!this._evm) {
            throw new Error('EVM provider is not set');
        }
        const scheme = window.location.protocol.slice(0, -1);
        const domain = window.location.host;
        const origin = window.location.origin;
        const address = await this._getEVMAddress();
        const message = siwe.createSiweMessage({
            address,
            chainId: 1,
            domain,
            issuedAt: new Date('2024-12-16T12:17:43.182Z'), // this remains same to arrive at same pvt key
            nonce: 'iLjYWC6s8frYt4l8w', // maybe this can be shortened hash of address
            scheme,
            statement: SIWE_STATEMENT,
            uri: origin,
            version: '1',
        });
        const currentChain = await this._getChainID();
        try {
            await this._evm.client.switchChain({ id: 1 });
            const res = await this._evm.client.signMessage({
                account: address,
                message,
            });
            return res;
        }
        finally {
            await this._evm.client.switchChain({ id: currentChain });
        }
    }
    async _waitForInit() {
        const promise = new Promise((resolve) => {
            this._initPromises.push(resolve);
        });
        return await promise;
    }
    _getSwapSupportedChainsAndTokens() {
        return getSwapSupportedChains(this.chainList);
    }
}
_CA_cosmosWallet = new WeakMap(), _CA_ephemeralWallet = new WeakMap();
CA.getSupportedChains = getSupportedChains;

/**
 * Check if a chain is supported
 */
function isSupportedChain(chainId) {
    return Object.values(commons.SUPPORTED_CHAINS).includes(chainId);
}
/**
 * Check if a token is supported
 */
function isSupportedToken(token) {
    const supportedTokens = ['ETH', 'USDC', 'USDT'];
    return supportedTokens.includes(token.toUpperCase());
}

/**
 * Service responsible for transaction handling and preparation
 */
class TransactionService {
    constructor(adapter) {
        this.adapter = adapter;
        // Flag to enable/disable gas estimation (can be set via constructor or method)
        this.enableGasEstimation = true;
    }
    /**
     * Enable or disable gas estimation before transaction execution
     */
    setGasEstimationEnabled(enabled) {
        this.enableGasEstimation = enabled;
    }
    /**
     * Estimate gas for a transaction before execution
     */
    async estimateTransactionGas(provider, transactionParams) {
        commons.logger.info('TransactionService - Starting gas estimation...');
        commons.logger.info('TransactionService - Transaction params:', {
            from: transactionParams.from,
            to: transactionParams.to,
            data: transactionParams.data.slice(0, 50) + '...', // Truncate for logging
            value: transactionParams.value,
        });
        try {
            // Step 1: Estimate gas
            const gasEstimate = (await provider.request({
                method: 'eth_estimateGas',
                params: [transactionParams],
            }));
            const gasEstimateDecimal = parseInt(gasEstimate, 16);
            commons.logger.info('TransactionService - Gas estimation successful:', {
                gasEstimateHex: gasEstimate,
                gasEstimateDecimal: gasEstimateDecimal,
                gasEstimateFormatted: gasEstimateDecimal.toLocaleString(),
            });
            // Step 2: Get current gas price for cost calculation
            let gasPriceGwei;
            let estimatedCostEth;
            try {
                const gasPrice = (await provider.request({
                    method: 'eth_gasPrice',
                }));
                const gasPriceDecimal = parseInt(gasPrice, 16);
                const estimatedCostWei = gasEstimateDecimal * gasPriceDecimal;
                const estimatedCostEthNum = estimatedCostWei / 1e18;
                gasPriceGwei = (gasPriceDecimal / 1e9).toFixed(4) + ' gwei';
                estimatedCostEth = estimatedCostEthNum.toFixed(8) + ' ETH';
                commons.logger.info('TransactionService - Gas cost estimation:', {
                    gasPriceHex: gasPrice,
                    gasPriceGwei: gasPriceGwei,
                    estimatedCostWei: estimatedCostWei.toString(),
                    estimatedCostEth: estimatedCostEth,
                });
            }
            catch (gasPriceError) {
                commons.logger.warn('TransactionService - Failed to get gas price:', gasPriceError);
            }
            return {
                success: true,
                gasEstimate,
                gasEstimateDecimal,
                gasPriceGwei,
                estimatedCostEth,
            };
        }
        catch (gasEstimateError) {
            commons.logger.error('TransactionService - Gas estimation failed:', gasEstimateError);
            // Extract revert reason if available
            let revertReason;
            let errorMessage = 'Gas estimation failed';
            if (gasEstimateError && typeof gasEstimateError === 'object') {
                if ('data' in gasEstimateError && gasEstimateError.data) {
                    commons.logger.error('TransactionService - Gas estimation revert data:', gasEstimateError.data);
                    revertReason = JSON.stringify(gasEstimateError.data);
                }
                if ('message' in gasEstimateError && gasEstimateError.message) {
                    errorMessage = gasEstimateError.message;
                    commons.logger.error('TransactionService - Gas estimation error message:', errorMessage);
                    // Extract common revert patterns
                    if (errorMessage.includes('execution reverted')) {
                        const revertMatch = errorMessage.match(/execution reverted:?\s*(.+)/i);
                        if (revertMatch && revertMatch[1]) {
                            revertReason = revertMatch[1].trim();
                        }
                        else {
                            revertReason = 'Transaction would revert (no reason provided)';
                        }
                    }
                    else if (errorMessage.includes('insufficient funds')) {
                        revertReason = 'Insufficient funds for gas * price + value';
                    }
                    else if (errorMessage.includes('out of gas')) {
                        revertReason = 'Transaction would run out of gas';
                    }
                }
            }
            return {
                success: false,
                error: errorMessage,
                revertReason,
            };
        }
    }
    /**
     * Ensure we're on the correct chain, switch if needed
     */
    async ensureCorrectChain(targetChainId) {
        try {
            const currentChainId = await this.adapter.nexusSDK.getEVMClient().getChainId();
            if (currentChainId !== targetChainId) {
                try {
                    await this.adapter.nexusSDK.getEVMClient().switchChain({ id: targetChainId });
                    return { success: true };
                }
                catch (switchError) {
                    if (switchError &&
                        typeof switchError === 'object' &&
                        'code' in switchError &&
                        switchError.code === 4902) {
                        throw new Error(`Chain ${targetChainId} is not configured in wallet. Please add it manually.`);
                    }
                    throw switchError;
                }
            }
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: commons.extractErrorMessage(error, 'chain switching'),
            };
        }
    }
    /**
     * Prepare execution by validating parameters and encoding function call
     */
    async prepareExecution(params) {
        // Get the from address first (needed for callback)
        const fromAddress = await this.adapter.nexusSDK.getEVMClient().getAddresses();
        if (!fromAddress || fromAddress.length === 0) {
            throw new Error('No accounts available');
        }
        // Ensure we're on the correct chain
        const chainResult = await this.ensureCorrectChain(params.toChainId);
        if (!chainResult.success) {
            throw new Error(`Failed to switch to chain ${params.toChainId}: ${chainResult.error}`);
        }
        // Call buildFunctionParams callback to get the actual function parameters
        // For ETH transactions, provide ETH as token and 0 as amount if tokenApproval is undefined
        const token = params.tokenApproval?.token || 'ETH';
        const amount = params.tokenApproval?.amount || '0';
        const { functionParams, value: callbackValue } = params.buildFunctionParams(token, amount, params.toChainId, fromAddress[0]);
        // Validate contract parameters with built function params
        const validation = commons.validateContractParams({
            contractAddress: params.contractAddress,
            contractAbi: params.contractAbi,
            functionName: params.functionName,
            functionParams,
            chainId: params.toChainId,
        });
        if (!validation.isValid) {
            throw new Error(`Invalid contract parameters: ${validation.error}`);
        }
        // Encode the function call
        const encodingResult = commons.encodeContractCall({
            contractAbi: params.contractAbi,
            functionName: params.functionName,
            functionParams,
        });
        if (!encodingResult.success) {
            throw new Error(`Failed to encode contract call: ${encodingResult.error}`);
        }
        return {
            provider: this.adapter.nexusSDK.getEVMProviderWithCA(),
            fromAddress: fromAddress[0],
            encodedData: encodingResult.data,
            value: callbackValue,
        };
    }
    /**
     * Send transaction with enhanced error handling and polling support
     */
    async sendTransaction(provider, fromAddress, contractAddress, encodedData, value, options) {
        const transactionParams = {
            from: fromAddress,
            to: contractAddress,
            data: encodedData,
            value: value || '0x0',
        };
        try {
            // Perform gas estimation if enabled
            if (this.enableGasEstimation) {
                commons.logger.info('TransactionService - Performing pre-execution gas estimation...');
                const gasEstimation = await this.estimateTransactionGas(provider, transactionParams);
                if (!gasEstimation.success) {
                    commons.logger.error('TransactionService - Pre-execution gas estimation failed:', gasEstimation.error);
                    if (gasEstimation.revertReason) {
                        commons.logger.warn(`TransactionService - Transaction will likely fail: ${gasEstimation.revertReason}`);
                        throw new Error(`Transaction simulation failed: ${gasEstimation.revertReason}`);
                    }
                }
                else {
                    commons.logger.info('TransactionService - Gas estimation completed successfully:', {
                        gasEstimate: gasEstimation.gasEstimate,
                        estimatedCost: gasEstimation.estimatedCostEth,
                        gasPrice: gasEstimation.gasPriceGwei,
                    });
                }
            }
            else {
                commons.logger.info('TransactionService - Gas estimation disabled, proceeding with transaction');
            }
            commons.logger.info('TransactionService - Sending transaction...');
            const response = await provider.request({
                method: 'eth_sendTransaction',
                params: [transactionParams],
            });
            // Get transaction hash with fallback polling
            const hashResult = await commons.getTransactionHashWithFallback(provider, response, {
                enablePolling: options.enableTransactionPolling,
                timeout: options.transactionTimeout,
                fromAddress,
            });
            if (!hashResult.success || !hashResult.hash) {
                throw new Error(hashResult.error || 'Failed to retrieve transaction hash from provider response');
            }
            commons.logger.info('TransactionService - Transaction sent successfully:', {
                transactionHash: hashResult.hash,
            });
            return hashResult.hash;
        }
        catch (error) {
            // Enhanced error handling for common transaction failures
            if (error && typeof error === 'object' && 'code' in error) {
                if (error.code === 4001) {
                    throw new Error('Transaction rejected by user');
                }
                else if (error.code === -32e3) {
                    throw new Error('Insufficient funds for transaction');
                }
                else if (error.code === -32603) {
                    throw new Error('Internal JSON-RPC error during transaction');
                }
            }
            throw new Error(`Transaction failed: ${commons.extractErrorMessage(error, 'transaction')}`);
        }
    }
    /**
     * Handle transaction confirmation with receipt and confirmations
     */
    async handleTransactionConfirmation(provider, transactionHash, options, chainId) {
        if (!options.waitForReceipt) {
            return {};
        }
        try {
            const receiptResult = await commons.waitForTransactionReceipt(provider, transactionHash, {
                timeout: options.receiptTimeout,
                requiredConfirmations: options.requiredConfirmations,
            }, chainId);
            if (!receiptResult.success) {
                commons.logger.warn(`Failed to get transaction receipt: ${receiptResult.error}`);
                return {};
            }
            return {
                receipt: receiptResult.receipt,
                confirmations: receiptResult.confirmations,
                gasUsed: receiptResult.receipt?.gasUsed?.toString(),
                effectiveGasPrice: receiptResult.receipt?.effectiveGasPrice?.toString(),
            };
        }
        catch (error) {
            commons.logger.warn(`Receipt retrieval failed: ${commons.extractErrorMessage(error, 'receipt retrieval')}`);
            return {};
        }
    }
    /**
     * Build execute result with transaction information
     */
    buildExecuteResult(transactionHash, chainId, receiptInfo) {
        return {
            transactionHash,
            explorerUrl: commons.getBlockExplorerUrl(chainId, transactionHash),
            chainId,
            ...receiptInfo,
        };
    }
    /**
     * Direct native token transfer (ETH, MATIC, AVAX, etc.)
     */
    async transferNativeToken(provider, fromAddress, toAddress, amount, // Amount in human-readable format (e.g., "0.1")
    decimals = 18) {
        const { parseUnits } = await import('viem');
        const valueInWei = parseUnits(amount, decimals);
        const transactionParams = {
            from: fromAddress,
            to: toAddress,
            data: '0x',
            value: `0x${valueInWei.toString(16)}`,
        };
        try {
            // Perform gas estimation if enabled
            if (this.enableGasEstimation) {
                commons.logger.info('TransactionService - Performing gas estimation for native token transfer...');
                const gasEstimation = await this.estimateTransactionGas(provider, transactionParams);
                if (!gasEstimation.success) {
                    commons.logger.error('TransactionService - Gas estimation failed for native token transfer:', gasEstimation.error);
                    throw new Error(`Native token transfer gas estimation failed: ${gasEstimation.error}`);
                }
                commons.logger.info('TransactionService - Native token transfer gas estimation successful:', {
                    gasEstimate: gasEstimation.gasEstimate,
                    estimatedCost: gasEstimation.estimatedCostEth,
                });
            }
            commons.logger.info('TransactionService - Sending native token transfer...');
            const response = await provider.request({
                method: 'eth_sendTransaction',
                params: [transactionParams],
            });
            const transactionHash = commons.getTransactionHashWithFallback(provider, response);
            commons.logger.info('TransactionService - Native token transfer sent successfully:', transactionHash);
            return transactionHash;
        }
        catch (error) {
            commons.logger.error('TransactionService - Native token transfer failed:', error);
            throw new Error(`Native token transfer failed: ${commons.extractErrorMessage(error, 'native transfer')}`);
        }
    }
    /**
     * Direct ERC20 token transfer
     */
    async transferERC20Token(provider, fromAddress, tokenAddress, toAddress, amount, // Amount in human-readable format (e.g., "100")
    decimals = 18) {
        const { parseUnits } = await import('viem');
        try {
            const amountInWei = parseUnits(amount, decimals);
            // ERC20 transfer function selector: transfer(address,uint256)
            const transferSelector = '0xa9059cbb';
            const paddedRecipient = toAddress.slice(2).padStart(64, '0');
            const paddedAmount = amountInWei.toString(16).padStart(64, '0');
            const transferData = `${transferSelector}${paddedRecipient}${paddedAmount}`;
            const transactionParams = {
                from: fromAddress,
                to: tokenAddress,
                data: transferData,
                value: '0x0',
            };
            // Perform gas estimation if enabled
            if (this.enableGasEstimation) {
                commons.logger.info('TransactionService - Performing gas estimation for ERC20 transfer...');
                const gasEstimation = await this.estimateTransactionGas(provider, transactionParams);
                if (!gasEstimation.success) {
                    commons.logger.error('TransactionService - Gas estimation failed for ERC20 transfer:', gasEstimation.error);
                    if (gasEstimation.revertReason) {
                        throw new Error(`ERC20 transfer will fail: ${gasEstimation.revertReason}`);
                    }
                    throw new Error(`ERC20 transfer gas estimation failed: ${gasEstimation.error}`);
                }
                commons.logger.info('TransactionService - ERC20 transfer gas estimation successful:', {
                    gasEstimate: gasEstimation.gasEstimate,
                    estimatedCost: gasEstimation.estimatedCostEth,
                });
            }
            commons.logger.info('TransactionService - Sending ERC20 transfer...');
            const response = await provider.request({
                method: 'eth_sendTransaction',
                params: [transactionParams],
            });
            const transactionHash = commons.getTransactionHashWithFallback(provider, response);
            commons.logger.info('TransactionService - ERC20 transfer sent successfully:', transactionHash);
            return transactionHash;
        }
        catch (error) {
            commons.logger.error('TransactionService - ERC20 transfer failed:', error);
            throw new Error(`ERC20 transfer failed: ${commons.extractErrorMessage(error, 'ERC20 transfer')}`);
        }
    }
}

/**
 * Internal constants for adapter behavior
 */
const ADAPTER_CONSTANTS$1 = {
    // Default 2% buffer (200 bps) to handle precision issues. Can be overridden per-call via ExecuteParams.approvalBufferBps
    APPROVAL_BUFFER_BPS_DEFAULT: 200n,
    DEFAULT_DECIMALS: 18,
    MAX_APPROVAL_AMOUNT: '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',
};
/**
 * Service responsible for handling contract approvals
 */
class ApprovalService {
    constructor(adapter) {
        this.adapter = adapter;
    }
    /**
     * Check if approval is needed for a token spending operation
     */
    async checkApprovalNeeded(tokenApproval, spenderAddress, chainId, approvalBufferBps) {
        const accounts = await this.adapter.nexusSDK.getEVMClient().getAddresses();
        if (!accounts || accounts.length === 0) {
            throw new Error('No accounts available');
        }
        const ownerAddress = accounts[0];
        const tokenContractAddress = commons.getTokenContractAddress(tokenApproval.token, chainId);
        if (!tokenContractAddress) {
            throw new Error(`Token contract address not found for ${tokenApproval.token} on chain ${chainId}`);
        }
        try {
            // Convert amount to proper token units - handle both decimal and integer formats
            let amountInWei;
            // Get token metadata for decimal handling
            const tokenMetadata = commons.TOKEN_METADATA[tokenApproval.token.toUpperCase()];
            const decimals = tokenMetadata?.decimals || ADAPTER_CONSTANTS$1.DEFAULT_DECIMALS;
            try {
                // Handle both decimal strings (user-friendly) and integer strings (already converted)
                // This matches the logic from the legacy adapter
                if (tokenApproval.amount.includes('.')) {
                    // Decimal amount - user-friendly format like "0.01"
                    amountInWei = viem.parseUnits(tokenApproval.amount, decimals);
                }
                else {
                    // Integer amount - likely already in wei/micro format like "10000"
                    // For USDC and other 6-decimal tokens, check if this is already in micro-units
                    const amountNum = BigInt(tokenApproval.amount);
                    const USDC_THRESHOLD = 1000000n; // 1 USDC in micro-units
                    if (decimals === 6 && amountNum > USDC_THRESHOLD) {
                        // For USDC, large numbers are likely already in micro-units
                        amountInWei = amountNum;
                    }
                    else if (decimals === 18 && amountNum > 1000000000000000000n) {
                        // For ETH, large numbers are likely already in wei
                        amountInWei = amountNum;
                    }
                    else {
                        // Small numbers are likely user amounts that need conversion
                        amountInWei = viem.parseUnits(tokenApproval.amount, decimals);
                    }
                }
            }
            catch (error) {
                throw new Error(`Failed to parse amount ${tokenApproval.amount} for ${tokenApproval.token}: ${commons.extractErrorMessage(error, 'amount parsing')}`);
            }
            const currentAllowance = await this.adapter.nexusSDK.getEVMClient().readContract({
                address: tokenContractAddress,
                abi: viem.erc20Abi,
                functionName: 'allowance',
                args: [ownerAddress, spenderAddress],
            });
            // Add a small buffer to avoid repeated approvals due to minor amount differences
            const bufferBps = approvalBufferBps !== undefined && approvalBufferBps >= 0
                ? BigInt(approvalBufferBps)
                : ADAPTER_CONSTANTS$1.APPROVAL_BUFFER_BPS_DEFAULT;
            const requiredAmountWithBuffer = amountInWei + (amountInWei * bufferBps) / 10000n;
            const needsApproval = currentAllowance < requiredAmountWithBuffer;
            return {
                needsApproval,
                currentAllowance,
                requiredAmount: amountInWei,
                tokenAddress: tokenContractAddress,
                spenderAddress,
                token: tokenApproval.token,
                chainId,
                hasPendingApproval: !needsApproval,
            };
        }
        catch (error) {
            throw new Error(`Failed to check approval for ${tokenApproval.token}: ${commons.extractErrorMessage(error, 'approval check')}`);
        }
    }
    /**
     * Ensure contract approval is in place for token spending
     */
    async ensureContractApproval(tokenApproval, spenderAddress, chainId, waitForConfirmation = false, approvalBufferBps) {
        try {
            // Check if approval is needed
            const approvalInfo = await this.checkApprovalNeeded(tokenApproval, spenderAddress, chainId, approvalBufferBps);
            // Skip approval if sufficient allowance exists
            if (!approvalInfo.needsApproval) {
                return {
                    wasNeeded: false,
                    confirmed: true,
                };
            }
            const accounts = await this.adapter.nexusSDK.getEVMClient().getAddresses();
            if (!accounts || accounts.length === 0) {
                return {
                    wasNeeded: true,
                    error: 'No accounts available',
                };
            }
            // Calculate buffer amount with proper decimal handling for MetaMask display
            const bufferBps = approvalBufferBps !== undefined && approvalBufferBps >= 0
                ? BigInt(approvalBufferBps)
                : ADAPTER_CONSTANTS$1.APPROVAL_BUFFER_BPS_DEFAULT;
            const requiredAmountWithBuffer = approvalInfo.requiredAmount + (approvalInfo.requiredAmount * bufferBps) / 10000n;
            // Get token decimals for proper formatting
            const tokenMetadata = commons.TOKEN_METADATA[tokenApproval.token.toUpperCase()];
            const tokenDecimals = tokenMetadata?.decimals || ADAPTER_CONSTANTS$1.DEFAULT_DECIMALS;
            // Convert to human-readable format first, then back to wei for better MetaMask display
            // This ensures MetaMask shows "0.01001" instead of "10100"
            const humanReadableAmount = viem.formatUnits(requiredAmountWithBuffer, tokenDecimals);
            commons.logger.info('DEBUG approval - Human readable amount for MetaMask:', {
                humanReadableAmount,
                token: tokenApproval.token,
            });
            // Convert back to wei for the transaction
            const finalApprovalAmount = viem.parseUnits(humanReadableAmount, tokenDecimals);
            const chain = this.adapter.nexusSDK.chainList.getChainByID(chainId);
            if (!chain) {
                throw new Error('chain not supported');
            }
            const transactionHash = await this.adapter.nexusSDK.getEVMClient().writeContract({
                functionName: 'approve',
                abi: viem.erc20Abi,
                address: approvalInfo.tokenAddress,
                args: [spenderAddress, finalApprovalAmount],
                chain,
                account: accounts[0],
            });
            if (waitForConfirmation) {
                try {
                    await this.adapter.nexusSDK.getEVMClient().waitForTransactionReceipt({
                        hash: transactionHash,
                        retryCount: 10,
                    });
                }
                catch (confirmationError) {
                    commons.logger.warn('DEBUG approval - Confirmation failed:', confirmationError);
                    return {
                        transactionHash,
                        wasNeeded: true,
                        confirmed: false,
                        error: `Approval confirmation failed: ${commons.extractErrorMessage(confirmationError, 'approval confirmation')}`,
                    };
                }
                return {
                    transactionHash,
                    wasNeeded: true,
                    confirmed: true,
                };
            }
            return {
                transactionHash,
                wasNeeded: false,
                confirmed: false,
            };
        }
        catch (error) {
            commons.logger.error('DEBUG approval - Error:', error);
            return {
                wasNeeded: true,
                error: commons.extractErrorMessage(error, 'contract approval'),
            };
        }
    }
}

/**
 * Multi-step simulation engine with state override capabilities
 */
class SimulationEngine {
    constructor(adapter) {
        this.adapter = adapter;
    }
    ensureInitialized() {
        if (!this.adapter.nexusSDK.isInitialized()) {
            throw new Error('Adapter not initialized');
        }
    }
    /**
     * Main entry point for enhanced simulation with automatic state setup
     */
    async simulateWithStateSetup(params) {
        this.ensureInitialized();
        try {
            const { user, tokenRequired, amountRequired, contractCall } = params;
            const chainId = contractCall.toChainId;
            commons.logger.info('DEBUG SimulationEngine - Starting enhanced simulation with full context:', {
                user,
                tokenRequired,
                amountRequired,
                chainId,
                contract: contractCall.contractAddress,
                function: contractCall.functionName,
                contractCallParams: {
                    tokenApproval: contractCall.tokenApproval,
                    buildFunctionParams: typeof contractCall.buildFunctionParams,
                },
            });
            // Step 1: Check user's current token balance
            const balanceCheck = await this.checkUserBalance(user, tokenRequired, chainId, amountRequired);
            commons.logger.info('DEBUG SimulationEngine - Balance check result:', balanceCheck);
            // Step 2: Generate simulation steps
            const steps = await this.generateSimulationSteps({
                user,
                tokenRequired,
                amountRequired,
                contractCall,
                balanceCheck,
            });
            commons.logger.info('DEBUG SimulationEngine - Generated steps:', steps.length);
            // Step 3: Execute multi-step simulation
            const result = await this.executeBatchSimulation(steps, chainId);
            commons.logger.info('DEBUG SimulationEngine - Simulation complete:', {
                success: result.success,
                totalGas: result.totalGasUsed,
                stepsExecuted: result.steps.length,
            });
            return result;
        }
        catch (error) {
            commons.logger.error('DEBUG SimulationEngine - Simulation failed:', error);
            return this.createFailedResult(`Enhanced simulation failed: ${commons.extractErrorMessage(error, 'simulation')}`);
        }
    }
    /**
     * Check user's token balance on specific chain
     */
    async checkUserBalance(user, token, chainId, requiredAmount) {
        try {
            const tokenAddress = commons.getTokenContractAddress(token, chainId);
            if (!tokenAddress) {
                throw new Error(`Token ${token} not supported on chain ${commons.CHAIN_METADATA[chainId]?.name}`);
            }
            // For native ETH, use eth_getBalance
            if (token === 'ETH') {
                const balance = await this.adapter.nexusSDK.getEVMClient().getBalance({
                    address: user,
                    blockTag: 'latest',
                });
                const balanceBigInt = BigInt(balance);
                const requiredBigInt = requiredAmount ? BigInt(requiredAmount) : BigInt(0);
                const sufficient = balanceBigInt >= requiredBigInt;
                const shortfall = sufficient ? '0' : (requiredBigInt - balanceBigInt).toString();
                return {
                    balance: balance.toString(),
                    sufficient,
                    shortfall,
                    tokenAddress,
                };
            }
            const balance = await this.adapter.nexusSDK.getEVMClient().readContract({
                abi: viem.erc20Abi,
                functionName: 'balanceOf',
                args: [user],
                address: tokenAddress,
            });
            if (requiredAmount) {
                const requiredBigInt = BigInt(requiredAmount);
                const sufficient = balance >= requiredBigInt;
                const shortfall = sufficient ? '0' : (requiredBigInt - balance).toString();
                return {
                    balance: balance.toString(),
                    sufficient,
                    shortfall,
                    tokenAddress,
                };
            }
            return {
                balance: balance.toString(),
                sufficient: false, // Cannot determine without required amount
                shortfall: '0',
                tokenAddress,
            };
        }
        catch (error) {
            commons.logger.warn(`Failed to check balance for ${token} on chain ${chainId}:`, error);
            return {
                balance: '0',
                sufficient: false,
                shortfall: requiredAmount || '0',
                tokenAddress: commons.getTokenContractAddress(token, chainId) || '',
            };
        }
    }
    /**
     * Get the storage slot for token balances mapping - Production Ready Static Mapping
     * Based on actual contract analysis for all supported tokens and chains
     */
    getBalanceStorageSlot(token, chainId) {
        const storageSlotMapping = {
            // Ethereum Mainnet (1)
            1: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Base Mainnet (8453)
            8453: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Arbitrum One (42161)
            42161: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Optimism (10)
            10: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Polygon (137)
            137: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Avalanche C-Chain (43114)
            43114: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Scroll (534352)
            534352: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Base Sepolia Testnet (84532)
            84532: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Arbitrum Sepolia Testnet (421614)
            421614: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Optimism Sepolia Testnet (11155420)
            11155420: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
            // Polygon Amoy Testnet (80002)
            80002: {
                ETH: 0,
                USDC: 9,
                USDT: 2,
            },
        };
        const chainMapping = storageSlotMapping[chainId];
        if (!chainMapping) {
            commons.logger.warn(`Unsupported chain ${chainId}, falling back to defaults`);
            // Fallback defaults based on most common patterns
            return token === 'USDC' ? 9 : token === 'USDT' ? 2 : 0;
        }
        const slot = chainMapping[token];
        if (slot === undefined) {
            commons.logger.warn(`Token ${token} not supported on chain ${commons.CHAIN_METADATA[chainId]?.name}, falling back to defaults`);
            return token === 'USDC' ? 9 : token === 'USDT' ? 2 : 0;
        }
        commons.logger.info(`Using storage slot ${slot} for ${token} on chain ${chainId}`);
        return slot;
    }
    /**
     * Generate state overrides to fund user with required tokens
     */
    async generateStateOverrides(user, token, requiredAmount, chainId) {
        try {
            const tokenAddress = commons.getTokenContractAddress(token, chainId);
            if (!tokenAddress) {
                throw new Error(`Token ${token} not supported on chain ${commons.CHAIN_METADATA[chainId]?.name}`);
            }
            // For native ETH
            if (token === 'ETH') {
                return {
                    [user]: {
                        balance: `0x${BigInt(requiredAmount).toString(16)}`,
                    },
                };
            }
            // For ERC20 tokens - override the balance mapping using verified storage slots
            const balanceSlot = this.getBalanceStorageSlot(token, chainId);
            // Calculate storage slot for user's balance: keccak256(user_address . balances_slot)
            const userBalanceSlot = viem.keccak256(viem.encodePacked(['address', 'uint256'], [user, BigInt(balanceSlot)]));
            // Convert amount to hex with proper padding
            const amountHex = `0x${BigInt(requiredAmount).toString(16).padStart(64, '0')}`;
            commons.logger.info(`Generating state override for ${token} on chain ${chainId}: slot=${balanceSlot}, storageKey=${userBalanceSlot}`);
            return {
                [tokenAddress]: {
                    storage: {
                        [userBalanceSlot]: amountHex,
                    },
                },
            };
        }
        catch (error) {
            commons.logger.error('Error generating state overrides:', error);
            throw error;
        }
    }
    /**
     * Generate the sequence of simulation steps needed
     */
    async generateSimulationSteps(params) {
        const { user, tokenRequired, amountRequired, contractCall, balanceCheck } = params;
        const steps = [];
        // Check if user has sufficient balance
        const requiredAmountBigInt = BigInt(amountRequired);
        const currentBalanceBigInt = BigInt(balanceCheck.balance);
        const needsFunding = currentBalanceBigInt < requiredAmountBigInt;
        commons.logger.info('DEBUG generateSimulationSteps - Balance analysis:', {
            required: requiredAmountBigInt.toString(),
            current: currentBalanceBigInt.toString(),
            needsFunding,
            tokenRequired,
            user,
            contractCall: {
                functionName: contractCall.functionName,
                contractAddress: contractCall.contractAddress,
                tokenApproval: contractCall.tokenApproval,
                buildFunctionParamsType: typeof contractCall.buildFunctionParams,
            },
        });
        // Step 1: Funding step (if needed)
        if (needsFunding) {
            const stateOverrides = await this.generateStateOverrides(user, tokenRequired, amountRequired, contractCall.toChainId);
            steps.push({
                type: 'funding',
                required: true,
                description: `Fund user with ${amountRequired} ${tokenRequired}`,
                stepId: 'funding-step',
                stateOverride: stateOverrides,
                params: {
                    chainId: contractCall.toChainId.toString(),
                    from: user,
                    to: user,
                    value: '0x0',
                },
            });
        }
        // First, convert amountRequired from micro-units to user-friendly format for the callback
        // The callback expects amount in user-friendly format (e.g., "0.01" for 0.01 USDC)
        // but amountRequired comes in micro-units (e.g., "10000" for 0.01 USDC)
        commons.logger.info('Token metadata:', { meta: commons.TOKEN_METADATA, tokenRequired });
        const decimals = commons.TOKEN_METADATA[tokenRequired]?.decimals ?? 6;
        const userFriendlyAmount = viem.formatUnits(BigInt(amountRequired), decimals);
        commons.logger.info('DEBUG SimulationEngine - Amount conversion:', {
            microUnits: amountRequired,
            decimals,
            userFriendly: userFriendlyAmount,
        });
        // Call the buildFunctionParams with user-friendly amount
        commons.logger.info('DEBUG SimulationEngine - Calling buildFunctionParams with:', {
            tokenRequired,
            userFriendlyAmount,
            chainId: contractCall.toChainId,
            user,
        });
        const { functionParams, value } = contractCall.buildFunctionParams(tokenRequired, userFriendlyAmount, contractCall.toChainId, user);
        commons.logger.info('DEBUG SimulationEngine - buildFunctionParams result:', {
            functionParams,
            value,
            functionParamsLength: functionParams?.length,
            functionParamsTypes: functionParams?.map((p) => typeof p),
        });
        // Step 2: Approval step (if needed for ERC20)
        if (tokenRequired !== 'ETH' && contractCall.tokenApproval) {
            const actualAmountToApprove = amountRequired;
            commons.logger.info('DEBUG SimulationEngine - Approval step preparation:', {
                tokenRequired,
                amountRequired,
                actualAmountToApprove,
                contractToApprove: contractCall.contractAddress,
                tokenAddress: balanceCheck.tokenAddress,
            });
            const approvalCallData = await this.buildApprovalCallData(contractCall.contractAddress, actualAmountToApprove);
            steps.push({
                type: 'approval',
                required: true,
                description: `Approve ${contractCall.contractAddress} to spend ${tokenRequired}`,
                stepId: 'approval-step',
                dependsOn: needsFunding ? ['funding-step'] : undefined,
                params: {
                    chainId: contractCall.toChainId.toString(),
                    from: user,
                    to: balanceCheck.tokenAddress,
                    data: approvalCallData,
                    value: '0x0',
                },
            });
        }
        // Step 3: Execute step
        // Encode the function call with the built parameters
        const encodingResult = commons.encodeContractCall({
            contractAbi: contractCall.contractAbi,
            functionName: contractCall.functionName,
            functionParams,
        });
        if (!encodingResult.success) {
            throw new Error(`Failed to encode contract call: ${encodingResult.error}`);
        }
        commons.logger.info('DEBUG SimulationEngine - Execute step preparation:', {
            encodedData: encodingResult.data,
            contractCallValue: contractCall.value,
            callbackValue: value,
            finalValue: value || contractCall.value || '0x0',
            dependsOn: tokenRequired !== 'ETH' ? ['approval-step'] : needsFunding ? ['funding-step'] : undefined,
        });
        steps.push({
            type: 'execute',
            required: true,
            description: `Execute ${contractCall.functionName} on ${contractCall.contractAddress}`,
            stepId: 'execute-step',
            dependsOn: tokenRequired !== 'ETH' ? ['approval-step'] : needsFunding ? ['funding-step'] : undefined,
            params: {
                chainId: contractCall.toChainId.toString(),
                from: user,
                to: contractCall.contractAddress,
                data: encodingResult.data,
                value: value || contractCall.value || '0x0',
            },
        });
        commons.logger.info('DEBUG SimulationEngine - Final steps generated:', {
            totalSteps: steps.length,
            stepTypes: steps.map((s) => s.type),
            stepIds: steps.map((s) => s.stepId),
        });
        return steps;
    }
    /**
     * Build approval call data for ERC20 token
     */
    async buildApprovalCallData(spender, amount) {
        // ERC20 approve function selector: approve(address,uint256)
        const approveSelector = '0x095ea7b3';
        const paddedSpender = spender.slice(2).padStart(64, '0');
        const paddedAmount = BigInt(amount).toString(16).padStart(64, '0');
        return `${approveSelector}${paddedSpender}${paddedAmount}`;
    }
    /**
     * Execute batch simulation using bundle endpoint
     */
    async executeBatchSimulation(steps, chainId) {
        const simulationClient = getSimulationClient();
        if (!simulationClient) {
            return this.createFailedResult('Simulation client not configured');
        }
        commons.logger.info(`DEBUG executeBatchSimulation - Starting bundle simulation with ${steps.length} steps`);
        // Build cumulative state overrides
        let cumulativeStateOverrides = {};
        const bundleSimulations = [];
        for (const step of steps) {
            // Merge cumulative state overrides with step-specific overrides
            cumulativeStateOverrides = this.mergeStateOverrides(cumulativeStateOverrides, step.stateOverride || {});
            // Add to bundle
            bundleSimulations.push({
                stepId: step.stepId || '',
                type: step.type,
                from: step.params.from || '',
                to: step.params.to || '',
                data: step.params.data || '0x',
                value: step.params.value || '0x0',
                stateOverride: { ...cumulativeStateOverrides }, // Each step gets cumulative state
            });
            commons.logger.info(`DEBUG executeBatchSimulation - Prepared step: ${step.stepId} (${step.type})`);
        }
        try {
            // Execute bundle simulation
            const bundleRequest = {
                chainId: chainId.toString(),
                simulations: bundleSimulations,
            };
            commons.logger.info('DEBUG executeBatchSimulation - Sending bundle request');
            const bundleResult = await simulationClient.simulateBundle(bundleRequest);
            if (!bundleResult.success) {
                return {
                    totalGasUsed: '0',
                    success: false,
                    error: 'Bundle simulation failed',
                    steps: bundleResult.results.map((result) => ({
                        stepId: result.stepId,
                        type: bundleSimulations.find((sim) => sim.stepId === result.stepId)?.type || '',
                        gasUsed: result.gasUsed,
                        success: result.success,
                        error: result.error,
                    })),
                    stateOverrides: cumulativeStateOverrides,
                };
            }
            // Process successful bundle result
            const executedSteps = bundleResult.results.map((result) => {
                const stepType = bundleSimulations.find((sim) => sim.stepId === result.stepId)?.type || '';
                commons.logger.info(`DEBUG executeBatchSimulation - Step ${result.stepId} completed:`, {
                    gasUsed: result.gasUsed,
                });
                return {
                    stepId: result.stepId,
                    type: stepType,
                    gasUsed: result.gasUsed,
                    success: result.success,
                    error: result.error,
                    stateChanges: bundleSimulations.find((sim) => sim.stepId === result.stepId)
                        ?.stateOverride,
                };
            });
            return {
                totalGasUsed: bundleResult.totalGasUsed,
                success: true,
                steps: executedSteps,
                stateOverrides: cumulativeStateOverrides,
                simulationMetadata: {
                    blockNumber: 'latest',
                    timestamp: new Date().toISOString(),
                    chainId: chainId.toString(),
                },
            };
        }
        catch (error) {
            commons.logger.error('Bundle simulation error:', error);
            return this.createFailedResult(`Bundle simulation failed: ${commons.extractErrorMessage(error, 'bundle simulation')}`);
        }
    }
    /**
     * Merge two state override objects
     */
    mergeStateOverrides(base, additional) {
        const merged = { ...base };
        for (const [address, overrides] of Object.entries(additional)) {
            if (merged[address]) {
                merged[address] = {
                    ...merged[address],
                    ...overrides,
                    storage: {
                        ...merged[address].storage,
                        ...overrides.storage,
                    },
                };
            }
            else {
                merged[address] = overrides;
            }
        }
        return merged;
    }
    /**
     * Create a failed simulation result
     */
    createFailedResult(error) {
        return {
            totalGasUsed: '0',
            success: false,
            error,
            steps: [],
        };
    }
}

/**
 * Service responsible for handling execution operations
 */
class ExecuteService {
    constructor(adapter) {
        this.adapter = adapter;
        this.transactionService = new TransactionService(adapter);
        this.approvalService = new ApprovalService(adapter);
    }
    /**
     * Enable or disable gas estimation for transactions
     */
    setGasEstimationEnabled(enabled) {
        this.transactionService.setGasEstimationEnabled(enabled);
    }
    /**
     * Execute a contract call with approval handling
     */
    async execute(params) {
        try {
            // Prepare execution (includes chain switching)
            const preparation = await this.transactionService.prepareExecution(params);
            // Handle approval if needed (after chain switching)
            let approvalTxHash;
            if (params.tokenApproval) {
                const approvalResult = await this.approvalService.ensureContractApproval(params.tokenApproval, params.contractAddress, params.toChainId, false, params.approvalBufferBps);
                if (approvalResult.error) {
                    throw new Error(`Approval failed: ${approvalResult.error}`);
                }
                approvalTxHash = approvalResult.transactionHash;
            }
            // Send transaction
            const transactionHash = await this.transactionService.sendTransaction(preparation.provider, preparation.fromAddress, params.contractAddress, preparation.encodedData, preparation.value || params.value || '0x0', {
                enableTransactionPolling: params.enableTransactionPolling,
                transactionTimeout: params.transactionTimeout,
                waitForReceipt: params.waitForReceipt,
                receiptTimeout: params.receiptTimeout,
                requiredConfirmations: params.requiredConfirmations,
            });
            // Handle transaction confirmation
            const receiptInfo = await this.transactionService.handleTransactionConfirmation(preparation.provider, transactionHash, {
                waitForReceipt: params.waitForReceipt,
                receiptTimeout: params.receiptTimeout,
                requiredConfirmations: params.requiredConfirmations,
            }, params.toChainId);
            // Build result
            const result = this.transactionService.buildExecuteResult(transactionHash, params.toChainId, receiptInfo);
            // If approval happened, attach approval tx hash if available
            if (params.tokenApproval && approvalTxHash) {
                // Augment the typed result by casting to the extended type locally before returning
                const extendedResult = {
                    ...result,
                    approvalTransactionHash: approvalTxHash,
                };
                return extendedResult;
            }
            return result;
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * Simulate contract execution
     */
    async simulateExecute(params) {
        try {
            // Get simulation client
            const simulationClient = getSimulationClient();
            if (!simulationClient) {
                return {
                    contractAddress: params.contractAddress,
                    functionName: params.functionName,
                    gasUsed: '0',
                    success: false,
                    error: 'Simulation client not configured',
                };
            }
            // Get user address for callback
            const fromAddress = await this.adapter.nexusSDK.getEVMClient().getAddresses();
            if (!fromAddress || fromAddress.length === 0) {
                throw new Error('No accounts available');
            }
            // Prepare execution to get encoded data and value (calls buildFunctionParams internally)
            const preparation = await this.transactionService.prepareExecution(params);
            // Create simulation parameters
            const simulationParams = {
                from: preparation.fromAddress,
                to: params.contractAddress,
                data: preparation.encodedData,
                value: preparation.value || params.value || '0x0',
                chainId: params.toChainId.toString(),
            };
            // Run simulation
            const simulationResult = await simulationClient.simulate(simulationParams);
            if (!simulationResult.success) {
                return {
                    contractAddress: params.contractAddress,
                    functionName: params.functionName,
                    gasUsed: '0',
                    success: false,
                    error: simulationResult.errorMessage || 'Simulation failed',
                };
            }
            const gasUsedDecimal = viem.hexToNumber(simulationResult.gasUsed);
            let gasCostEth;
            try {
                const gasPriceHex = (await this.adapter.nexusSDK.request({
                    method: 'eth_gasPrice',
                }));
                const gasPriceWei = parseInt(gasPriceHex, 16);
                const costEthNum = (gasUsedDecimal * gasPriceWei) / 1e18;
                gasCostEth = costEthNum.toFixed(8);
            }
            catch (gpErr) {
                commons.logger.warn('Failed to fetch gas price during simulation cost calc:', gpErr);
            }
            return {
                gasUsed: gasUsedDecimal.toString(),
                success: true,
                ...(gasCostEth ? { gasCostEth } : {}),
            };
        }
        catch (error) {
            return {
                contractAddress: params.contractAddress,
                functionName: params.functionName,
                gasUsed: '0',
                success: false,
                error: commons.extractErrorMessage(error, 'execution simulation'),
            };
        }
    }
    /**
     * Enhanced simulation with automatic state setup
     */
    async simulateExecuteEnhanced(params) {
        try {
            // Check if we should use enhanced simulation
            commons.logger.debug('DEBUG ExecuteService - Full params received:', {
                functionName: params.functionName,
                contractAddress: params.contractAddress,
                tokenApproval: params.tokenApproval,
                buildFunctionParams: typeof params.buildFunctionParams,
                toChainId: params.toChainId,
            });
            const shouldUseEnhancedSimulation = this.shouldUseEnhancedSimulation(params);
            commons.logger.debug('DEBUG ExecuteService - Final enhanced simulation decision:', shouldUseEnhancedSimulation);
            if (shouldUseEnhancedSimulation) {
                return await this.runEnhancedSimulation(params);
            }
            return await this.simulateExecute(params);
        }
        catch (error) {
            return {
                contractAddress: params.contractAddress,
                functionName: params.functionName,
                gasUsed: '0',
                success: false,
                error: commons.extractErrorMessage(error, 'enhanced simulation'),
            };
        }
    }
    /**
     * Determine if enhanced simulation should be used
     */
    shouldUseEnhancedSimulation(params) {
        // Use enhanced simulation if:
        // 1. Token approval is required (indicates ERC20 interaction)
        // 2. Function is likely to fail without proper balance setup
        const shouldUse = params.tokenApproval !== undefined &&
            params.tokenApproval.token !== 'ETH' &&
            this.isComplexContractCall(params);
        commons.logger.debug('DEBUG shouldUseEnhancedSimulation - Decision:', {
            hasTokenApproval: !!params.tokenApproval,
            isComplex: this.isComplexContractCall(params),
            functionName: params.functionName,
            finalDecision: shouldUse,
        });
        return (params.tokenApproval !== undefined &&
            params.tokenApproval.token !== 'ETH' &&
            this.isComplexContractCall(params));
    }
    /**
     * Check if this is a complex contract call that benefits from enhanced simulation
     */
    isComplexContractCall(params) {
        const complexFunctions = [
            'deposit',
            'withdraw',
            'swap',
            'trade',
            'stake',
            'unstake',
            'mint',
            'burn',
            'transfer',
            'transferFrom',
            'approve',
            'supply',
            'borrow',
            'repay',
            'redeem',
            'lend',
        ];
        return complexFunctions.some((func) => params.functionName.toLowerCase().includes(func.toLowerCase()));
    }
    /**
     * Run enhanced simulation with automatic state setup
     */
    async runEnhancedSimulation(params) {
        try {
            // Check if evmProvider is available
            if (!this.adapter.nexusSDK.getEVMProviderWithCA()) {
                throw new Error('EVM provider not available for enhanced simulation');
            }
            const simulationEngine = new SimulationEngine(this.adapter);
            // Get user address
            const preparation = await this.transactionService.prepareExecution(params);
            // Convert tokenApproval amount to proper format if needed
            const tokenAmount = params.tokenApproval?.amount || '0';
            commons.logger.info('DEBUG ExecuteService - Running enhanced simulation:', {
                user: preparation.fromAddress,
                token: params.tokenApproval?.token,
                amount: tokenAmount,
                function: params.functionName,
            });
            // Run enhanced simulation (tokenApproval is guaranteed to exist here due to shouldUseEnhancedSimulation check)
            if (!params.tokenApproval) {
                throw new Error('Enhanced simulation requires token approval information');
            }
            const enhancedResult = await simulationEngine.simulateWithStateSetup({
                user: preparation.fromAddress,
                tokenRequired: params.tokenApproval.token,
                amountRequired: tokenAmount,
                contractCall: params,
            });
            // Convert enhanced result to ExecuteSimulation format
            if (!enhancedResult.success) {
                return {
                    contractAddress: params.contractAddress,
                    functionName: params.functionName,
                    gasUsed: '0',
                    success: false,
                    error: enhancedResult.error || 'Enhanced simulation failed',
                };
            }
            // enhancedResult.totalGasUsed is already an ETH-denominated string (SimulationEngine converts)
            return {
                contractAddress: params.contractAddress,
                functionName: params.functionName,
                gasUsed: enhancedResult.totalGasUsed,
                success: true,
                gasCostEth: enhancedResult.totalGasUsed,
            };
        }
        catch (error) {
            commons.logger.error('Enhanced simulation failed, falling back to standard:', error);
            // Fallback to standard simulation
            return await this.simulateExecute(params);
        }
    }
}

// Local constants for the service
const ADAPTER_CONSTANTS = {
    DEFAULT_DECIMALS: 18,
};
class BridgeExecuteService {
    constructor(adapter) {
        this.adapter = adapter;
        this.skipBridge = false;
        this.optimalBridgeAmount = '0';
        this.executeService = new ExecuteService(adapter);
    }
    /**
     * Enable or disable gas estimation for execute transactions
     * This provides easy control over whether gas estimation runs before execution
     */
    setGasEstimationEnabled(enabled) {
        // Access the transaction service through the execute service's public method
        this.executeService.setGasEstimationEnabled(enabled);
    }
    /**
     * Bridge and execute operation - combines bridge and execute with proper sequencing
     * Now includes smart balance checking to skip bridging when sufficient funds exist
     */
    async bridgeAndExecute(params) {
        const { toChainId, token, amount, execute, enableTransactionPolling = false, transactionTimeout = 30000, waitForReceipt = true, receiptTimeout = 300000, requiredConfirmations = 1, } = params;
        // Declare here so accessible in catch/finally
        let stepForwarder = () => { };
        try {
            // Normalize the input amount to ensure consistent processing
            const normalizedAmount = this.normalizeAmountToWei(amount, token);
            // Check if simulation was run - if not, calculate optimal bridge amount
            if (this.optimalBridgeAmount === '0' && !this.skipBridge) {
                commons.logger.info('Simulation was not run, calculating optimal bridge amount...');
                const bridgeOptimization = await this.calculateOptimalBridgeAmount(toChainId, token, normalizedAmount);
                this.skipBridge = bridgeOptimization.skipBridge;
                this.optimalBridgeAmount = bridgeOptimization.optimalAmount;
            }
            // Use the skipBridge flag set during simulation to determine execution path
            if (this.skipBridge && execute) {
                commons.logger.info(`Enhanced smart routing: Sufficient ${token} + gas balance on chain ${toChainId}, skipping bridge and executing directly`);
                // Skip bridging - execute directly with existing funds
                return await this.executeDirectly(execute, toChainId, token, normalizedAmount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations);
            }
            // Original bridge-and-execute flow when enhanced balance check fails
            commons.logger.info(`Enhanced smart routing: Insufficient ${token} or gas balance on chain ${toChainId}, proceeding with bridge + execute`);
            // Set up listeners to capture Arcana bridge steps and forward step completions
            const bridgeStepsPromise = new Promise((resolve) => {
                const expectedHandler = (steps) => {
                    this.adapter.nexusSDK.nexusEvents.off(commons.NEXUS_EVENTS.EXPECTED_STEPS, expectedHandler);
                    resolve(steps);
                };
                this.adapter.nexusSDK.nexusEvents.on(commons.NEXUS_EVENTS.EXPECTED_STEPS, expectedHandler);
            });
            stepForwarder = (step) => {
                this.adapter.nexusSDK.nexusEvents.emit(commons.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, step);
            };
            this.adapter.nexusSDK.nexusEvents.on(commons.NEXUS_EVENTS.STEP_COMPLETE, stepForwarder);
            // Perform the actual bridge transaction using optimal amount
            // Convert optimal bridge amount from wei to user-friendly format for bridge service
            const tokenMetadata = commons.TOKEN_METADATA[token.toUpperCase()];
            const decimals = tokenMetadata?.decimals || 18;
            const { formatUnits } = await import('viem');
            const userFriendlyBridgeAmount = formatUnits(BigInt(this.optimalBridgeAmount), decimals);
            commons.logger.info('Bridge amount conversion for execution:', {
                optimalBridgeAmountWei: this.optimalBridgeAmount,
                userFriendlyBridgeAmount,
                decimals,
                token,
            });
            const bridgeResult = await this.adapter.nexusSDK.bridge({
                token,
                amount: userFriendlyBridgeAmount,
                chainId: toChainId,
                sourceChains: params.sourceChains,
            });
            if (!bridgeResult.success) {
                throw new Error(`Bridge failed: ${bridgeResult.error}`);
            }
            // Wait for captured bridge steps
            const bridgeSteps = await bridgeStepsPromise;
            // Add a small delay to ensure bridge settlement is complete
            commons.logger.info('DEBUG bridgeAndExecute - Waiting for bridge settlement...');
            await new Promise((resolve) => setTimeout(resolve, 2000)); // 2 second delay
            commons.logger.info('DEBUG bridgeAndExecute - Bridge settlement delay complete');
            // Prepare extra steps for approval/execute/receipt/confirmation
            const extraSteps = [];
            const makeStep = (typeID, type, data = {}) => ({
                typeID,
                type,
                data: {
                    chainID: toChainId,
                    chainName: commons.CHAIN_METADATA[toChainId]?.name || toChainId.toString(),
                    ...data,
                },
            });
            if (execute?.tokenApproval) {
                extraSteps.push(makeStep('AP', 'APPROVAL'));
            }
            if (execute) {
                extraSteps.push(makeStep('TS', 'TRANSACTION_SENT'));
                if (waitForReceipt) {
                    extraSteps.push(makeStep('RR', 'RECEIPT_RECEIVED'));
                }
                if ((requiredConfirmations ?? 0) > 0) {
                    extraSteps.push(makeStep('CN', 'TRANSACTION_CONFIRMED'));
                }
            }
            // Emit consolidated expected steps for the whole operation
            this.adapter.nexusSDK.nexusEvents.emit(commons.NEXUS_EVENTS.BRIDGE_EXECUTE_EXPECTED_STEPS, [
                ...bridgeSteps,
                ...extraSteps,
            ]);
            const { executeTransactionHash, executeExplorerUrl, approvalTransactionHash } = await this.handleExecutePhase(execute, toChainId, token, normalizedAmount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations, 
            // pass helper to emit steps
            (step) => this.adapter.nexusSDK.nexusEvents.emit(commons.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, step), makeStep);
            const result = {
                executeTransactionHash,
                executeExplorerUrl,
                approvalTransactionHash,
                bridgeTransactionHash: bridgeResult.transactionHash,
                bridgeExplorerUrl: bridgeResult.explorerUrl,
                toChainId,
                success: true,
                bridgeSkipped: false, // bridge was performed normally
            };
            // Clean up listener
            this.adapter.nexusSDK.nexusEvents.off(commons.NEXUS_EVENTS.STEP_COMPLETE, stepForwarder);
            return result;
        }
        catch (error) {
            const errorMessage = commons.extractErrorMessage(error, 'bridge and execute');
            // Forward error step (generic) for UI consumers
            this.adapter.nexusSDK.nexusEvents.emit(commons.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, {
                typeID: 'ER',
                type: 'operation.failed',
                data: {
                    error: errorMessage,
                    stage: errorMessage.includes('Execute phase failed') ? 'execute' : 'bridge',
                },
            });
            // Clean listener
            this.adapter.nexusSDK.nexusEvents.off(commons.NEXUS_EVENTS.STEP_COMPLETE, stepForwarder);
            return {
                toChainId,
                success: false,
                error: `Bridge and execute operation failed: ${errorMessage}`,
                bridgeSkipped: false, // error occurred during normal bridge flow
            };
        }
    }
    /**
     * Simulate bridge and execute operation
     * Now includes smart routing simulation
     */
    async simulateBridgeAndExecute(params) {
        try {
            const { execute } = params;
            const steps = [];
            // Normalize the input amount to ensure consistent processing
            const normalizedAmount = this.normalizeAmountToWei(params.amount, params.token);
            // First, calculate optimal bridge amount based on destination balance
            const bridgeOptimization = await this.calculateOptimalBridgeAmount(params.toChainId, params.token, normalizedAmount);
            this.skipBridge = bridgeOptimization.skipBridge;
            this.optimalBridgeAmount = bridgeOptimization.optimalAmount;
            // Run simulations with optimal amounts
            let bridgeSimulation = null;
            let bridgeReceiveAmount = '0';
            let totalBridgeFee = '0';
            // Only add bridge step if we're not skipping it
            if (!this.skipBridge) {
                // Convert optimal bridge amount from wei to user-friendly format for bridge service
                const tokenMetadata = commons.TOKEN_METADATA[params.token.toUpperCase()];
                const decimals = tokenMetadata?.decimals || 18;
                const { formatUnits } = await import('viem');
                const userFriendlyBridgeAmount = formatUnits(BigInt(this.optimalBridgeAmount), decimals);
                commons.logger.info('Bridge amount conversion for simulation:', {
                    optimalBridgeAmountWei: this.optimalBridgeAmount,
                    userFriendlyBridgeAmount,
                    decimals,
                    token: params.token,
                });
                bridgeSimulation = await this.adapter.nexusSDK.simulateBridge({
                    token: params.token,
                    amount: userFriendlyBridgeAmount,
                    chainId: params.toChainId,
                    sourceChains: params.sourceChains,
                });
                steps.push({
                    type: 'bridge',
                    required: true,
                    simulation: bridgeSimulation,
                    description: `Bridge ${userFriendlyBridgeAmount} ${params.token} to chain ${params.toChainId}`,
                });
                // Enhanced bridge analysis
                if (bridgeSimulation?.intent) {
                    const intent = bridgeSimulation.intent;
                    // Extract destination amount (received amount after bridging)
                    if (intent.destination?.amount && intent.destination.amount !== '0') {
                        bridgeReceiveAmount = intent.destination.amount;
                    }
                    // Format bridge fees properly
                    if (intent.fees?.total) {
                        totalBridgeFee = `${intent.fees.total}`;
                    }
                }
            }
            let executeSimulation;
            const approvalRequired = false;
            if (execute) {
                try {
                    // Use the received amount from bridge simulation for execute simulation
                    let receivedAmountForContract = normalizedAmount; // fallback to normalized original amount
                    if (bridgeReceiveAmount !== '0') {
                        // Get token decimals from bridge simulation
                        const tokenDecimals = bridgeSimulation?.intent?.token?.decimals || bridgeSimulation?.token?.decimals;
                        if (tokenDecimals) {
                            const receivedAmountBigInt = viem.parseUnits(bridgeReceiveAmount, tokenDecimals);
                            receivedAmountForContract = receivedAmountBigInt.toString();
                        }
                    }
                    // Create execute parameters for simulation - use wei format for SimulationEngine
                    // SimulationEngine expects amounts in wei format, not user-friendly format
                    const modifiedExecuteParams = {
                        ...execute,
                        toChainId: params.toChainId,
                        tokenApproval: {
                            token: params.token,
                            amount: receivedAmountForContract, // Keep in wei format for SimulationEngine
                        },
                    };
                    executeSimulation =
                        await this.executeService.simulateExecuteEnhanced(modifiedExecuteParams);
                    if (executeSimulation) {
                        steps.push({
                            type: 'execute',
                            required: true,
                            simulation: executeSimulation,
                            description: `Execute ${execute.functionName} on contract ${execute.contractAddress}`,
                        });
                    }
                    // Execute analysis details are available in the simulation result
                }
                catch (simulationError) {
                    commons.logger.warn(`Execute simulation error: ${simulationError}`);
                    executeSimulation = {
                        contractAddress: execute.contractAddress,
                        functionName: execute.functionName,
                        gasUsed: '0',
                        success: false,
                        error: `Simulation failed: ${simulationError}`,
                    };
                    steps.push({
                        type: 'execute',
                        required: true,
                        simulation: executeSimulation,
                        description: `Execute ${execute.functionName} on contract ${execute.contractAddress} (failed)`,
                    });
                }
            }
            // Calculate enhanced total cost with approval step
            let totalEstimatedCost;
            if (totalBridgeFee !== '0' || executeSimulation?.gasUsed) {
                commons.logger.debug('DEBUG bridge-execute-service - totalBridgeFee (ETH):', totalBridgeFee);
                commons.logger.debug('DEBUG bridge-execute-service - executeSimulation?.gasUsed:', executeSimulation?.gasUsed);
                try {
                    const executeFee = executeSimulation?.gasCostEth || executeSimulation?.gasUsed || '0';
                    commons.logger.debug('DEBUG bridge-execute-service - executeFee source value:', executeFee);
                    let executeFeeEth = executeFee;
                    // If gasCostEth wasn't available, executeFee will be gas units – convert.
                    if (executeSimulation?.gasCostEth === undefined) {
                        commons.logger.debug('DEBUG bridge-execute-service - executeFee (gas units):', executeFee);
                        try {
                            // Get the current gas price from the connected provider (wei, hex string)
                            const gasPriceHex = (await this.adapter.nexusSDK.request({
                                method: 'eth_gasPrice',
                            }));
                            const gasPriceWei = parseInt(gasPriceHex, 16);
                            // gasUsed (string) * gasPriceWei (number) => wei, then convert to ETH
                            const gasUsedNum = parseFloat(executeFee);
                            const costEthNum = (gasUsedNum * gasPriceWei) / 1e18; // 1e18 wei per ETH
                            executeFeeEth = costEthNum.toFixed(8); // keep reasonable precision
                        }
                        catch (gpErr) {
                            commons.logger.warn('Failed to fetch gas price for execute fee conversion:', gpErr);
                        }
                    }
                    commons.logger.debug('DEBUG bridge-execute-service - executeFee (ETH):', executeFeeEth);
                    // Add bridge fee (already an ETH figure) with converted execute fee
                    const totalFeeEth = (parseFloat(totalBridgeFee) + parseFloat(executeFeeEth)).toString();
                    commons.logger.debug('DEBUG bridge-execute-service - totalFeeEth:', totalFeeEth);
                    totalEstimatedCost = {
                        total: totalFeeEth,
                        breakdown: {
                            bridge: totalBridgeFee,
                            execute: executeFeeEth,
                        },
                    };
                }
                catch (error) {
                    commons.logger.warn('Could not calculate total cost - cost breakdown may be incomplete:', error);
                }
            }
            // Enhanced balance check after simulations are complete
            // Re-validate the skip bridge decision with actual gas estimates
            if (!this.skipBridge && executeSimulation?.gasUsed) {
                const finalOptimization = await this.calculateOptimalBridgeAmount(params.toChainId, params.token, normalizedAmount, executeSimulation?.gasUsed, executeSimulation?.gasCostEth);
                // Update skip bridge decision if gas check reveals we can skip
                if (finalOptimization.skipBridge && !this.skipBridge) {
                    this.skipBridge = true;
                    this.optimalBridgeAmount = '0';
                    commons.logger.info('Updated bridge decision after gas validation: bridge can be skipped');
                }
            }
            commons.logger.info(`Enhanced balance check result: skipBridge = ${this.skipBridge} for chain ${params.toChainId}`);
            // Adjust simulation result based on skip decision
            let finalBridgeSimulation = bridgeSimulation;
            let finalSteps = steps;
            if (this.skipBridge) {
                // When bridge is skipped, set bridgeSimulation to null and filter out bridge steps
                finalBridgeSimulation = null;
                finalSteps = steps.filter((step) => step.type !== 'bridge');
                commons.logger.info('Bridge will be skipped - using execute-only simulation result');
                return {
                    steps: finalSteps,
                    bridgeSimulation: finalBridgeSimulation,
                    executeSimulation,
                    totalEstimatedCost,
                    success: true,
                    metadata: {
                        contractAddress: executeSimulation?.contractAddress ?? '',
                        functionName: executeSimulation?.functionName ?? '',
                        bridgeReceiveAmount: this.skipBridge
                            ? params.amount.toString()
                            : bridgeReceiveAmount !== '0'
                                ? bridgeReceiveAmount
                                : this.optimalBridgeAmount,
                        bridgeFee: this.skipBridge ? '0' : totalBridgeFee.replace(' ETH', '') || '0',
                        inputAmount: params.amount.toString(),
                        optimalBridgeAmount: this.optimalBridgeAmount,
                        targetChain: params.toChainId,
                        approvalRequired,
                        bridgeSkipped: this.skipBridge,
                        token: params?.token,
                    },
                };
            }
            return {
                steps: finalSteps,
                bridgeSimulation: finalBridgeSimulation,
                executeSimulation,
                totalEstimatedCost,
                success: true,
            };
        }
        catch (error) {
            return {
                steps: [],
                bridgeSimulation: null,
                executeSimulation: undefined,
                success: false,
                error: `Simulation failed: ${commons.extractErrorMessage(error, 'simulation')}`,
            };
        }
    }
    /**
     * Handle the execute phase of bridge and execute
     * Uses callback-based parameter pattern for dynamic parameter building
     */
    async handleExecutePhase(execute, toChainId, bridgeToken, bridgeAmount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations, emitStep, makeStep, approvalBufferBpsOverride) {
        if (!execute || !emitStep || !makeStep)
            return {};
        try {
            // Debug logging to understand amount handling
            commons.logger.info('DEBUG handleExecutePhase - Bridge amount (micro-units):', bridgeAmount);
            commons.logger.info('DEBUG handleExecutePhase - Bridge token:', bridgeToken);
            const { formatUnits } = await import('viem');
            const decimals = commons.TOKEN_METADATA[bridgeToken]?.decimals || 18;
            const userFriendlyAmount = formatUnits(BigInt(bridgeAmount), decimals);
            commons.logger.info('DEBUG handleExecutePhase - Amount conversion:', {
                microUnits: bridgeAmount,
                decimals,
                userFriendly: userFriendlyAmount,
                bridgeToken,
            });
            // Create execute parameters with user-friendly amount for the callback
            const finalExecuteParams = {
                ...execute,
                toChainId,
                tokenApproval: {
                    token: bridgeToken,
                    amount: userFriendlyAmount,
                },
                ...(approvalBufferBpsOverride !== undefined
                    ? { approvalBufferBps: approvalBufferBpsOverride }
                    : undefined),
            };
            commons.logger.info('DEBUG handleExecutePhase - Execute params created with user-friendly amount:', {
                userFriendlyAmount,
                originalBridgeAmount: bridgeAmount,
                token: bridgeToken,
                decimals,
            });
            // Check user balance on destination chain before executing
            try {
                const destinationBalance = await this.getDestinationChainBalance(toChainId, bridgeToken);
                commons.logger.info('DEBUG handleExecutePhase - User balance on destination chain:', {
                    chainId: toChainId,
                    token: bridgeToken,
                    balance: destinationBalance,
                    requiredAmount: bridgeAmount,
                });
            }
            catch (balanceError) {
                commons.logger.warn('DEBUG handleExecutePhase - Could not check destination balance:', balanceError);
            }
            // Execute the target contract call - let execute service handle approval
            commons.logger.info('DEBUG handleExecutePhase - Executing contract call with params:', {
                ...finalExecuteParams,
                toChainId,
            });
            const executeResult = await this.executeService.execute({
                ...finalExecuteParams,
                enableTransactionPolling,
                transactionTimeout,
                waitForReceipt,
                receiptTimeout,
                requiredConfirmations,
            });
            // Check if we should verify transaction success
            if (executeResult.transactionHash) {
                // Transaction sent step
                emitStep(makeStep('TS', 'transaction.sent', {
                    txHash: executeResult.transactionHash,
                }));
            }
            if (waitForReceipt && executeResult.transactionHash) {
                commons.logger.info('DEBUG handleExecutePhase - Checking transaction success for:', executeResult.transactionHash);
                const transactionCheck = await this.checkTransactionSuccess(executeResult.transactionHash, toChainId);
                if (!transactionCheck.success) {
                    commons.logger.error('DEBUG handleExecutePhase - Transaction failed:', transactionCheck.error);
                    emitStep(makeStep('EX', 'execute', {
                        error: transactionCheck.error,
                    }));
                    throw new Error(`Execute transaction failed: ${transactionCheck.error}`);
                }
                commons.logger.info('DEBUG handleExecutePhase - Transaction succeeded with gas used:', transactionCheck.gasUsed);
                // Emit receipt received step
                emitStep(makeStep('RR', 'receipt.received', {
                    txHash: executeResult.transactionHash,
                }));
                // Emit confirmation step if requiredConfirmations met
                if ((requiredConfirmations ?? 0) > 0) {
                    emitStep(makeStep('CN', 'transaction.confirmed', {
                        confirmations: requiredConfirmations,
                    }));
                }
            }
            return {
                executeTransactionHash: executeResult.transactionHash,
                executeExplorerUrl: executeResult.explorerUrl,
                approvalTransactionHash: executeResult.approvalTransactionHash,
            };
        }
        catch (executeError) {
            commons.logger.error('DEBUG handleExecutePhase - Execute error:', executeError);
            emitStep(makeStep('EX', 'execute', { error: executeError.message }));
            throw new Error(`Execute phase failed: ${commons.extractErrorMessage(executeError, 'execute phase')}`);
        }
    }
    /**
     * Normalize amount input to wei format for consistent processing
     * Supports various input formats and automatically handles token decimals
     */
    normalizeAmountToWei(amount, token) {
        try {
            // Convert to string if it's a number
            const amountStr = amount.toString();
            commons.logger.info('DEBUG normalizeAmountToWei - Input:', { amount: amountStr, token });
            // Handle edge cases
            if (!amountStr || amountStr === '0') {
                return '0';
            }
            // Get token metadata for accurate decimal handling
            const tokenUpper = token.toUpperCase();
            const tokenMetadata = commons.TOKEN_METADATA[tokenUpper];
            const decimals = tokenMetadata?.decimals || ADAPTER_CONSTANTS?.DEFAULT_DECIMALS || 18;
            commons.logger.info('DEBUG normalizeAmountToWei - Token info:', {
                tokenUpper,
                decimals,
                tokenMetadata,
            });
            // If it's already in wei format (no decimals, large number), return as-is
            // Check length to avoid converting small integers to wei incorrectly
            if (!amountStr.includes('.') && amountStr.length > 10) {
                commons.logger.info('DEBUG normalizeAmountToWei - Already in wei format');
                return amountStr;
            }
            // Handle hex values
            if (amountStr.startsWith('0x')) {
                const result = BigInt(amountStr).toString();
                commons.logger.info(`DEBUG normalizeAmountToWei - Hex conversion: ${result}`);
                return result;
            }
            // Handle decimal amounts (need conversion to wei)
            if (amountStr.includes('.')) {
                const result = viem.parseUnits(amountStr, decimals).toString();
                commons.logger.info(`DEBUG normalizeAmountToWei - Decimal conversion: ${amountStr} -> ${result}`);
                return result;
            }
            // Handle whole number inputs
            const numValue = parseFloat(amountStr);
            // For USDC specifically, be more careful with the conversion
            // USDC typically has 6 decimals, so 1 USDC = 1,000,000 micro-USDC
            const USDC_MICRO_UNITS_THRESHOLD = 1000000; // 1 USDC
            if (tokenUpper === 'USDC') {
                // For USDC, small numbers (< 1,000,000) are likely user amounts that need conversion
                if (numValue < USDC_MICRO_UNITS_THRESHOLD) {
                    const result = viem.parseUnits(amountStr, 6).toString();
                    commons.logger.info(`DEBUG normalizeAmountToWei - USDC user amount conversion: ${amountStr} -> ${result}`);
                    return result;
                }
                else {
                    // Larger numbers are likely already in micro-USDC
                    commons.logger.info('DEBUG normalizeAmountToWei - USDC already in micro format');
                    return amountStr;
                }
            }
            // For small whole numbers, likely represent user-friendly amounts (e.g., "1" ETH)
            // For larger numbers, likely already in wei format
            if (numValue < 1000 || (tokenMetadata?.decimals === 6 && numValue < 1000000)) {
                // Convert small numbers as user-friendly amounts
                const result = viem.parseUnits(amountStr, decimals).toString();
                commons.logger.info(`DEBUG normalizeAmountToWei - User amount conversion: ${amountStr} -> ${result}`);
                return result;
            }
            else {
                // Assume larger numbers are already in the correct format
                commons.logger.info('DEBUG normalizeAmountToWei - Already in correct format');
                return amountStr;
            }
        }
        catch (error) {
            // If conversion fails, return original
            commons.logger.warn(`Failed to normalize amount ${amount} for token ${token}:`, error);
            return amount.toString();
        }
    }
    /**
     * Get transaction receipt with retry logic
     * Note: Assumes we're already on the correct chain (handled by checkTransactionSuccess)
     */
    async getTransactionReceipt(txHash, maxRetries = 3) {
        return this.adapter.nexusSDK.getEVMClient().waitForTransactionReceipt({
            hash: txHash,
            retryCount: maxRetries,
        });
    }
    /**
     * Simulate a failed transaction to get the revert reason
     * Note: Assumes we're already on the correct chain (handled by checkTransactionSuccess)
     */
    async simulateFailedTransaction(txHash) {
        try {
            // Get the original transaction details
            const tx = await this.adapter.nexusSDK.getEVMClient().getTransaction({
                hash: txHash,
            });
            if (!tx || tx === null) {
                return null;
            }
            // Type guard to ensure transaction has required properties
            if (typeof tx !== 'object' || tx === null) {
                return 'Invalid transaction data';
            }
            if (!tx.to || !tx.input) {
                return 'Invalid transaction data';
            }
            // Get the transaction receipt to find the block number where it failed
            const receipt = await this.adapter.nexusSDK.getEVMClient().getTransactionReceipt({
                hash: txHash,
            });
            // Use the block number where the transaction was mined, or the previous block
            // This ensures we simulate the exact state when the transaction failed
            let simulationBlock = 0n;
            if (receipt) {
                if (receipt.blockNumber) {
                    simulationBlock = receipt.blockNumber;
                }
            }
            else if (tx.blockNumber) {
                simulationBlock = tx.blockNumber;
            }
            commons.logger.info(`DEBUG simulateFailedTransaction - Simulating at block: ${simulationBlock}`);
            // Simulate the transaction call to get revert reason
            await this.adapter.nexusSDK.getEVMClient().call({
                to: tx.to,
                data: tx.input,
                value: tx.value,
                gas: tx.gas,
                blockNumber: simulationBlock,
            });
            // If eth_call succeeds when we expected it to fail, this is suspicious
            // The original transaction failed but the simulation passes
            commons.logger.warn('DEBUG simulateFailedTransaction - eth_call succeeded but original transaction failed. This might indicate a state-dependent failure.');
            return 'Transaction failed due to state changes or gas issues';
        }
        catch (error) {
            commons.logger.info('DEBUG simulateFailedTransaction - eth_call failed as expected, extracting revert reason');
            // This is the expected path - eth_call should fail and give us the revert reason
            // Extract revert reason from error
            if (error && typeof error === 'object' && 'data' in error) {
                const providerError = error;
                if (providerError.data?.message) {
                    return providerError.data.message;
                }
            }
            if (error && typeof error === 'object' && 'message' in error) {
                const errorWithMessage = error;
                // Parse common revert reason patterns
                const revertMatch = errorWithMessage.message.match(/revert (.+?)(?:\s|$)/i);
                if (revertMatch) {
                    return revertMatch[1];
                }
                // Check for execution reverted patterns
                if (errorWithMessage.message.includes('execution reverted')) {
                    const cleanMessage = errorWithMessage.message.replace('execution reverted: ', '').trim();
                    return cleanMessage || 'Transaction reverted without reason';
                }
                // Handle other common error patterns
                if (errorWithMessage.message.includes('insufficient funds')) {
                    return 'Insufficient funds for gas * price + value';
                }
                if (errorWithMessage.message.includes('gas required exceeds allowance')) {
                    return 'Out of gas';
                }
                return errorWithMessage.message;
            }
            return 'Transaction simulation failed';
        }
    }
    /**
     * Check transaction success and get detailed error information
     */
    async checkTransactionSuccess(txHash, chainId, maxRetries = 5, retryDelay = 3000) {
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                commons.logger.info(`DEBUG checkTransactionSuccess - Attempt ${attempt}/${maxRetries}: Checking transaction: ${txHash} on chain: ${chainId}`);
                // Ensure we're on the correct chain before checking transaction
                const currentChainId = await this.adapter.nexusSDK.getEVMClient().getChainId();
                if (currentChainId !== chainId) {
                    commons.logger.info(`DEBUG checkTransactionSuccess - Switching from chain ${currentChainId} to ${chainId}`);
                    try {
                        await this.adapter.nexusSDK.getEVMClient().switchChain({ id: chainId });
                        // Wait a bit after chain switch
                        await new Promise((resolve) => setTimeout(resolve, 1000));
                    }
                    catch (switchError) {
                        commons.logger.error(`DEBUG checkTransactionSuccess - Failed to switch to chain ${chainId}:`, switchError);
                        return {
                            success: false,
                            error: `Failed to switch to chain ${chainId} for transaction verification`,
                        };
                    }
                }
                // 1. Get transaction receipt - basic success/failure
                const receipt = await this.getTransactionReceipt(txHash);
                if (!receipt) {
                    if (attempt < maxRetries) {
                        commons.logger.info(`DEBUG checkTransactionSuccess - Receipt not found, retrying in ${retryDelay}ms...`);
                        await new Promise((resolve) => setTimeout(resolve, retryDelay));
                        continue; // Retry
                    }
                    return {
                        success: false,
                        error: 'Transaction receipt not found after multiple attempts',
                    };
                }
                commons.logger.info(`DEBUG checkTransactionSuccess - Receipt status: ${receipt.status}`);
                // Check if transaction succeeded
                if (receipt.status === 'success') {
                    return {
                        success: true,
                        gasUsed: viem.toHex(receipt.gasUsed),
                    };
                }
                else {
                    let errorMessage = 'Transaction failed';
                    // 3. Simulate the transaction to get detailed error
                    try {
                        const simulationError = await this.simulateFailedTransaction(txHash);
                        if (simulationError) {
                            errorMessage = simulationError;
                        }
                    }
                    catch (simError) {
                        commons.logger.warn('DEBUG checkTransactionSuccess - Simulation failed:', simError);
                        // Keep generic error message if simulation fails
                    }
                    commons.logger.info(`DEBUG checkTransactionSuccess - Final error: ${errorMessage}`);
                    return {
                        success: false,
                        error: errorMessage,
                        gasUsed: viem.toHex(receipt.gasUsed),
                    };
                }
                // Transaction failed - now get the error reason
            }
            catch (error) {
                commons.logger.error(`DEBUG checkTransactionSuccess - Attempt ${attempt} failed:`, error);
                if (attempt < maxRetries) {
                    commons.logger.info(`DEBUG checkTransactionSuccess - Retrying in ${retryDelay}ms...`);
                    await new Promise((resolve) => setTimeout(resolve, retryDelay));
                    continue; // Retry
                }
                // Final attempt failed
                return {
                    success: false,
                    error: `Failed to check transaction status after ${maxRetries} attempts: ${commons.extractErrorMessage(error, 'transaction check')}`,
                };
            }
        }
        // This should never be reached, but just in case
        return {
            success: false,
            error: `Transaction check failed after ${maxRetries} attempts`,
        };
    }
    /**
     * Calculate optimal bridge amount based on destination chain balance
     * Returns the exact amount needed to bridge, or indicates if bridge can be skipped entirely
     */
    async calculateOptimalBridgeAmount(chainId, token, requiredAmount, gasEstimate, gasCostEth) {
        try {
            // Get destination chain balance
            const destinationBalance = await this.getDestinationChainBalance(chainId, token);
            if (destinationBalance === null) {
                // If we can't get balance info, bridge the full amount
                return { skipBridge: false, optimalAmount: requiredAmount };
            }
            const requiredAmountBigInt = BigInt(requiredAmount);
            const destinationBalanceBigInt = BigInt(destinationBalance);
            // Check if we have sufficient balance on destination to skip bridge entirely
            if (destinationBalanceBigInt >= requiredAmountBigInt) {
                // Check gas balance if we have gas estimate
                if (gasEstimate || gasCostEth) {
                    const hasGasBalance = await this.checkGasBalance(chainId, gasEstimate, gasCostEth);
                    if (!hasGasBalance) {
                        commons.logger.info(`Insufficient gas balance on chain ${chainId}, cannot skip bridge`);
                        return { skipBridge: false, optimalAmount: requiredAmount };
                    }
                }
                commons.logger.info(`Sufficient ${token} and gas balance on chain ${chainId}, bridge can be skipped`);
                return { skipBridge: true, optimalAmount: '0' };
            }
            // Calculate how much we need to bridge (required - what's already on destination)
            const optimalBridgeAmountBigInt = requiredAmountBigInt - destinationBalanceBigInt;
            const optimalAmount = (optimalBridgeAmountBigInt > 0n ? optimalBridgeAmountBigInt : 0n).toString();
            commons.logger.info(`Optimal bridge calculation:`, {
                token,
                chainId,
                requiredAmount,
                destinationBalance,
                optimalBridgeAmount: optimalAmount,
            });
            return { skipBridge: false, optimalAmount };
        }
        catch (error) {
            commons.logger.warn(`Failed to calculate optimal bridge amount: ${error}`);
            // Default to bridging full amount on error
            return { skipBridge: false, optimalAmount: requiredAmount };
        }
    }
    /**
     * Get destination chain balance for a specific token
     * Returns balance in wei as string, or null if not found
     */
    async getDestinationChainBalance(chainId, token) {
        try {
            commons.logger.info(`Getting ${token} balance on chain ${chainId}`);
            // Get user's unified balances
            const balances = (await this.adapter.nexusSDK.getUnifiedBalances());
            // Find the balance for the specific token
            const tokenBalance = balances.find((asset) => asset.symbol === token);
            if (!tokenBalance || !tokenBalance.breakdown) {
                commons.logger.info(`No ${token} balance found`);
                return null;
            }
            // Find balance on the specific chain
            const chainBalance = tokenBalance.breakdown.find((balance) => balance.chain.id === chainId);
            if (!chainBalance) {
                commons.logger.info(`No ${token} balance found on chain ${chainId}`);
                return '0'; // Return 0 if no balance on this chain
            }
            // Get token metadata for decimal conversion
            const tokenMetadata = commons.TOKEN_METADATA[token.toUpperCase()];
            const decimals = tokenMetadata?.decimals || 18;
            // Convert the balance to wei for calculation
            const balanceInWei = viem.parseUnits(chainBalance.balance, decimals);
            commons.logger.info(`Balance found:`, {
                token,
                chainId,
                balance: chainBalance.balance,
                balanceInWei: balanceInWei.toString(),
            });
            return balanceInWei.toString();
        }
        catch (error) {
            commons.logger.warn(`Failed to get destination chain balance: ${error}`);
            return null;
        }
    }
    /**
     * Check native token balance for gas requirements
     */
    async checkGasBalance(chainId, gasEstimate, gasCostEth) {
        try {
            // Get native token symbol for this chain
            const chainMetadata = commons.CHAIN_METADATA[chainId];
            if (!chainMetadata) {
                commons.logger.warn(`No chain metadata found for chain ${chainId}`);
                return false;
            }
            const nativeTokenSymbol = chainMetadata.nativeCurrency.symbol;
            commons.logger.info(`Checking ${nativeTokenSymbol} balance on chain ${chainId} for gas`);
            // Get user's unified balances
            const balances = (await this.adapter.nexusSDK.getUnifiedBalances());
            // Find the native token balance
            const nativeTokenBalance = balances.find((asset) => asset.symbol === nativeTokenSymbol);
            if (!nativeTokenBalance || !nativeTokenBalance.breakdown) {
                commons.logger.info(`No ${nativeTokenSymbol} balance found`);
                return false;
            }
            // Find balance on the specific chain
            const chainBalance = nativeTokenBalance.breakdown.find((balance) => balance.chain.id === chainId);
            if (!chainBalance) {
                commons.logger.info(`No ${nativeTokenSymbol} balance found on chain ${chainId}`);
                return false;
            }
            // Calculate required gas cost
            let requiredGasCost = '0';
            if (gasCostEth) {
                // If we have gas cost in ETH, use it directly
                requiredGasCost = gasCostEth;
            }
            else if (gasEstimate) {
                // Convert gas estimate to ETH using current gas price
                try {
                    const gasPriceHex = (await this.adapter.nexusSDK.request({
                        method: 'eth_gasPrice',
                    }));
                    const gasPriceWei = parseInt(gasPriceHex, 16);
                    const gasUsedNum = parseFloat(gasEstimate);
                    const costEthNum = (gasUsedNum * gasPriceWei) / 1e18; // Convert wei to ETH
                    requiredGasCost = costEthNum.toString();
                }
                catch (error) {
                    commons.logger.warn(`Failed to fetch gas price for gas balance check: ${error}`);
                    return false;
                }
            }
            // Add 10% buffer to required gas cost
            const requiredGasCostWithBuffer = (parseFloat(requiredGasCost) * 1.1).toString();
            // Compare balances (both in user-friendly format like ETH)
            const userBalance = parseFloat(chainBalance.balance);
            const requiredGasFloat = parseFloat(requiredGasCostWithBuffer);
            const hasSufficientGasBalance = userBalance >= requiredGasFloat;
            commons.logger.info(`Gas balance check result:`, {
                nativeTokenSymbol,
                chainId,
                userBalance: chainBalance.balance,
                requiredGasCost,
                requiredGasCostWithBuffer,
                hasSufficientGasBalance,
            });
            return hasSufficientGasBalance;
        }
        catch (error) {
            commons.logger.warn(`Failed to check gas balance: ${error}`);
            return false;
        }
    }
    /**
     * Execute directly without bridging when user has sufficient funds
     * Uses callback-based parameters for dynamic execution
     */
    async executeDirectly(execute, toChainId, token, amount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations) {
        try {
            // Emit expected steps for execute-only flow
            const executeSteps = [];
            const makeStep = (typeID, type, data = {}) => ({
                typeID,
                type,
                data: {
                    chainID: toChainId,
                    chainName: commons.CHAIN_METADATA[toChainId]?.name || toChainId.toString(),
                    ...data,
                },
            });
            // Add steps for execute-only flow
            if (execute.tokenApproval) {
                executeSteps.push(makeStep('AP', 'APPROVAL'));
            }
            executeSteps.push(makeStep('TS', 'TRANSACTION_SENT'));
            if (waitForReceipt) {
                executeSteps.push(makeStep('RR', 'RECEIPT_RECEIVED'));
            }
            if ((requiredConfirmations ?? 0) > 0) {
                executeSteps.push(makeStep('CN', 'TRANSACTION_CONFIRMED'));
            }
            // Emit expected steps for execute-only flow
            this.adapter.nexusSDK.nexusEvents.emit(commons.NEXUS_EVENTS.BRIDGE_EXECUTE_EXPECTED_STEPS, executeSteps);
            // Execute directly using existing funds
            const { executeTransactionHash, executeExplorerUrl, approvalTransactionHash } = await this.handleExecutePhase(execute, toChainId, token, amount, enableTransactionPolling, transactionTimeout, waitForReceipt, receiptTimeout, requiredConfirmations, (step) => this.adapter.nexusSDK.nexusEvents.emit(commons.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, step), makeStep);
            return {
                executeTransactionHash,
                executeExplorerUrl,
                approvalTransactionHash,
                bridgeTransactionHash: undefined, // bridge was skipped
                bridgeExplorerUrl: undefined, // bridge was skipped
                toChainId,
                success: true,
                bridgeSkipped: true, // bridge was skipped due to sufficient funds
            };
        }
        catch (error) {
            const errorMessage = commons.extractErrorMessage(error, 'execute directly');
            // Emit error step
            this.adapter.nexusSDK.nexusEvents.emit(commons.NEXUS_EVENTS.BRIDGE_EXECUTE_COMPLETED_STEPS, {
                typeID: 'ER',
                type: 'operation.failed',
                data: {
                    error: errorMessage,
                    stage: 'execute',
                },
            });
            return {
                toChainId,
                success: false,
                error: `Execute-only operation failed: ${errorMessage}`,
                bridgeSkipped: true, // error occurred during execute-only flow
            };
        }
    }
}

/**
 * Provides a unified interface for chain abstraction operations.
 */
class ChainAbstractionAdapter {
    constructor(nexusSDK) {
        this.nexusSDK = nexusSDK;
        commons.logger.debug('ChainAbstractionAdapter', { nexusSDK });
        // Initialize services
        this.executeService = new ExecuteService(this);
        this.bridgeExecuteService = new BridgeExecuteService(this);
        this.setGasEstimationEnabled(true);
    }
    async getEVMClient() {
        return this.nexusSDK.getEVMClient();
    }
    /**
     * Execute a contract call using the execute service.
     */
    async execute(params) {
        return this.executeService.execute(params);
    }
    /**
     * Simulate contract execution using the execute service.
     */
    async simulateExecute(params) {
        return this.executeService.simulateExecute(params);
    }
    /**
     * Get the list of supported chains from the CA SDK.
     */
    getSupportedChains(env) {
        return getSupportedChains(env);
    }
    /**
     * Check if a chain is supported by the adapter.
     */
    isSupportedChain(chainId) {
        return isSupportedChain(chainId);
    }
    /**
     * Check if a token is supported by the adapter.
     */
    isSupportedToken(token) {
        return isSupportedToken(token);
    }
    /**
     * Bridge and execute operation - uses the BridgeExecuteService
     */
    async bridgeAndExecute(params) {
        return this.bridgeExecuteService.bridgeAndExecute(params);
    }
    /**
     * Simulate bridge and execute operation
     */
    async simulateBridgeAndExecute(params) {
        return this.bridgeExecuteService.simulateBridgeAndExecute(params);
    }
    /**
     * Enable or disable gas estimation for transactions
     * When enabled, gas estimation will run before each transaction execution
     * This helps identify potential failures early and provides cost estimates
     */
    setGasEstimationEnabled(enabled) {
        this.bridgeExecuteService.setGasEstimationEnabled(enabled);
        this.executeService.setGasEstimationEnabled(enabled);
    }
}

// src/core/sdk/index.ts
class NexusSDK extends CA {
    constructor(config) {
        super(config);
        commons.logger.debug('Nexus SDK initialized with config:', config);
        this.nexusAdapter = new ChainAbstractionAdapter(this);
        this.nexusEvents = this._caEvents;
        this.utils = new NexusUtils(this.nexusAdapter, () => this.isInitialized());
    }
    /**
     * Initialize the SDK with a provider
     */
    async initialize(provider) {
        // Initialize the core adapter first
        this._setEVMProvider(provider);
        await this._init();
        const BACKEND_URL = 'https://nexus-backend.avail.so';
        {
            try {
                const initResult = await initializeSimulationClient(BACKEND_URL);
                if (!initResult.success) {
                    throw new Error('Backend initialization failed');
                }
            }
            catch (error) {
                throw new Error('Backend initialization failed');
            }
        }
    }
    /**
     * Get unified balances across all chains
     */
    async getUnifiedBalances() {
        return this._getUnifiedBalances();
    }
    /**
     * Get unified balance for a specific token
     */
    async getUnifiedBalance(symbol) {
        return this._getUnifiedBalance(symbol);
    }
    /**
     * Cross chain token transfer
     */
    async bridge(params) {
        try {
            const result = await (await this._bridge(params)).exec();
            return {
                success: true,
                explorerUrl: result?.explorerURL ?? '',
            };
        }
        catch (e) {
            return {
                success: false,
                error: e instanceof Error ? e.message : String(e),
            };
        }
    }
    /**
     * Cross chain token transfer to EOA
     */
    async transfer(params) {
        try {
            const result = await (await this._transfer({ ...params, to: params.recipient })).exec();
            return {
                success: true,
                transactionHash: result.hash,
                explorerUrl: result.explorerURL,
            };
        }
        catch (e) {
            return {
                success: false,
                error: e instanceof Error ? e.message : String(e),
            };
        }
    }
    async swapWithExactIn(input, options) {
        try {
            const result = await this._swapWithExactIn(input, options);
            return {
                success: true,
                result,
            };
        }
        catch (error) {
            console.error('Error in swap with exact out', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    async swapWithExactOut(input, options) {
        try {
            const result = await this._swapWithExactOut(input, options);
            return {
                success: true,
                result,
            };
        }
        catch (error) {
            console.error('Error in swap with exact out', error);
            return {
                success: false,
                error: error instanceof Error ? error.message : String(error),
            };
        }
    }
    /**
     * Get chain abstracted provider allowing use of chain asbtraction
     * @returns EthereumProvider
     */
    getEVMProviderWithCA() {
        return this._getEVMProviderWithCA();
    }
    /**
     * Simulate bridge transaction to get costs and fees
     */
    async simulateBridge(params) {
        return (await this._bridge(params)).simulate();
    }
    /**
     * Simulate transfer transaction to get costs and fees
     */
    async simulateTransfer(params) {
        return (await this._transfer({ ...params, to: params.recipient })).simulate();
    }
    /**
     * Get user's intents with pagination
     */
    async getMyIntents(page = 1) {
        return this._getMyIntents(page);
    }
    /**
     * Check allowance for tokens on a specific chain
     */
    async getAllowance(chainId, tokens) {
        return this._allowance().get({ chainID: chainId, tokens });
    }
    /**
     * Set allowance for a token on a specific chain
     */
    async setAllowance(chainId, tokens, amount) {
        return this._allowance().set({ chainID: chainId, tokens, amount });
    }
    /**
     * Revoke allowance for a token on a specific chain
     */
    async revokeAllowance(chainId, tokens) {
        return this._allowance().revoke({ chainID: chainId, tokens });
    }
    /**
     * Set callback for intent status updates
     */
    setOnIntentHook(callback) {
        this._setOnIntentHook(callback);
    }
    /**
     * Set callback for allowance approval events
     */
    setOnAllowanceHook(callback) {
        this._setOnAllowanceHook(callback);
    }
    async deinit() {
        return this._deinit();
    }
    async request(args) {
        return this._handleEVMTx(args);
    }
    /**
     * Standalone function to execute funds into a smart contract
     * @param params execute parameters including contract details and transaction settings
     * @returns Promise resolving to execute result with transaction hash and explorer URL
     */
    async execute(params) {
        return this.nexusAdapter.execute(params);
    }
    /**
     * Simulate a standalone execute to estimate gas costs and validate parameters
     * @param params execute parameters for simulation
     * @returns Promise resolving to simulation result with gas estimates
     */
    async simulateExecute(params) {
        return this.nexusAdapter.simulateExecute(params);
    }
    /**
     * Enhanced bridge and execute function with optional execute step and improved error handling
     * @param params Enhanced bridge and execute parameters
     * @returns Promise resolving to comprehensive operation result
     */
    async bridgeAndExecute(params) {
        return this.nexusAdapter.bridgeAndExecute(params);
    }
    /**
     * Simulate bridge and execute operation using bridge output amounts for realistic execute cost estimation
     * This method provides more accurate gas estimates by using the actual amount that will be
     * received on the destination chain after bridging (accounting for fees, slippage, etc.)
     * Includes detailed step-by-step breakdown with approval handling.
     */
    async simulateBridgeAndExecute(params) {
        return this.nexusAdapter.simulateBridgeAndExecute(params);
    }
    getSwapSupportedChainsAndTokens() {
        return this._getSwapSupportedChainsAndTokens();
    }
    isInitialized() {
        return this._isInitialized();
    }
}

Object.defineProperty(exports, "CHAIN_METADATA", {
  enumerable: true,
  get: function () { return commons.CHAIN_METADATA; }
});
Object.defineProperty(exports, "DESTINATION_SWAP_TOKENS", {
  enumerable: true,
  get: function () { return commons.DESTINATION_SWAP_TOKENS; }
});
Object.defineProperty(exports, "MAINNET_CHAINS", {
  enumerable: true,
  get: function () { return commons.MAINNET_CHAINS; }
});
Object.defineProperty(exports, "NEXUS_EVENTS", {
  enumerable: true,
  get: function () { return commons.NEXUS_EVENTS; }
});
Object.defineProperty(exports, "SUPPORTED_CHAINS", {
  enumerable: true,
  get: function () { return commons.SUPPORTED_CHAINS; }
});
Object.defineProperty(exports, "TESTNET_CHAINS", {
  enumerable: true,
  get: function () { return commons.TESTNET_CHAINS; }
});
Object.defineProperty(exports, "TESTNET_TOKEN_METADATA", {
  enumerable: true,
  get: function () { return commons.TESTNET_TOKEN_METADATA; }
});
Object.defineProperty(exports, "TOKEN_CONTRACT_ADDRESSES", {
  enumerable: true,
  get: function () { return commons.TOKEN_CONTRACT_ADDRESSES; }
});
Object.defineProperty(exports, "TOKEN_METADATA", {
  enumerable: true,
  get: function () { return commons.TOKEN_METADATA; }
});
exports.NexusSDK = NexusSDK;
Object.keys(commons).forEach(function (k) {
  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return commons[k]; }
  });
});
