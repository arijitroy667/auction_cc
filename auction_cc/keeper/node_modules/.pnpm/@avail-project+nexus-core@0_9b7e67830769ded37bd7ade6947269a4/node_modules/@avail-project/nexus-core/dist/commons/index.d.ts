import { TransactionReceipt, Hex, WalletClient, PrivateKeyAccount, Abi, ByteArray, Chain as Chain$1, Address } from 'viem';
export { TransactionReceipt } from 'viem';
import { Universe, Environment, ChainDatum, PermitVariant } from '@arcana/ca-common';
import Decimal from 'decimal.js';
import { DirectSecp256k1Wallet } from '@cosmjs/proto-signing';
import { TransactionRequestLike, FuelConnector, Provider } from 'fuels';

declare const SUPPORTED_CHAINS: {
    readonly ETHEREUM: 1;
    readonly BASE: 8453;
    readonly ARBITRUM: 42161;
    readonly OPTIMISM: 10;
    readonly POLYGON: 137;
    readonly AVALANCHE: 43114;
    readonly SCROLL: 534352;
    readonly SOPHON: 50104;
    readonly KAIA: 8217;
    readonly BNB: 56;
    readonly HYPEREVM: 999;
    readonly SEPOLIA: 11155111;
    readonly BASE_SEPOLIA: 84532;
    readonly ARBITRUM_SEPOLIA: 421614;
    readonly OPTIMISM_SEPOLIA: 11155420;
    readonly POLYGON_AMOY: 80002;
    readonly MONAD_TESTNET: 10143;
};
declare const TOKEN_METADATA: Record<string, TokenMetadata>;
declare const TESTNET_TOKEN_METADATA: Record<string, TokenMetadata>;
declare const CHAIN_METADATA: Record<number, ChainMetadata>;
declare const NEXUS_EVENTS: {
    readonly STEP_COMPLETE: "step_complete";
    readonly EXPECTED_STEPS: "expected_steps";
    readonly SWAP_STEPS: "swap_step";
    readonly BRIDGE_EXECUTE_EXPECTED_STEPS: "bridge_execute_expected_steps";
    readonly BRIDGE_EXECUTE_COMPLETED_STEPS: "bridge_execute_completed_steps";
};
declare const MAINNET_CHAINS: readonly [1, 8453, 42161, 10, 137, 43114, 534352, 50104, 8217, 56, 999];
declare const TESTNET_CHAINS: readonly [11155111, 84532, 421614, 11155420, 80002, 10143];
/**
 * Token contract addresses per chain
 * This registry contains the contract addresses for supported tokens across different chains
 */
declare const TOKEN_CONTRACT_ADDRESSES: Record<string, Record<number, `0x${string}`>>;
declare const DESTINATION_SWAP_TOKENS: Map<number, {
    decimals: number;
    logo: string;
    name: string;
    symbol: string;
    tokenAddress: `0x${string}`;
}[]>;

/**
 * Service-specific types for the adapter architecture
 */
/**
 * Transaction handling options
 */
interface TransactionOptions {
    enableTransactionPolling?: boolean;
    transactionTimeout?: number;
    waitForReceipt?: boolean;
    receiptTimeout?: number;
    requiredConfirmations?: number;
}
/**
 * Transaction result with receipt information
 */
interface TransactionResult {
    receipt?: TransactionReceipt;
    confirmations?: number;
    gasUsed?: string;
    effectiveGasPrice?: string;
}
/**
 * Execute preparation result
 */
interface ExecutePreparation {
    provider: EthereumProvider;
    fromAddress: string;
    encodedData: `0x${string}`;
    value?: string;
}
/**
 * Approval transaction result
 */
interface ApprovalResult {
    transactionHash?: string;
    wasNeeded: boolean;
    error?: string;
    confirmed?: boolean;
}
/**
 * Chain switching result
 */
interface ChainSwitchResult {
    success: boolean;
    error?: string;
}
/**
 * Token approval info for service operations
 */
interface TokenApprovalInfo {
    token: SUPPORTED_TOKENS;
    amount: string;
    spenderAddress: string;
    chainId: number;
}

type serviceTypes_ApprovalResult = ApprovalResult;
type serviceTypes_ChainSwitchResult = ChainSwitchResult;
type serviceTypes_ExecutePreparation = ExecutePreparation;
type serviceTypes_TokenApprovalInfo = TokenApprovalInfo;
type serviceTypes_TransactionOptions = TransactionOptions;
type serviceTypes_TransactionResult = TransactionResult;
declare namespace serviceTypes {
  export type { serviceTypes_ApprovalResult as ApprovalResult, serviceTypes_ChainSwitchResult as ChainSwitchResult, serviceTypes_ExecutePreparation as ExecutePreparation, serviceTypes_TokenApprovalInfo as TokenApprovalInfo, serviceTypes_TransactionOptions as TransactionOptions, serviceTypes_TransactionResult as TransactionResult };
}

type AuthorizationList = {
    address: Uint8Array;
    chain_id: Uint8Array;
    nonce: number;
    sig_r: Uint8Array;
    sig_s: Uint8Array;
    sig_v: number;
};
type BridgeAsset = {
    chainID: number;
    contractAddress: `0x${string}`;
    decimals: number;
    eoaBalance: Decimal;
    ephemeralBalance: Decimal;
};
type SBCCall = {
    data: Uint8Array;
    to_addr: Uint8Array;
    value: Uint8Array;
};
type SBCTx = {
    address: Uint8Array;
    authorization_list: AuthorizationList[];
    calls: SBCCall[];
    chain_id: Uint8Array;
    deadline: Uint8Array;
    key_hash: Uint8Array;
    nonce: Uint8Array;
    revert_on_failure: boolean;
    signature: Uint8Array;
    universe: Universe;
};
type BaseSwapInput = {
    toChainID: number;
    toTokenAddress: Hex;
};
type SWAP_ALL_IN = BaseSwapInput;
type SWAP_EXACT_IN = {
    fromAmount: bigint;
    fromChainID: number;
    fromTokenAddress: Hex;
} & BaseSwapInput;
type SWAP_EXACT_OUT = {
    toAmount: bigint;
} & BaseSwapInput;
type SwapInput = SWAP_ALL_IN | SWAP_EXACT_IN | SWAP_EXACT_OUT;
type InternalSwapInput = {
    chainList: ChainListType;
    cosmos: {
        address: string;
        wallet: DirectSecp256k1Wallet;
    };
    destination: {
        amount?: bigint;
        chainID: number;
        token: `0x${string}`;
    };
    eoaWallet: WalletClient;
    ephemeralWallet: PrivateKeyAccount;
    networkConfig: NetworkConfig;
    source?: {
        amount: bigint;
        chainID: number;
        token: `0x${string}`;
    };
};
type SwapIntent = {
    destination: {
        amount: string;
        chain: {
            id: number;
            logo: string;
            name: string;
        };
        token: {
            contractAddress: Hex;
            decimals: number;
            symbol: string;
        };
    };
    sources: {
        amount: string;
        chain: {
            id: number;
            logo: string;
            name: string;
        };
        token: {
            contractAddress: Hex;
            decimals: number;
            symbol: string;
        };
    }[];
};
type SwapIntentHook = (data: {
    allow: () => void;
    deny: () => void;
    intent: SwapIntent;
    refresh: () => Promise<SwapIntent>;
}) => unknown;
type SwapParams = {
    emit: (stepID: string, step: unknown) => void;
    chainList: ChainListType;
    address: {
        cosmos: string;
        eoa: Hex;
        ephemeral: Hex;
    };
    wallet: {
        cosmos: DirectSecp256k1Wallet;
        ephemeral: PrivateKeyAccount;
        eoa: WalletClient;
    };
    networkConfig: NetworkConfig;
} & SwapInputOptionalParams;
type SwapInputOptionalParams = {
    swapIntentHook?: SwapIntentHook;
};
interface ExactInSwapInput {
    from?: {
        chainId: number;
        amount: bigint;
        tokenAddress: Hex;
    }[];
    toChainId: number;
    toTokenAddress: Hex;
}
interface ExactOutSwapInput {
    toChainId: number;
    toTokenAddress: Hex;
    toAmount: bigint;
}
declare enum SwapMode {
    EXACT_IN = 0,
    EXACT_OUT = 1
}
type SwapData = {
    mode: SwapMode.EXACT_IN;
    data: ExactInSwapInput;
} | {
    mode: SwapMode.EXACT_OUT;
    data: ExactOutSwapInput;
};
declare const CaliburSBCTypes: {
    readonly BatchedCall: readonly [{
        readonly name: "calls";
        readonly type: "Call[]";
    }, {
        readonly name: "revertOnFailure";
        readonly type: "bool";
    }];
    readonly Call: readonly [{
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly name: "value";
        readonly type: "uint256";
    }, {
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly SignedBatchedCall: readonly [{
        readonly name: "batchedCall";
        readonly type: "BatchedCall";
    }, {
        readonly name: "nonce";
        readonly type: "uint256";
    }, {
        readonly name: "keyHash";
        readonly type: "bytes32";
    }, {
        readonly name: "executor";
        readonly type: "address";
    }, {
        readonly name: "deadline";
        readonly type: "uint256";
    }];
};
type AnkrAsset = {
    balance: string;
    balanceRawInteger: string;
    balanceUsd: string;
    blockchain: string;
    contractAddress: `0x${string}`;
    holderAddress: `0x${string}`;
    thumbnail: string;
    tokenDecimals: number;
    tokenName: string;
    tokenPrice: string;
    tokenSymbol: string;
    tokenType: 'ERC20' | 'NATIVE';
};
type AnkrBalance = {
    balance: string;
    balanceUSD: string;
    chainID: number;
    tokenAddress: `0x${string}`;
    tokenData: {
        decimals: number;
        icon: string;
        name: string;
        symbol: string;
    };
    universe: Universe;
};
type AnkrBalances = AnkrBalance[];
type Balances = {
    amount: string;
    chain_id: number;
    decimals: number;
    token_address: `0x${string}`;
    universe: Universe;
    value: number;
}[];
type EoaToEphemeralCallMap = Record<number, {
    amount: bigint;
    decimals: number;
    tokenAddress: Hex;
}>;
type RFFDepositCallMap = Record<number, {
    amount: bigint;
    tokenAddress: Hex;
    tx: Tx[];
}>;
type RFFIntent = {
    destination: {
        amount: bigint;
        chainID: number;
        gasToken?: bigint;
        tokenContract: `0x${string}`;
    };
    fees: {
        caGas: bigint;
        collection: bigint;
        fulfilment: bigint;
        gasSupplied: bigint;
        protocol: bigint;
        solver: bigint;
    };
    isAvailableBalanceInsufficient: boolean;
    sources: {
        amount: bigint;
        chainID: number;
        tokenContract: `0x${string}`;
    }[];
};
type SupportedChainsResult = {
    id: number;
    logo: string;
    name: string;
    tokens: TokenInfo[];
}[];
type Tx = {
    data: Hex;
    to: Hex;
    value: bigint;
};
type Swap = {
    inputAmount: bigint;
    inputContract: Hex;
    inputDecimals: number;
    outputAmount: bigint;
    outputContract: Hex;
    outputDecimals: number;
};
type ChainSwap = {
    chainId: number;
    swaps: Swap[];
    txHash: Hex;
};
type SuccessfulSwapResult = {
    sourceSwaps: ChainSwap[];
    explorerURL: string;
    destinationSwap: ChainSwap | null;
};
type SwapResult = {
    success: true;
    result: SuccessfulSwapResult;
} | {
    success: false;
    error: string;
};

type TokenInfo = {
    contractAddress: `0x${string}`;
    decimals: number;
    logo?: string;
    name: string;
    platform?: string;
    symbol: string;
};
type NexusNetwork = 'mainnet' | 'testnet';
interface BlockTransaction {
    hash?: string;
    from?: string;
}
interface Block {
    transactions?: BlockTransaction[];
}
interface ChainMetadata {
    id: number;
    name: string;
    shortName: string;
    logo: string;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
    rpcUrls: string[];
    blockExplorerUrls: string[];
}
interface TokenMetadata {
    symbol: string;
    name: string;
    decimals: number;
    icon: string;
    coingeckoId: string;
    isNative?: boolean;
}
/**
 * Generic event listener type for CA SDK events
 */
type EventListener = (...args: unknown[]) => void;
/**
 * Parameters for checking or setting token allowance.
 */
interface AllowanceParams {
    tokens: string[];
    amount: number;
    chainId: (typeof SUPPORTED_CHAINS)[keyof typeof SUPPORTED_CHAINS];
}
/**
 * Response structure for token allowance.
 */
interface AllowanceResponse {
    chainID: number;
    allowance: bigint;
    token: string;
}
type SUPPORTED_TOKENS = 'ETH' | 'USDC' | 'USDT';
type SUPPORTED_CHAINS_IDS = (typeof SUPPORTED_CHAINS)[keyof typeof SUPPORTED_CHAINS];
/**
 * Dynamic parameter builder function for building function parameters at execution time
 * This allows for dynamic parameter generation based on actual bridged amounts and user context
 */
type DynamicParamBuilder = (token: SUPPORTED_TOKENS, amount: string, chainId: SUPPORTED_CHAINS_IDS, userAddress: `0x${string}`) => {
    functionParams: readonly unknown[];
    /** ETH value in wei (string). Omit or '0' for ERC-20 calls */
    value?: string;
};
/**
 * Parameters for bridging tokens between chains.
 */
interface BridgeParams {
    token: SUPPORTED_TOKENS;
    amount: number | string;
    chainId: SUPPORTED_CHAINS_IDS;
    gas?: bigint;
    sourceChains?: number[];
}
/**
 * Result structure for bridge transactions.
 */
type BridgeResult = {
    success: false;
    error: string;
} | {
    success: true;
    explorerUrl: string;
    transactionHash?: string;
};
/**
 * Result structure for transfer transactions.
 */
type TransferResult = {
    success: true;
    transactionHash: string;
    explorerUrl: string;
} | {
    success: false;
    error: string;
};
interface SimulationResult {
    intent: ReadableIntent;
    token: TokenInfo;
}
/**
 * Parameters for transferring tokens.
 */
interface TransferParams {
    token: SUPPORTED_TOKENS;
    amount: number | string;
    chainId: SUPPORTED_CHAINS_IDS;
    recipient: `0x${string}`;
    sourceChains?: number[];
}
/**
 * Enhanced token balance information
 */
interface TokenBalance {
    symbol: string;
    balance: string;
    formattedBalance: string;
    balanceInFiat?: number;
    chainId: number;
    contractAddress?: `0x${string}`;
    isNative?: boolean;
}
interface ExecuteParams {
    toChainId: SUPPORTED_CHAINS_IDS;
    contractAddress: string;
    contractAbi: Abi;
    functionName: string;
    buildFunctionParams: DynamicParamBuilder;
    value?: string;
    enableTransactionPolling?: boolean;
    transactionTimeout?: number;
    waitForReceipt?: boolean;
    receiptTimeout?: number;
    requiredConfirmations?: number;
    tokenApproval?: {
        token: SUPPORTED_TOKENS;
        amount: string;
    };
    /**
     * Optional approval buffer in basis points (bps). Defaults to 100 (1%).
     * Use 0 to disable buffer (e.g., for bridge+execute flows where exact balances are used).
     */
    approvalBufferBps?: number;
}
interface ExecuteResult {
    transactionHash: string;
    explorerUrl: string;
    chainId: number;
    receipt?: TransactionReceipt;
    confirmations?: number;
    gasUsed?: string;
    effectiveGasPrice?: string;
    approvalTransactionHash?: string;
}
interface ExecuteSimulation {
    contractAddress: string;
    functionName: string;
    gasUsed: string;
    success: boolean;
    error?: string;
    gasCostEth?: string;
}
interface ApprovalInfo {
    needsApproval: boolean;
    currentAllowance: bigint;
    requiredAmount: bigint;
    tokenAddress?: string;
    spenderAddress: string;
    token: SUPPORTED_TOKENS;
    chainId: number;
    hasPendingApproval?: boolean;
}
interface ApprovalSimulation {
    gasUsed: string;
    gasPrice: string;
    totalFee: string;
    success: boolean;
    error?: string;
}
interface SimulationStep {
    type: 'bridge' | 'approval' | 'execute';
    required: boolean;
    simulation: SimulationResult | ApprovalSimulation | ExecuteSimulation;
    description: string;
}
interface SimulationMetadata {
    contractAddress: string;
    functionName: string;
    bridgeReceiveAmount: string;
    bridgeFee: string;
    inputAmount: string;
    optimalBridgeAmount?: string;
    targetChain: number;
    approvalRequired: boolean;
    bridgeSkipped?: boolean;
    token?: SUPPORTED_TOKENS;
}
interface BridgeAndExecuteSimulationResult {
    steps: SimulationStep[];
    bridgeSimulation: SimulationResult | null;
    executeSimulation?: ExecuteSimulation;
    totalEstimatedCost?: {
        total: string;
        breakdown: {
            bridge: string;
            execute: string;
        };
    };
    success: boolean;
    error?: string;
    metadata?: SimulationMetadata;
}
interface BridgeAndExecuteParams {
    toChainId: SUPPORTED_CHAINS_IDS;
    token: SUPPORTED_TOKENS;
    amount: number | string;
    recipient?: `0x${string}`;
    sourceChains?: number[];
    execute?: Omit<ExecuteParams, 'toChainId'>;
    enableTransactionPolling?: boolean;
    transactionTimeout?: number;
    waitForReceipt?: boolean;
    receiptTimeout?: number;
    requiredConfirmations?: number;
    recentApprovalTxHash?: string;
}
interface BridgeAndExecuteResult {
    executeTransactionHash?: string;
    executeExplorerUrl?: string;
    approvalTransactionHash?: string;
    bridgeTransactionHash?: string;
    bridgeExplorerUrl?: string;
    toChainId: number;
    success: boolean;
    error?: string;
    bridgeSkipped: boolean;
}
/**
 * Smart contract call parameters
 */
interface ContractCallParams {
    to: `0x${string}`;
    data: `0x${string}`;
    value?: bigint;
    gas?: bigint;
    gasPrice?: bigint;
}
type BridgeQueryInput = {
    amount: number | string;
    chainId: number;
    gas?: bigint;
    sourceChains?: number[];
    token: string;
};
interface CA {
    createEVMHandler(tx: EVMTransaction, options: Partial<TxOptions>): Promise<CreateHandlerResponse | null>;
    createFuelHandler(tx: TransactionRequestLike, options: Partial<TxOptions>): Promise<CreateHandlerResponse | null>;
    getChainID(): Promise<number>;
    init(): Promise<void>;
    switchChain(chainID: number): Promise<void>;
}
type Chain = {
    blockExplorers?: {
        default: {
            name: string;
            url: string;
        };
    };
    custom: {
        icon: string;
        knownTokens: TokenInfo[];
    };
    id: number;
    name: string;
    ankrName: string;
    nativeCurrency: {
        decimals: number;
        name: string;
        symbol: string;
    };
    rpcUrls: {
        default: {
            http: string[];
            publicHttp?: string[];
            webSocket: string[];
        };
    };
    universe: Universe;
};
interface CreateHandlerResponse {
    handler: IRequestHandler | null;
    processTx: () => Promise<unknown>;
}
interface EthereumProvider {
    on(eventName: string | symbol, listener: (...args: any[]) => void): this;
    removeListener(eventName: string | symbol, listener: (...args: any[]) => void): this;
    request(args: RequestArguments): Promise<unknown>;
}
type EVMTransaction = {
    data?: `0x${string}`;
    from: `0x${string}`;
    to: `0x${string}`;
    value?: `0x${string}`;
};
type FeeStoreData = {
    fee: {
        collection: {
            chainID: number;
            fee: number;
            tokenAddress: string;
            universe: Universe;
        }[];
        fulfilment: {
            chainID: number;
            fee: number;
            tokenAddress: string;
            universe: Universe;
        }[];
        protocol: {
            feeBP: string;
        };
    };
    solverRoutes: {
        destinationChainID: number;
        destinationTokenAddress: string;
        destinationUniverse: Universe;
        feeBP: number;
        sourceChainID: number;
        sourceTokenAddress: string;
        sourceUniverse: Universe;
    }[];
};
type FeeUniverse = 'ETHEREUM' | 'FUEL';
type Intent = {
    allSources: IntentSource[];
    destination: IntentDestination;
    fees: {
        caGas: string;
        collection: string;
        fulfilment: string;
        gasSupplied: string;
        protocol: string;
        solver: string;
    };
    isAvailableBalanceInsufficient: boolean;
    sources: IntentSource[];
};
type IntentDestination = {
    amount: Decimal;
    chainID: number;
    decimals: number;
    gas: bigint;
    tokenContract: `0x${string}`;
    universe: Universe;
};
type IntentSource = {
    amount: Decimal;
    chainID: number;
    tokenContract: `0x${string}`;
    universe: Universe;
};
type IntentSourceForAllowance = {
    chainID: number;
    currentAllowance: bigint;
    requiredAllowance: bigint;
    token: TokenInfo;
};
interface IRequestHandler {
    buildIntent(sourceChains: number[]): Promise<{
        intent: Intent;
        token: TokenInfo;
    } | undefined>;
    process(): Promise<{
        explorerURL: string;
    } | undefined>;
}
type Network = Extract<Environment, Environment.CERISE | Environment.CORAL | Environment.FOLLY>;
type NetworkConfig = {
    COSMOS_URL: string;
    EXPLORER_URL: string;
    FAUCET_URL: string;
    GRPC_URL: string;
    NETWORK_HINT: Environment;
    SIMULATION_URL: string;
    VSC_DOMAIN: string;
};
type OnIntentHookData = {
    allow: () => void;
    deny: () => void;
    intent: ReadableIntent;
    refresh: (selectedSources?: number[]) => Promise<ReadableIntent>;
};
type OnAllowanceHookData = {
    allow: (s: Array<'max' | 'min' | bigint | string>) => void;
    deny: () => void;
    sources: AllowanceHookSources;
};
type AllowanceHookSources = onAllowanceHookSource[];
type OnAllowanceHook = (data: OnAllowanceHookData) => void;
type onAllowanceHookSource = {
    allowance: {
        current: string;
        minimum: string;
    };
    chain: {
        id: number;
        logo: string;
        name: string;
    };
    token: {
        contractAddress: `0x${string}`;
        decimals: number;
        logo: string;
        name: string;
        symbol: string;
    };
};
type OnIntentHook = (data: OnIntentHookData) => void;
type OraclePriceResponse = {
    chainId: number;
    priceUsd: Decimal;
    tokenAddress: `0x${string}`;
    tokensPerUsd: Decimal;
}[];
type ReadableIntent = {
    allSources: {
        amount: string;
        chainID: number;
        chainLogo: string | undefined;
        chainName: string;
        contractAddress: `0x${string}`;
    }[];
    destination: {
        amount: string;
        chainID: number;
        chainLogo: string | undefined;
        chainName: string;
    };
    fees: {
        caGas: string;
        gasSupplied: string;
        protocol: string;
        solver: string;
        total: string;
    };
    sources: {
        amount: string;
        chainID: number;
        chainLogo: string | undefined;
        chainName: string;
        contractAddress: `0x${string}`;
    }[];
    sourcesTotal: string;
    token: {
        decimals: number;
        logo: string | undefined;
        name: string;
        symbol: string;
    };
};
type RequestArguments = {
    readonly method: string;
    readonly params?: object | readonly unknown[];
};
type RequestHandler = new (i: RequestHandlerInput) => IRequestHandler;
type ChainListType = {
    chains: Chain[];
    getVaultContractAddress(chainID: number): `0x${string}`;
    getTokenInfoBySymbol(chainID: number, symbol: string): TokenInfo | undefined;
    getTokenByAddress(chainID: number, address: `0x${string}`): TokenInfo | undefined;
    getNativeToken(chainID: number): TokenInfo;
    getChainByID(id: number): Chain | undefined;
    getAnkrNameList(): string[];
};
type RequestHandlerInput = {
    chain: Chain;
    chainList: ChainListType;
    cosmosWallet: DirectSecp256k1Wallet;
    evm: {
        address: `0x${string}`;
        client: WalletClient;
        tx?: EVMTransaction;
    };
    fuel?: {
        address: string;
        connector: FuelConnector;
        provider: Provider;
        tx?: TransactionRequestLike;
    };
    hooks: {
        onAllowance: OnAllowanceHook;
        onIntent: OnIntentHook;
    };
    options: {
        emit: (eventName: string, ...args: any[]) => void;
        networkConfig: NetworkConfig;
    } & TxOptions;
};
type RequestHandlerResponse = {
    buildIntent(): Promise<{
        intent: Intent;
        token: TokenInfo;
    } | undefined>;
    input: RequestHandlerInput;
    process(): Promise<unknown>;
} | null;
type RFF = {
    deposited: boolean;
    destinationChainID: number;
    destinations: {
        tokenAddress: Hex;
        value: bigint;
    }[];
    destinationUniverse: string;
    expiry: number;
    fulfilled: boolean;
    id: number;
    refunded: boolean;
    sources: {
        chainID: number;
        tokenAddress: Hex;
        universe: string;
        value: bigint;
    }[];
};
type SDKConfig = {
    debug?: boolean;
    network?: Network | NetworkConfig;
};
type SetAllowanceInput = {
    amount: bigint;
    chainID: number;
    tokenContract: `0x${string}`;
};
type SimulateReturnType = {
    amount: Decimal;
    gas: bigint;
    gasFee: Decimal;
    token: {
        contractAddress: `0x${string}`;
        decimals: number;
        name: string;
        symbol: string;
    };
};
type SimulationResultData = {
    amount: number;
    gasBreakdown: {
        feeData: {
            maxFeePerGas: string;
            maxPriorityFeePerGas: string;
        };
        limit: string;
    };
    gasUsed: string;
    tokenContract: `0x${string}`;
};
type SponsoredApprovalData = {
    address: ByteArray;
    chain_id: ChainDatum['ChainID32'];
    operations: {
        sig_r: ByteArray;
        sig_s: ByteArray;
        sig_v: number;
        token_address: ByteArray;
        value: ByteArray;
        variant: PermitVariant;
    }[];
    universe: Universe;
};
type SponsoredApprovalDataArray = SponsoredApprovalData[];
type Step = {
    data?: {
        amount: string;
        chainName: string;
        symbol: string;
    } | {
        chainID: number;
        chainName: string;
    } | {
        confirmed: number;
        total: number;
    } | {
        explorerURL: string;
        intentID: number;
    };
} & StepInfo;
type StepInfo = {
    type: string;
    typeID: string;
};
type Steps = Step[];
type Token = {
    contractAddress: `0x${string}`;
    decimals: number;
    name: string;
    symbol: string;
};
type TransferQueryInput = {
    to: Hex;
} & Omit<BridgeQueryInput, 'gas'>;
type TxOptions = {
    bridge: boolean;
    gas: bigint;
    skipTx: boolean;
    sourceChains: number[];
};
type UnifiedBalanceResponseData = {
    chain_id: Uint8Array;
    currencies: {
        balance: string;
        token_address: Uint8Array;
        value: string;
    }[];
    total_usd: string;
    universe: Universe;
};
type UserAssetDatum = {
    abstracted?: boolean;
    balance: string;
    balanceInFiat: number;
    breakdown: {
        balance: string;
        balanceInFiat: number;
        chain: {
            id: number;
            logo: string;
            name: string;
        };
        contractAddress: `0x${string}`;
        decimals: number;
        isNative?: boolean;
        universe: Universe;
    }[];
    decimals: number;
    icon?: string;
    symbol: string;
};

interface ApiResponse<T = unknown> {
    success: boolean;
    data?: T;
    error?: string;
    message?: string;
    timestamp?: string;
}
/**
 * State override for simulation - allows modifying blockchain state during simulation
 */
interface StateOverride {
    [address: string]: {
        balance?: string;
        storage?: Record<string, string>;
        code?: string;
        nonce?: string;
    };
}
/**
 * Enhanced simulation step for multi-step operations
 */
interface EnhancedSimulationStep {
    type: 'funding' | 'approval' | 'execute' | 'bridge' | 'transfer';
    required: boolean;
    description: string;
    params: GasEstimationRequest;
    stateOverride?: StateOverride;
    expectedGas?: string;
    dependsOn?: string[];
    stepId?: string;
}
/**
 * Enhanced simulation result with detailed step breakdown
 */
interface EnhancedSimulationResult {
    totalGasUsed: string;
    success: boolean;
    error?: string;
    steps: Array<{
        stepId: string;
        type: string;
        gasUsed: string;
        success: boolean;
        error?: string;
        stateChanges?: Record<string, unknown>;
    }>;
    stateOverrides?: StateOverride;
    simulationMetadata?: {
        blockNumber: string;
        timestamp: string;
        chainId: string;
    };
}
/**
 * Gas estimation request parameters for backend API
 */
interface GasEstimationRequest {
    chainId: string;
    from: string;
    to: string;
    value?: string;
    data?: string;
    gas?: string;
    gasPrice?: string;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
    blockNumber?: string | 'latest';
}
/**
 * Enhanced gas estimation request with state override support
 */
interface EnhancedGasEstimationRequest extends GasEstimationRequest {
    stateOverride?: StateOverride;
    simulationSteps?: EnhancedSimulationStep[];
    enableStateOverride?: boolean;
}
/**
 * Bundle simulation request for multiple steps
 */
interface BundleSimulationRequest {
    chainId: string;
    simulations: Array<{
        stepId: string;
        type: string;
        from: string;
        to: string;
        data?: string;
        value?: string;
        stateOverride?: StateOverride;
    }>;
}
/**
 * Backend bundle simulation response (raw format)
 */
interface BackendBundleResponse {
    success: boolean;
    data: Array<{
        gasLimit: Hex;
        gasUsed: Hex;
    }>;
    chainId: string;
    requestId: string;
    message: string;
}
/**
 * Bundle simulation response (processed format)
 */
interface BundleSimulationResponse {
    success: boolean;
    results: Array<{
        stepId: string;
        gasUsed: string;
        success: boolean;
        error?: string;
    }>;
    totalGasUsed: string;
}
/**
 * Gas estimation response from backend API
 */
interface GasEstimationResponse {
    gasLimit: string;
    gasUsed: string;
    gasPrice?: string;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
}
/**
 * Enhanced gas estimation response with state change details
 */
interface EnhancedGasEstimationResponse extends GasEstimationResponse {
    stateChanges?: Record<string, unknown>;
    simulationTrace?: unknown;
    revertReason?: string;
    success: boolean;
}
/**
 * Chain support response
 */
interface ChainSupportResponse {
    chainId: string;
    supported: boolean;
    networkName?: string;
}
/**
 * Service status response
 */
interface ServiceStatusResponse {
    configured: boolean;
    supportedChainsCount: number;
}
/**
 * Health check response
 */
interface HealthCheckResponse {
    status: 'ok' | 'error';
    timestamp: string;
    uptime: number;
    environment: string;
    version: string;
}
/**
 * Backend configuration interface
 */
interface BackendConfig {
    baseUrl: string;
}

declare const LOG_LEVEL: {
    readonly DEBUG: 1;
    readonly ERROR: 4;
    readonly INFO: 2;
    readonly NOLOGS: 5;
    readonly WARNING: 3;
};
type LogLevel = (typeof LOG_LEVEL)[keyof typeof LOG_LEVEL];
type ExceptionReporter = (message: string) => void;
declare const setExceptionReporter: (reporter: ExceptionReporter) => void;
declare const setLogLevel: (level: LogLevel) => void;
declare const getLogger: () => Logger;
declare class Logger {
    private prefix;
    consoleLog(level: LogLevel, message: string, params?: unknown): void;
    debug(message: string, params?: unknown): void;
    error(message: string, err?: Error | string): void;
    info<T>(message: string, params?: T): void;
    internalLog(level: LogLevel, message: string, params?: unknown): void;
    warn(message: string, params?: unknown): void;
}
declare const logger: Logger;

/**
 * Shared utility for standardized error message extraction
 */
declare function extractErrorMessage(error: unknown, fallbackContext: string): string;
declare function wait(ms: number): Promise<void>;
/**
 * Get Viem chain configuration for supported chains
 */
declare function getViemChain(chainId: number): Chain$1;
/**
 * Format a balance string to a human-readable format using Decimal.js
 */
declare function formatBalance(balance: string, decimals: number, precision?: number): string;
/**
 * Parse units from a human-readable string to wei/smallest unit using Decimal.js
 */
declare function parseUnits(value: string, decimals: number): bigint;
/**
 * Format units from wei/smallest unit to human-readable string using Decimal.js
 */
declare function formatUnits(value: bigint, decimals: number): string;
/**
 * Validate if a string is a valid Ethereum address using viem
 */
declare function isValidAddress(address: string): address is Address;
/**
 * Get mainnet token metadata by symbol
 */
declare const getMainnetTokenMetadata: (symbol: SUPPORTED_TOKENS) => TokenMetadata | undefined;
/**
 * Get testnet token metadata by symbol
 */
declare const getTestnetTokenMetadata: (symbol: SUPPORTED_TOKENS) => TokenMetadata | undefined;
/**
 * Get token metadata by symbol (defaults to mainnet, kept for backward compatibility)
 */
declare const getTokenMetadata: (symbol: SUPPORTED_TOKENS) => TokenMetadata | undefined;
/**
 * Get chain metadata by chain ID
 */
declare function getChainMetadata(chainId: SUPPORTED_CHAINS_IDS): ChainMetadata;
/**
 * Format a mainnet token amount with proper decimals and symbol
 */
declare function formatTokenAmount(amount: string | bigint, tokenSymbol: SUPPORTED_TOKENS, precision?: number): string;
/**
 * Format a testnet token amount with proper decimals and symbol
 */
declare function formatTestnetTokenAmount(amount: string | bigint, tokenSymbol: SUPPORTED_TOKENS, precision?: number): string;
/**
 * Truncate an address for display purposes
 */
declare function truncateAddress(address: string, startLength?: number, endLength?: number): string;
/**
 * Convert chain ID to hex format
 */
declare function chainIdToHex(chainId: number): string;
/**
 * Convert hex chain ID to number
 */
declare function hexToChainId(hex: string): number;
declare const isMainnetChain: (chainId: SUPPORTED_CHAINS_IDS) => boolean;
declare const isTestnetChain: (chainId: SUPPORTED_CHAINS_IDS) => boolean;
/**
 * Enhanced contract parameter validation with detailed error messages
 */
declare function validateContractParams(params: {
    contractAddress: string;
    contractAbi: Abi;
    functionName: string;
    functionParams: readonly unknown[];
    chainId: number;
}): {
    isValid: boolean;
    error?: string;
};
/**
 * Enhanced contract call encoding with comprehensive error handling
 */
declare function encodeContractCall(params: {
    contractAbi: Abi;
    functionName: string;
    functionParams: readonly unknown[];
}): {
    success: boolean;
    data?: `0x${string}`;
    error?: string;
};
/**
 * Validate and ensure a value is a valid transaction hash
 */
declare function validateTransactionHash(value: unknown): value is `0x${string}`;
/**
 * Validate hex response from RPC calls
 */
declare function validateHexResponse(value: unknown, fieldName: string): {
    isValid: boolean;
    error?: string;
};
/**
 * Enhanced block explorer URL generation with fallback support
 */
declare function getBlockExplorerUrl(chainId: number, txHash: string): string;
/**
 * Get transaction hash with multiple fallback strategies
 */
declare function getTransactionHashWithFallback(provider: EthereumProvider, response: unknown, options?: {
    enablePolling?: boolean;
    timeout?: number;
    fromAddress?: string;
}): Promise<{
    success: boolean;
    hash?: `0x${string}`;
    error?: string;
}>;
/**
 * Enhanced transaction receipt waiting using Viem
 */
declare function waitForTransactionReceipt(provider: EthereumProvider, txHash: `0x${string}`, options?: {
    timeout?: number;
    requiredConfirmations?: number;
    pollingInterval?: number;
}, chainId?: number): Promise<{
    success: boolean;
    receipt?: TransactionReceipt;
    confirmations?: number;
    error?: string;
}>;
/**
 * Utility function to get token contract address for a specific token and chain
 * @param token Token symbol (e.g., 'USDC', 'USDT')
 * @param chainId Chain ID
 * @param isTestnet Whether to use testnet addresses
 * @returns Contract address or undefined if not found
 */
declare function getTokenContractAddress(token: SUPPORTED_TOKENS, chainId: SUPPORTED_CHAINS_IDS): string | undefined;

export { CHAIN_METADATA, CaliburSBCTypes, DESTINATION_SWAP_TOKENS, LOG_LEVEL, MAINNET_CHAINS, NEXUS_EVENTS, SUPPORTED_CHAINS, serviceTypes as ServiceTypes, SwapMode, TESTNET_CHAINS, TESTNET_TOKEN_METADATA, TOKEN_CONTRACT_ADDRESSES, TOKEN_METADATA, chainIdToHex, encodeContractCall, extractErrorMessage, formatBalance, formatTestnetTokenAmount, formatTokenAmount, formatUnits, getBlockExplorerUrl, getChainMetadata, getLogger, getMainnetTokenMetadata, getTestnetTokenMetadata, getTokenContractAddress, getTokenMetadata, getTransactionHashWithFallback, getViemChain, hexToChainId, isMainnetChain, isTestnetChain, isValidAddress, logger, parseUnits, setExceptionReporter, setLogLevel, truncateAddress, validateContractParams, validateHexResponse, validateTransactionHash, wait, waitForTransactionReceipt };
export type { onAllowanceHookSource as AllowanceHookSource, AllowanceHookSources, AllowanceParams, AllowanceResponse, AnkrAsset, AnkrBalance, AnkrBalances, ApiResponse, ApprovalInfo, ApprovalResult, ApprovalSimulation, AuthorizationList, BackendBundleResponse, BackendConfig, Balances, Block, BlockTransaction, BridgeAndExecuteParams, BridgeAndExecuteResult, BridgeAndExecuteSimulationResult, BridgeAsset, BridgeParams, BridgeQueryInput, BridgeResult, BundleSimulationRequest, BundleSimulationResponse, CA, Chain, ChainListType, ChainMetadata, ChainSupportResponse, ChainSwap, ChainSwitchResult, ContractCallParams, CreateHandlerResponse, DynamicParamBuilder, EVMTransaction, EnhancedGasEstimationRequest, EnhancedGasEstimationResponse, EnhancedSimulationResult, EnhancedSimulationStep, EoaToEphemeralCallMap, EthereumProvider, EventListener, ExactInSwapInput, ExactOutSwapInput, ExceptionReporter, ExecuteParams, ExecutePreparation, ExecuteResult, ExecuteSimulation, FeeStoreData, FeeUniverse, GasEstimationRequest, GasEstimationResponse, HealthCheckResponse, IRequestHandler, Intent, IntentDestination, IntentSource, IntentSourceForAllowance, InternalSwapInput, LogLevel, Network, NetworkConfig, NexusNetwork, OnAllowanceHook, OnAllowanceHookData, OnIntentHook, OnIntentHookData, OraclePriceResponse, Step as ProgressStep, Steps as ProgressSteps, RFF, RFFDepositCallMap, RFFIntent, ReadableIntent, RequestArguments, RFF as RequestForFunds, RequestHandler, RequestHandlerInput, RequestHandlerResponse, SBCCall, SBCTx, SDKConfig, SUPPORTED_CHAINS_IDS, SUPPORTED_TOKENS, ServiceStatusResponse, SetAllowanceInput, SimulateReturnType, SimulationResult, SimulationResultData, SimulationStep, SponsoredApprovalData, SponsoredApprovalDataArray, StateOverride, Step, StepInfo, Steps, SuccessfulSwapResult, SupportedChainsResult, Swap, SwapData, SwapInput, SwapInputOptionalParams, SwapIntent, SwapIntentHook, SwapParams, SwapResult, Token, TokenApprovalInfo, TokenBalance, TokenInfo, TokenMetadata, TransactionOptions, TransactionResult, TransferParams, TransferQueryInput, TransferResult, Tx, TxOptions, UnifiedBalanceResponseData, UserAssetDatum as UserAsset, UserAssetDatum, onAllowanceHookSource };
