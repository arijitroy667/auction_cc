import { bytesToBigInt, bytesToHex, hexToBigInt, hexToBytes, toBytes, toHex, } from "viem";
import { universeFromJSON, universeToJSON, } from "../proto/definition";
import { convertToBufferIfNecessary } from "./utils";
export function encodeChainID36(universe, chainID) {
    let chainIDB;
    if (Buffer.isBuffer(chainID) || chainID instanceof Uint8Array) {
        chainIDB = chainID;
    }
    else {
        chainIDB = toBytes(chainID);
    }
    const buf = Buffer.alloc(36);
    buf.writeUint32BE(universe);
    buf.set(chainIDB, 4 + (32 - chainIDB.length));
    return buf;
}
export class OmniversalChainID {
    universe;
    chainID;
    binaryForm;
    constructor(universe, chainID) {
        this.universe = universe;
        if (typeof chainID === "bigint") {
            this.chainID = chainID;
        }
        else if (typeof chainID === "number" || typeof chainID === "string") {
            this.chainID = BigInt(chainID);
        }
        else if (chainID instanceof Uint8Array) {
            this.chainID = bytesToBigInt(chainID);
        }
        this.binaryForm = encodeChainID36(this.universe, this.chainID);
    }
    toString() {
        return universeToJSON(this.universe) + "_" + this.chainID.toString(10);
    }
    toJSON() {
        return {
            universe: universeToJSON(this.universe),
            chainID: toHex(this.chainID),
        };
    }
    static fromJSON(input) {
        return new OmniversalChainID(universeFromJSON(input.universe), hexToBigInt(input.chainID));
    }
    static fromChainID36(_input) {
        const input = convertToBufferIfNecessary(_input);
        const univID = input.readUint32BE(0);
        const rest = input.subarray(4);
        return new OmniversalChainID(univID, rest);
    }
    // Do not modify the returned buffer. Make a copy if necessary.
    toBytes() {
        return this.binaryForm;
    }
    equals(rhs) {
        return this.universe === rhs.universe && this.chainID === rhs.chainID;
    }
    static equals(lhs, rhs) {
        return lhs.equals(rhs);
    }
}
export class ChainIDKeyedMap {
    map;
    constructor(entries = null) {
        this.map = new Map(entries != null
            ? entries.map((e) => [bytesToHex(e[0].toBytes()), e[1]])
            : null);
    }
    get(key) {
        return this.map.get(bytesToHex(key.toBytes()));
    }
    set(key, value) {
        this.map.set(bytesToHex(key.toBytes()), value);
        return this;
    }
    getFromChainID36(key) {
        return this.map.get(bytesToHex(key));
    }
    *entries() {
        for (const [key, value] of this.map.entries()) {
            yield [OmniversalChainID.fromChainID36(hexToBytes(key)), value];
        }
    }
}
