import Decimal from "decimal.js";
import { Aggregator, Quote, QuoteRequestExactInput, QuoteRequestExactOutput } from "./iface";
import { Currency, CurrencyID, OmniversalChainID } from "../data";
import { Bytes } from "../types";
import { FixedFeeTuple } from "../proto/definition";
type Asset = {
    tokenAddress: Bytes;
    amount: bigint;
};
export type Holding = {
    chainID: OmniversalChainID;
    value: number;
} & Asset;
export declare class AutoSelectionError extends Error {
}
declare const enum AggregateAggregatorsMode {
    MaximizeOutput = 0,
    MinimizeInput = 1
}
export declare function aggregateAggregators(requests: (QuoteRequestExactInput | QuoteRequestExactOutput)[], aggregators: Aggregator[], mode: AggregateAggregatorsMode): Promise<{
    quote: Quote | null;
    aggregator: Aggregator;
}[]>;
export declare function autoSelectSources(userAddress: Bytes, holdings: Holding[], outputRequired: Decimal, aggregators: Aggregator[], collectionFees: FixedFeeTuple[], commonCurrencyID?: CurrencyID): Promise<({
    req: QuoteRequestExactInput;
    cfee: bigint;
    originalHolding: Holding;
    cur: Currency;
} & {
    quote: Quote;
    agg: Aggregator;
})[]>;
export declare function determineDestinationSwaps(userAddress: Bytes, receiverAddress: Bytes | null, chainID: OmniversalChainID, requirement: Asset, aggregators: Aggregator[], commonCurrencyID?: CurrencyID): Promise<{
    quote: Quote | null;
    aggregator: Aggregator;
    inputAmount: Decimal;
    outputAmount: bigint;
}>;
export declare function liquidateInputHoldings(userAddress: Bytes, holdings: Holding[], aggregators: Aggregator[], collectionFees: FixedFeeTuple[], commonCurrencyID?: CurrencyID): Promise<{
    quotes: {
        agg: Aggregator;
        quote: Quote;
        req: QuoteRequestExactInput;
        cfee: bigint;
        originalHolding: Holding;
        cur: Currency;
        aggregator: Aggregator;
    }[];
    total: Decimal;
}>;
export declare function destinationSwapWithExactIn(userAddress: Bytes, chainID: OmniversalChainID, inputAmount: bigint, outputToken: Bytes, aggregators: Aggregator[], commonCurrencyID?: CurrencyID): Promise<{
    inputAmount: Decimal;
    outputAmount: bigint;
    quote: Quote | null;
    aggregator: Aggregator;
}>;
export {};
