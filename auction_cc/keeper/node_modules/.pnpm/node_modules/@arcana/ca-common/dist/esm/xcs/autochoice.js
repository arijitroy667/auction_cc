import { groupBy, orderBy } from "es-toolkit";
import { bytesToBigInt, bytesToHex } from "viem";
import Decimal from "decimal.js";
import { QuoteType, } from "./iface";
import { ChaindataMap, convertBigIntToDecimal, convertDecimalToBigInt, CurrencyID, maxByBigInt, minByByBigInt, } from "../data";
export class AutoSelectionError extends Error {
}
const safetyMultiplier = new Decimal("1.025");
export async function aggregateAggregators(requests, aggregators, mode) {
    const responses = await Promise.all(aggregators.map(async (agg) => {
        let quotes;
        try {
            quotes = await agg.getQuotes(requests);
        }
        catch (e) {
            console.log("XCS | Failed to get quote from", agg, "in aggregateAggregators.", requests, "with:", e);
            quotes = new Array(requests.length).fill(null);
        }
        return {
            quotes,
            agg,
        };
    }));
    const final = new Array(requests.length);
    switch (mode) {
        case 0 /* AggregateAggregatorsMode.MaximizeOutput */: {
            for (let i = 0; i < requests.length; i++) {
                const best = maxByBigInt(responses.map((ra) => ({ quote: ra.quotes[i], aggregator: ra.agg })), (r) => r.quote?.outputAmountMinimum ?? 0n);
                if (best != null) {
                    final[i] = best;
                }
                else {
                    final[i] = {
                        quote: null,
                        aggregator: aggregators[0],
                    };
                }
            }
            break;
        }
        case 1 /* AggregateAggregatorsMode.MinimizeInput */: {
            for (let i = 0; i < requests.length; i++) {
                const best = minByByBigInt(responses.map((ra) => ({ quote: ra.quotes[i], aggregator: ra.agg })), (r) => r.quote?.inputAmount ?? 0n);
                if (best != null) {
                    final[i] = best;
                }
                else {
                    final[i] = {
                        quote: null,
                        aggregator: aggregators[0],
                    };
                }
            }
            break;
        }
    }
    return final;
}
export async function autoSelectSources(userAddress, holdings, outputRequired, aggregators, collectionFees, commonCurrencyID = CurrencyID.USDC) {
    console.log("XCS | SS | Holdings:", holdings);
    const groupedByChainID = groupBy(holdings, (h) => bytesToHex(h.chainID.toBytes()));
    const fullLiquidationQuotes = [];
    for (const holdings of Object.values(groupedByChainID)) {
        const chain = ChaindataMap.get(holdings[0].chainID);
        if (chain == null) {
            throw new AutoSelectionError("Chain not found");
        }
        const correspondingCurrency = chain.Currencies.find((cur) => cur.currencyID === commonCurrencyID);
        if (correspondingCurrency == null) {
            console.log("XCS | SS | Skipping because correspondingCurrency is null", {
                chain,
                correspondingCurrency,
            });
            continue;
        }
        const cfeeTuple = collectionFees.find((cf) => {
            return (cf.universe === chain.Universe &&
                Buffer.compare(cf.chainID, chain.ChainID32) === 0 &&
                // output token is the CA one
                Buffer.compare(cf.tokenAddress, correspondingCurrency.tokenAddress) ===
                    0);
        });
        const cfee = cfeeTuple != null ? bytesToBigInt(cfeeTuple.fee) : 0n;
        for (const holding of holdings) {
            if (Buffer.compare(holding.tokenAddress, correspondingCurrency.tokenAddress) === 0) {
                console.log("XCS | SS | Disqualifying", holding, "because holding.tokenAddress = CA asset");
                continue;
            }
            fullLiquidationQuotes.push({
                req: {
                    userAddress,
                    receiverAddress: null,
                    type: QuoteType.ExactIn,
                    chain: chain.ChainID,
                    inputToken: holding.tokenAddress,
                    inputAmount: holding.amount,
                    outputToken: correspondingCurrency.tokenAddress,
                },
                // necessary for various purposes
                cfee,
                originalHolding: holding,
                cur: correspondingCurrency,
            });
        }
    }
    // const groupedByChainID = groupBy(quoteOutputs, h => h.chainIDHex)
    const quotesByValue = orderBy(fullLiquidationQuotes, [
        (quoteOut) => quoteOut.cfee,
        (quoteOut) => quoteOut.originalHolding.value, // once optimized for collections, we select the biggest asset we hold
    ], ["asc", "desc"]);
    const responses = await aggregateAggregators(quotesByValue.map((fq) => fq.req), aggregators, 0 /* AggregateAggregatorsMode.MaximizeOutput */);
    console.log("XCS | SS | Responses:", responses);
    const final = [];
    let remainder = outputRequired; // assuming all that chains have the same amount of fixed point places
    for (let i = 0; i < quotesByValue.length; i++) {
        if (remainder.lte(0)) {
            break;
        }
        const q = quotesByValue[i];
        const { quote: resp, aggregator: agg } = responses[i];
        if (resp == null) {
            continue;
        }
        console.log("XCS | SS | 1", {
            i,
            remainder,
            q,
            resp,
            agg,
        });
        const divisor = Decimal.pow(10, q.cur.decimals);
        const oamD = convertBigIntToDecimal(resp.outputAmountMinimum).div(divisor);
        if (oamD.gt(remainder)) {
            const indicativePrice = convertBigIntToDecimal(resp.inputAmount).div(convertBigIntToDecimal(resp.outputAmountMinimum));
            const userBal = convertBigIntToDecimal(q.originalHolding.amount);
            // remainder is the output we want, so the input amount is remainder × indicativePrice
            let expectedInput = Decimal.min(remainder.mul(divisor).mul(indicativePrice).mul(safetyMultiplier), userBal);
            while (true) {
                console.log("XCS | SS | 2⒜", {
                    indicativePrice,
                    expectedInput,
                    userBal,
                });
                const adequateQuoteResult = await aggregateAggregators([
                    {
                        ...q.req,
                        inputAmount: convertDecimalToBigInt(expectedInput),
                    },
                ], aggregators, 0 /* AggregateAggregatorsMode.MaximizeOutput */);
                if (adequateQuoteResult.length !== 1) {
                    throw new AutoSelectionError("???");
                }
                const adequateQuote = adequateQuoteResult[0];
                if (adequateQuote.quote == null) {
                    throw new AutoSelectionError("Couldn't get buy quote");
                }
                console.log("XCS | SS | 2⒜⑴", {
                    adequateQuote,
                });
                const oam2D = convertBigIntToDecimal(adequateQuote.quote.outputAmountMinimum).div(divisor);
                if (oam2D.gte(remainder)) {
                    final.push({
                        ...q,
                        quote: adequateQuote.quote,
                        agg: adequateQuote.aggregator,
                    });
                    remainder = remainder.minus(oam2D);
                    break;
                }
                else if (expectedInput.eq(userBal)) {
                    throw new AutoSelectionError("Holding was supposedly enough to meet the full requirement but ceased to be so subsequently");
                }
                else {
                    expectedInput = Decimal.min(expectedInput.mul(safetyMultiplier), userBal); // try again with higher amount
                }
            }
        }
        else {
            console.log("XCS | SS | 2⒝", resp);
            final.push({
                ...q,
                quote: resp,
                agg,
            });
            remainder = remainder.minus(convertBigIntToDecimal(resp.outputAmountMinimum).div(divisor));
        }
    }
    console.log("XCS | SS | 3⒜", {
        remainder,
        final,
    });
    if (remainder.gt(0)) {
        throw new AutoSelectionError("Failed to accumulate enough swaps to meet requirement");
    }
    console.log("XCS | SS | Final:", final);
    return final;
}
export async function determineDestinationSwaps(userAddress, receiverAddress, chainID, requirement, aggregators, commonCurrencyID = CurrencyID.USDC) {
    const chaindata = ChaindataMap.get(chainID);
    if (chaindata == null) {
        throw new AutoSelectionError("Chain not found");
    }
    const COT = chaindata.Currencies.find((cur) => cur.currencyID === commonCurrencyID);
    if (COT == null) {
        throw new AutoSelectionError("COT not present on the destination chain");
    }
    // what happens if we happen to sell the requirement for the COT, what would the amount be?
    const fullLiquidationQR = {
        type: QuoteType.ExactIn,
        chain: chainID,
        userAddress,
        receiverAddress: null,
        inputToken: requirement.tokenAddress,
        outputToken: COT.tokenAddress,
        inputAmount: requirement.amount,
    };
    const fullLiquidationResult = await aggregateAggregators([fullLiquidationQR], aggregators, 0 /* AggregateAggregatorsMode.MaximizeOutput */);
    if (fullLiquidationResult.length !== 1) {
        throw new AutoSelectionError("???");
    }
    const fullLiquidationQuote = fullLiquidationResult[0];
    if (fullLiquidationQuote.quote == null) {
        throw new AutoSelectionError("Couldn't get full liquidation quote");
    }
    let curAmount = convertBigIntToDecimal(fullLiquidationQuote.quote.outputAmountLikely).mul(safetyMultiplier);
    console.log("XCS | DDS | 1⒜", {
        fullLiquidationQR,
        fullLiquidationResult,
        COT,
    });
    while (true) {
        const buyQuoteResult = await aggregateAggregators([
            {
                type: QuoteType.ExactIn,
                userAddress,
                receiverAddress,
                chain: chainID,
                inputToken: COT.tokenAddress,
                outputToken: requirement.tokenAddress,
                inputAmount: convertDecimalToBigInt(curAmount),
            },
        ], aggregators, 0 /* AggregateAggregatorsMode.MaximizeOutput */);
        if (buyQuoteResult.length !== 1) {
            throw new AutoSelectionError("???");
        }
        const buyQuote = buyQuoteResult[0];
        if (buyQuote.quote == null) {
            throw new AutoSelectionError("Couldn't get buy quote");
        }
        console.log("XCS | DDS | 2⒜ iteration", {
            buyQuote,
            curAmount,
        });
        if (buyQuote.quote.outputAmountMinimum >= requirement.amount) {
            return {
                ...buyQuote,
                inputAmount: convertBigIntToDecimal(buyQuote.quote.inputAmount).div(Decimal.pow(10, COT.decimals)),
                outputAmount: requirement.amount,
            };
        }
        else {
            curAmount = curAmount.mul(safetyMultiplier); // try again with higher amount
        }
    }
}
export async function liquidateInputHoldings(userAddress, holdings, aggregators, collectionFees, commonCurrencyID = CurrencyID.USDC) {
    console.log("XCS | LIH | Holdings:", holdings);
    const groupedByChainID = groupBy(holdings, (h) => bytesToHex(h.chainID.toBytes()));
    const fullLiquidationQuotes = [];
    for (const holdings of Object.values(groupedByChainID)) {
        const chain = ChaindataMap.get(holdings[0].chainID);
        if (chain == null) {
            throw new AutoSelectionError("Chain not found");
        }
        const correspondingCurrency = chain.Currencies.find((cur) => cur.currencyID === commonCurrencyID);
        if (correspondingCurrency == null) {
            console.log("XCS | LIH | Skipping because correspondingCurrency is null", {
                chain,
                correspondingCurrency,
            });
            continue;
        }
        const cfeeTuple = collectionFees.find((cf) => {
            return (cf.universe === chain.Universe &&
                Buffer.compare(cf.chainID, chain.ChainID32) === 0 &&
                // output token is the CA one
                Buffer.compare(cf.tokenAddress, correspondingCurrency.tokenAddress) ===
                    0);
        });
        const cfee = cfeeTuple != null ? bytesToBigInt(cfeeTuple.fee) : 0n;
        for (const holding of holdings) {
            if (Buffer.compare(holding.tokenAddress, correspondingCurrency.tokenAddress) === 0) {
                console.log("XCS | LIH | Disqualifying", holding, "because holding.tokenAddress = CA asset");
                continue;
            }
            fullLiquidationQuotes.push({
                req: {
                    userAddress,
                    type: QuoteType.ExactIn,
                    chain: chain.ChainID,
                    receiverAddress: null,
                    inputToken: holding.tokenAddress,
                    inputAmount: holding.amount,
                    outputToken: correspondingCurrency.tokenAddress,
                },
                // necessary for various purposes
                cfee,
                originalHolding: holding,
                cur: correspondingCurrency,
            });
        }
    }
    const responses = await aggregateAggregators(fullLiquidationQuotes.map((fq) => fq.req), aggregators, 0 /* AggregateAggregatorsMode.MaximizeOutput */);
    console.log("XCS | LIH | Responses:", responses);
    const validResponses = responses
        .filter((r) => r.quote !== null)
        .map((r, i) => ({
        ...r,
        ...fullLiquidationQuotes[i],
        agg: r.aggregator,
        quote: r.quote,
    }));
    const total = validResponses.reduce((acc, r) => {
        return acc.add(new Decimal(r.quote.outputAmountMinimum ?? 0n).div(Decimal.pow(10, r.cur.decimals)));
    }, new Decimal(0));
    return {
        quotes: validResponses,
        total,
    };
}
export async function destinationSwapWithExactIn(userAddress, chainID, inputAmount, outputToken, aggregators, commonCurrencyID = CurrencyID.USDC) {
    const chaindata = ChaindataMap.get(chainID);
    if (chaindata == null) {
        throw new AutoSelectionError("Chain not found");
    }
    const COT = chaindata.Currencies.find((cur) => cur.currencyID === commonCurrencyID);
    if (COT == null) {
        throw new AutoSelectionError("COT not present on the destination chain");
    }
    const fullLiquidationResult = await aggregateAggregators([
        {
            type: QuoteType.ExactIn,
            chain: chainID,
            userAddress,
            receiverAddress: null,
            inputToken: COT.tokenAddress,
            outputToken: outputToken,
            inputAmount: inputAmount,
            // seriousness: QuoteSeriousness.SERIOUS,
        },
    ], aggregators, 0 /* AggregateAggregatorsMode.MaximizeOutput */);
    if (fullLiquidationResult.length !== 1) {
        throw new AutoSelectionError("???");
    }
    const fullLiquidationQuote = fullLiquidationResult[0];
    if (fullLiquidationQuote.quote == null) {
        throw new AutoSelectionError("Couldn't get full liquidation quote");
    }
    return {
        ...fullLiquidationQuote,
        inputAmount: convertBigIntToDecimal(inputAmount).div(Decimal.pow(10, COT.decimals)),
        outputAmount: fullLiquidationQuote.quote.outputAmountMinimum,
    };
}
